<bb2doc>
  <command name="LoadAnim">
    <keyword>LoadAnim</keyword>
    <fullCommand>LoadAnim Anim#,Filename$[,Palette#]</fullCommand>
    <parameters>Anim#,Filename$[,Palette#]</parameters>
    <shortDescription />
    <longDescription>The LoadAnim command will create an Anim object and load a DPaint compatible
animation. The ILBMInfo command can be used to find the correct screensize and
resolution for the anim file. The optional Palette# parameter can be used to load a
palette with the anims correct colours.</longDescription>
  </command>
  <command name="InitAnim">
    <keyword>InitAnim</keyword>
    <fullCommand>InitAnim Anim#[,BitMap#]</fullCommand>
    <parameters>Anim#[,BitMap#]</parameters>
    <shortDescription />
    <longDescription>InitAnim renders the first two frames of the Anim onto the current BitMap and the
BitMap specified by the second parameter. The second BitMap# parameter is optional,
this is to support Anims that are not in a double- buffered format (each frame is a
delta of the last frame not from two frames ago). However, the two parameter double
buffered form of InitAnim should always be used. (hmmm don't ask me O.K.!).</longDescription>
  </command>
  <command name="NextFrame">
    <keyword>NextFrame</keyword>
    <fullCommand>NextFrame Anim#</fullCommand>
    <parameters>Anim#</parameters>
    <shortDescription />
    <longDescription>NextFrame renders the nextframe of an Anim to the current BitMap. If the last frame
of an Anim has been rendered NextFrame will loop back to the start of the Animation.</longDescription>
  </command>
  <command name="Frames">
    <keyword>Frames</keyword>
    <fullCommand>Frames(Anim#)</fullCommand>
    <parameters>(Anim#)</parameters>
    <shortDescription />
    <longDescription>The Frames() function returns the number of frames in the specified Anim.</longDescription>
  </command>
  <command name="CreateRexxMsg">
    <keyword>CreateRexxMsg</keyword>
    <fullCommand>CreateRexxMsg MsgPtr=CreateRexxMsg(ReplyPort,Exten,Host)</fullCommand>
    <parameters>MsgPtr=CreateRexxMsg(ReplyPort,Exten,Host)</parameters>
    <shortDescription />
    <longDescription>CreateRexxMsg() allocates a special Message structure used to communicate with
Arexx. If all is successful it returns the LONGWORD address of this rexxmsg
structure.

The arguments are ReplyPort which is the long address returned by CreateMsgPort().
This is the Port that ARexx will reply to after it has finished with the message.

EXTEN which is the exten name used by any ARexx script you are wishing to run. i.e.
if you are attempting to run the ARexx script test.rexx you would use an EXTEN of
"rexx".

HOST is the name string of the HOST port. Your program is usually the HOST and so
this equates to the name you gave your port in CreateMsgPort(). REMEMBER IT IS CASE
SENSITIVE.

As we are allocating resources error checking is important and can be achieved with
the following code:

msg.l=CreateRexxMsg(Port,"rexx","HostName")
IF msg=0 THEN Error_Routine{}.</longDescription>
  </command>
  <command name="DeleteRexxMsg">
    <keyword>DeleteRexxMsg</keyword>
    <fullCommand>DeleteRexxMsg rexxmsg.l</fullCommand>
    <parameters>rexxmsg.l</parameters>
    <shortDescription />
    <longDescription>DeleteRexxMsg simply deletes a RexxMsg Structure previously allocated by
CreateRexxMsg(). It takes a single argument which is the long address of a RexxMsg
structure such as returned by CreateRexxMsg().


msg.l=CreateRexxMsg(Port,"rexx","HostName")
IF msg=0 THEN Error Routine()
DeleteRexxMsg msg


Again if you neglect to delete the RexxMsg structure Blitz will do this for you on
exit of the program.</longDescription>
  </command>
  <command name="FillRexxMsg">
    <keyword>FillRexxMsg</keyword>
    <fullCommand>FillRexxMsg rexxmsg,&amp;FillStruct</fullCommand>
    <parameters>rexxmsg,&amp;FillStruct</parameters>
    <shortDescription />
    <longDescription>FillRexxMsg allows you to fill all 16 ARGSlots if necessary with either ArgStrings
or numerical values depending on your requirement.

FillRexxMsg will only be used by those programmers wishing to do more advanced
things with Arexx, including adding libraries to the ARexx library list, adding
Hosts, Value Tokens etc. It is also needed to access Arexx using the #RXFUNC flag.

The arguments are a LONG Pointer to a rexxmsg. The LONG address of a FillStruct
NEWTYPE structure. This structure is defined in the Arexx.res and has the following
form.

NEWTYPE .FillStruct

     Flags.w  ;Flag block
     Args0.1  ; argument block (ARG0-ARG15)
     Args1.1  ; argument block (ARG0-ARG15)
     Args2.1  ; argument block (ARG0-ARG15)
     Args3.1  ; argument block (ARG0-ARG15)
     Args4.1  ; argument block (ARG0-ARG15)
     Args5.1  ; argument block (ARG0-ARG15)
     Args6.1  ; argument block (ARG0-ARG15)
     Args7.1  ; argument block (ARG0-ARG15)
     Args8.1  ; argument block (ARG0-ARG15)
     Args9.1  ; argument block (ARG0-ARG15)
     Args10.1 ; argument block (ARG0-ARG15)
     Args11.1 ; argument block (ARG0-ARG15)
     Args12.1 ; argument block (ARG0-ARG15)
     Args13.1 ; argument block (ARG0-ARG15)
     Args14.1 ; argument block (ARG0-ARG15)
     Args15.1 ; argument block (ARG0-ARG15)
     EndMark.l; End of the FillStruct

End NEWTYPE

The Args?.l are the 16 slots that can possibly be filled ready for converting into
the RexxMsg structure.

The Flags.w is a WORD value representing the type of LONG word you are supplying for
each ARGSLOT (Arg?.l).

Each bit in the Flags WORD is representative of a single Args?.l, where a set bit
represents a numerical value to be passed and a clear bit represents a string
argument to be converted into a ArgString before installing in the RexxMsg. The
Flags Value is easiest to supply as a binary number to make the bits visible and
would look like this.

%0000000000000000 ;represents that all Arguments are Strings.
%0110000000000000 ;represent second&amp;third as being integers.

FillRexxMsg expects to find the address of any strings in the Args?.l slots so it is
important to remember when filling a FillStruct that you must pass the string
address and not the name of the string. This is acomplished using the '&amp;' address of
operand.


So to use FillRexxMsg we must do the following things in our program:

1. Allocate a FillStruct
2. Set the flags in the FillStruct\Flags.w
3. Fill the FillStruct with either integer values or the addresses of our string
   arguments.
4. Call FillRexxMsg with the LONG address of our rexxmsg and the LONG address of our
   FillStruct.


To accomplish this takes the following code:

     ;Allocate our FillStruct (called F)
     DEFTYPE.FillStruct F
     ;assign some string arguments
     T$="open":T1$="-0123456789"
     ;Fill in our FillStruct with flags and (&amp;) addresses of our strings
     PFlags= %0010000000000000,&amp;T$,&amp;T1$,4
     ;Third argument here is an integer (4).
     Port.l=CreateMsgPort("host")
     msg.l=CreateRexxMsg(Port,"vc","host")
     FillRexxMsg msg,&amp;F
     ;&amp;lt;-3 args see #RXFUNC
     SendRexxCommand msg,"",#RXFUNC #RXFF_RESULT 3.</longDescription>
  </command>
  <command name="ClearRexxMsg">
    <keyword>ClearRexxMsg</keyword>
    <fullCommand>ClearRexxMsg rexxmsg</fullCommand>
    <parameters>rexxmsg</parameters>
    <shortDescription />
    <longDescription>ClearRexxMsg is used to delete and clear an ArgString from one or more of the
Argument slots in a RexxMsg Structure.

This is most useful for the more advanced programmer wishing to take advantage of
the Arexx #RXFUNC abilities.

The arguments are a LONGWORD address of a RexxMsg structure. ClearRexxMsg will
always work from slot number 1 forward to 16.</longDescription>
  </command>
  <command name="CreateArgString">
    <keyword>CreateArgString</keyword>
    <fullCommand>CreateArgString ArgString=CreateArgString(String)</fullCommand>
    <parameters>ArgString=CreateArgString(String)</parameters>
    <shortDescription />
    <longDescription>CreateArgString() builds an ARexx compatible ArgString structure around the provided
string. All strings sent to, or received from Arexx are in the form of ArgStrings.
See the TYPE RexxARG.

If all is well the return will be a LONG address of the ArgString structure. The
pointer will actually point to the NULL terminated String with the remainder of the
structure available at negative offsets.</longDescription>
  </command>
  <command name="DeleteArgString">
    <keyword>DeleteArgString</keyword>
    <fullCommand>DeleteArgString argstring</fullCommand>
    <parameters>argstring</parameters>
    <shortDescription />
    <longDescription>DeleteArgString is designed to Delete ArgStrings allocated by either Blitz or ARexx
in a system friendly way. It takes only one argument the LONGWORD address of an
ArgString as returned by CreateArgString().</longDescription>
  </command>
  <command name="SendRexxCommand">
    <keyword>SendRexxCommand</keyword>
    <fullCommand>SendRexxCommand rexxmsg,CommandString,ActionCodes</fullCommand>
    <parameters>rexxmsg,CommandString,ActionCodes</parameters>
    <shortDescription />
    <longDescription>SendRexxCommand is designed to fill and send a RexxMsg structure to ARexx inorder to
get ARexx to do something on your behalf. The arguments are as follows;

rexxmsg: the LONGWORD address of a RexxMsg structure as returned by CreateRexxMsg().

commands/ring: the command string you wish to send to ARexx. This is a string as in
"this is a string" and will vary depending on what you wish to do with ARexx.

Normally this will be the name of an ARexx script file you wish to execute. ARexx
will then look for the script by the name as well as the name with the exten added.
(this is the exten you used when you created the RexxMsg structure using
CreateRexxMsg()). This could also be a string file. That is a complete ARexx script
in a single line.

ActionCodes: the flag values you use to tell ARexx what you want it to do with the
commandstring you have supplied.


COMMAND (ACTION) CODES 

The command codes that are currently implemented in the resident process are
described below. Commands are listed by their mnemonic codes,followed by the valid
modifier flags. The final code value is always the logical OR of the code value and
all of the modifier flags selected. The command code is installed in the rm_Action
field of the message packet.

RXADDCON:

This code specifies an entry to be added to the Clip List. Parameter slot ARG0
points to the name string,slot ARG1 points to the value string,and slot ARG2
contains the length of the value string.

The name and value arguments do not need to be argstrings, but can be just pointers
to storage areas. The name should be a null-terminated string, but the value can
contain arbitrary data including nulls.

RXADDFH:

This action code specifies a function host to be added to the Library List.
Parameter slot ARG0 points to the (null-terminated) host name string, and slot ARG1
holds the search priority for the node.

The search priority should be an integer between 100 and -100 inclusive; the
remaining priority ranges are reserved for future extensions. If a node already
exists with the same name,the packet is returned with a warning level error code.

Note that no test is made at this time as to whether the host port exists.

RXADDLIB:

This code specifies an entry to be added to the Library List. Parameter slot ARG0
points to a null-terminated name string referring either to a function library or a
function host. Slot ARG1 is the priority for the node and should be an integer
between 100 and -100 inclusive; the remaining priority ranges are reserved for
future extensions. Slot ARG2 contains the entry Point offset and slot ARG3 is the
library version number.

If a node already exists with the same name, the packet is returned with a warning
level error code. Otherwise,a new entry is added and the library or host becomes
available to ARexx programs. Note that no test is made at this time as to whether
the library exists and can be opened

RXCOMM [RXFF_TOKEN] [RXFF_STRING] [RXFF_RESULT] [RXFF_NOIO] 

Specifies a command-mode invocation of an ARexx program. Parameter slot ARG0 must
contain an argstring Pointer to the command string. The RXFB_TOKEN flag specifies
that the command line is to be tokenized before being passed to the invoked program.
The RXFB_STRING flag bit indicates that the command string is a "string file"
Command invocations do not normally return result strings,but the RXFB_RESULT flag
can be set if the caller is prepared to handle the cleanup associated with a
returned string. The RXFB_NOIO modifier suppresses the inheritance of the host's
input and output streams.

RXFUNC [RXFF_RESULT] [RXFF_STRING] [RXFF_NOIO] argcount 

This command code specifies a function invoction. Parameter slot ARG0 contains a
pointer to the function name string,and slots ARG1 through ARG15 point to the
argument strings, all of which must be passed as argstrings. The lower byte of the
command code is the argument count; this count excludes the function name string
itself.

Function calls normally set the RXFB_RESULT flag, but this is not mandatory. The
RXFB_STRING modifier indicates that the function name string is actually a "string
file". The RXFB_NOIO modifier suppresses the inheritance of the host's input and
output streams.

RXREMCON:

This code requests that an entry be removed from the Clip List. Parameter slot ARG0
points to the null-terminated name to be removed.

The Clip List is searched for a node matching the supplied name,and if a match is
tound the list node is removed and recycled.

If no match is found the packet is returned with a warning error code.

RXREMLIB:

This command removes a Library List entry. Parameter slot ARG0 points to the null
terminated string specifying the library to be removed. The Library List is searched
for a node matching the library name,and if a match is found the node is removed and
released.

If no match is found the packet is returned with a warning error code. The libary
node will not be removed if the library is currently being used by an ARexx program.

RXTCCLS:

This code requests that the global tracing console be closed. The console window
will be closed immediately unless one or more ARexx programs are waiting for input
from the console. In this event,the window will be closed as soon as the active
programs are no longer using it.

RXTCOPN:

This command requests that the global tracing console be opened. Once the console is
open,all active ARexx programs will divert their tracing output to the console.
Tracing input (for interactive debugging) will also be diverted to the new console.

Only one console can be opened; subsequent RXTCOPN requests will be returned with a
warning error message.



MODIFIER FLAGS 

Command codes may include modifier flags to select various processing options.
Modifier flags are specific to certain commands,and are ignored otherwise.

RXFF_NOIO: 

This modifier is used with the RXCOMM and RXFUNC command codes to suppress the
automatic inheritance of the host's input and output streams.

RXFF_NONRET: 

Specifies that the message packet is to be recycled by the resident process rather
than being returned to the sender. This implies that the sender doesn't care about
whether the requested action succeeded, since the returned packet provides the only
means of acknowledgement. (RXFF_NONRET MUST NOT BE USED AT ANY TIME)

RXFF_RESULT: 

This modifer is valid with the RXCOMM and RXFUNC commands,and requests that the
called program return a result string. If the program EXITs (or RETURNs) with an
expression, the expression result is returned to the caller as an argstring.

This ArgString then becomes the callers responsibility to release. This is
automatically accomplished by using GetResultString(). It is therefore imperitive
that if you use RXFF_RESULT then you must use GetResultString() when the message
packet is returned to you or you will incure a memory loss equal to the size of the
ArgString Structure.

RXFF_STRING: 

This modifer is valid with the RXCOMM and RXFUNC command codes. It indicates that
the command or function argument (in slot ARG0) is a "string file" rather than a
file name.

RXFF_TOKEN: 

This flag is used with the RXCOMM code to request that the command string be
completely tokenized before being passed to the invoked program. Programs invoked as
commands normally have only a single argument string. The tokenization process uses
"white space" to separate the tokens, except within quoted strings.

Quoted strings can use either single or double quotes, and the end of the command
string (a null character) is considered as an implicit closing quote.</longDescription>
  </command>
  <command name="ReplyRexxMsg">
    <keyword>ReplyRexxMsg</keyword>
    <fullCommand>ReplyRexxMsg rexxmsg,Result1,Result2,ResultString</fullCommand>
    <parameters>rexxmsg,Result1,Result2,ResultString</parameters>
    <shortDescription />
    <longDescription>When ARexx sends you a RexxMsg (Other than a reply to yours i.e. sending yours back
to you with results) you must reply to the message before ARexx will continue or
free that memory associated with that RexxMsg. ReplyRexxMsg accomplishes this for
you.

ReplyRexxMsg also will only reply to message that requires a reply so you do not
have to include message checking routines in your source simply call ReplyRexxMsg on
every message you receive wether it is a command or not.

The arguments are:

rexxmsg is the LONGWORD address of the RexxMsg Arexx sent you as returned by
GetMsg_(Port).

Result1 is 0 or a severity value if there was an error.

Result2 is 0 or an Arexx error number if there was an error processing the command
that was contained in the message.

ResultString is the result string to be sent back to Arexx. This will only be sent
if Arexx requested one and Result1 and 2 are 0.

ReplyRexxMsg rexxmsg,0,0,"THE RETURNED MESSAGE".</longDescription>
  </command>
  <command name="GetRexxResult">
    <keyword>GetRexxResult</keyword>
    <fullCommand>GetRexxResult Result=GetRexxResult(rexxmsg,ResultNum)</fullCommand>
    <parameters>Result=GetRexxResult(rexxmsg,ResultNum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetRexxCommand">
    <keyword>GetRexxCommand</keyword>
    <fullCommand>GetRexxCommand String=GetRexxCommand(rexxmsg,ARGNum)</fullCommand>
    <parameters>String=GetRexxCommand(rexxmsg,ARGNum)</parameters>
    <shortDescription />
    <longDescription>GetRexxCommand allows you access to all 16 ArgString slots in the given RexxMsg.
Slot 1 contains the command string sent by ARexx in a command message so this allows
you to extract the Command.

Arguments are:

rexxmsg is a LONGWORD address of the RexxMsg structure as returned by RexxEvent()

AFGNum is an integer from 1 to 16 specifying the ArgString Slot you wish to get an
ArgString from.

YOU MUST KNOW THAT THERE IS AN ARGSTRING THERE. .</longDescription>
  </command>
  <command name="GetResultString">
    <keyword>GetResultString</keyword>
    <fullCommand>GetResultString String=GetResultString(rexxmsg)</fullCommand>
    <parameters>String=GetResultString(rexxmsg)</parameters>
    <shortDescription />
    <longDescription>GetResultString allows you to extract the result string returned to you by ARexx
after it has completed the action you requested. ARexx will only send back a result
string if you asked for one (using the ActionCodes) and the requested action was
successful.</longDescription>
  </command>
  <command name="RexxEvent">
    <keyword>RexxEvent</keyword>
    <fullCommand>RexxEvent rexxmsg=RexxEvent(PortAddress)</fullCommand>
    <parameters>rexxmsg=RexxEvent(PortAddress)</parameters>
    <shortDescription />
    <longDescription>RexxEvent is our Arexx Equivalent of EVENT(). It's purpose is to check the given
Port to see if there is a message waiting there for us.

It should be called atter a WAIT and will either return a NULL to us if there was no
message or the LONG address of a RexxMsg Structure if there was a message waiting.

Multiple Arexx MsgPorts can be handled using separate calls to RexxEvent():

Wait:Rmsg1.1=RexxEvent(Port1):Rmsg2.1=RexxEvent(Port2):etc

RexxEvent also takes care of automatically clearing the rexxmsg if it is our message
being returned to us.

The argument is the LONG address of a MsgPort as returned by CreateMsgPort().</longDescription>
  </command>
  <command name="IsRexxMsg">
    <keyword>IsRexxMsg</keyword>
    <fullCommand>IsRexxMsg Boolean=IsRexxMsg(rexxmsg)</fullCommand>
    <parameters>Boolean=IsRexxMsg(rexxmsg)</parameters>
    <shortDescription />
    <longDescription>IsRexxMsg tests the argument (a LONGWORD pointer hopefully to a message packet) to
see if it is a RexxMsg Packet. If it is TRUE is returned (1) or FALSE if it is not
(0).

As the test is non destructive and extensive passing a NULL value or a LONGWORD that
does not point to a Message structure (Intuition or Arexx) will safely return as
FALSE.</longDescription>
  </command>
  <command name="RexxError">
    <keyword>RexxError</keyword>
    <fullCommand>RexxError ErrorString=RexxError(ErrorCode)</fullCommand>
    <parameters>ErrorString=RexxError(ErrorCode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DiskPlay">
    <keyword>DiskPlay</keyword>
    <fullCommand>DiskPlay Filename$,Channelmask[,Vol1[,Vol2...]]</fullCommand>
    <parameters>Filename$,Channelmask[,Vol1[,Vol2...]]</parameters>
    <shortDescription />
    <longDescription>DiskPlay will play an 8SVX IFF sound file straight from disk. This is ideal for
situations where you simply want to play a sample without the extra hassle of
loading a sound, playing it, and then freeing it. The DiskPlay command will also
halt program flow until the sample has finished playing.

DiskPlay usually requires much less memory to play a sample than the LoadSound,
Sound technique. Also, DiskPlay allows you to play samples of any length, whereas
LoadSound only allows samples up to 128K in length to be loaded.</longDescription>
  </command>
  <command name="DiskBuffer">
    <keyword>DiskBuffer</keyword>
    <fullCommand>DiskBuffer Bufferlen</fullCommand>
    <parameters>Bufferlen</parameters>
    <shortDescription />
    <longDescription>DiskBuffer allows you to set the size of the memory buffer used by the DiskPlay
command. This Buffer is by default set to 1024 bytes, and should not normally have
to be set to more than this.

Reducing the buffer size by too much may cause loss of sound quality of the DiskPlay
command.

If you are using DiskPlay to access a very slow device, the buffer size may have to
be increased.</longDescription>
  </command>
  <command name="LoadSound">
    <keyword>LoadSound</keyword>
    <fullCommand>LoadSound Sound#,Filename$</fullCommand>
    <parameters>Sound#,Filename$</parameters>
    <shortDescription />
    <longDescription>LoadSound creates a sound object for later playback. The sound is taken from an 8SVX
IFF file. An error will be generated if the specified file is not in the correct IFF
format.</longDescription>
  </command>
  <command name="Sound">
    <keyword>Sound</keyword>
    <fullCommand>Sound Sound#,Channelmask[,Vol1[,Vol2...]]</fullCommand>
    <parameters>Sound#,Channelmask[,Vol1[,Vol2...]]</parameters>
    <shortDescription />
    <longDescription>Sound causes a previously created sound object to be played through the Amiga's
audio hardware. Channelmask specifies which of the Amiga's four audio channels the
sound should be played through, and should be in the range one through fifteen.


The following is a list of Channelmask values and their effect:

Mask   Channel0    Channel1    Channel2    Channel3 
1      on          off         off         off
2      off         on          off         off
3      on          on          off         off
4      off         off         on          off
5      on          off         on          off
6      off         on          on          off
7      on          on          on          off
8      off         off         off         on
9      on          off         off         on
10     off         on          off         on
11     on          on          off         on
12     off         off         on          on
13     on          off         on          on
14     off         on          on          on
15     on          on          on          on

In the above table, any audio channels specified as 'off' are not altered by Sound,
and any sounds they may have previously been playing will not be affected.

The Volx parameters allow individual volume settings for different audio channels.
Volume settings must be in the range zero through 64, zero being silence, and 64
being loudest.

The first Vol parameter specifies the volume for the lowest numbered 'on' audio
channel, the second Vol for the next lowest and so on.

For example, assume you are using the following Sound command:

Sound 0,10,32,16

The Channelmask of ten means the sound will play through audio channels one and
three. The first volume of 32 will be applied to channel one, and the second volume
of 16 will be applied to channel three.

Any Vol parameters omitted will be cause a volume setting of 64.</longDescription>
  </command>
  <command name="Volume">
    <keyword>Volume</keyword>
    <fullCommand>Volume Channelmask,Vol1[,Vol2...]</fullCommand>
    <parameters>Channelmask,Vol1[,Vol2...]</parameters>
    <shortDescription />
    <longDescription>Volume allows you to dynamically alter the volume of an audio channel. This enables
effects such as volume fades. For an explanation of Channelmask and Vol parameters,
please refer to the Sound command.</longDescription>
  </command>
  <command name="Filter">
    <keyword>Filter</keyword>
    <fullCommand>Filter On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription>Filter may be used to turn on or off the Amiga's low pass audio filter.</longDescription>
  </command>
  <command name="LoopSound">
    <keyword>LoopSound</keyword>
    <fullCommand>LoopSound Sound#,Channelmask[,Vol1[,Vol2...]]</fullCommand>
    <parameters>Sound#,Channelmask[,Vol1[,Vol2...]]</parameters>
    <shortDescription />
    <longDescription>LoopSound behaves identically to Sound, only the sound will be played repeatedly.
Looping a sound allows for the facility to play the entire sound just once, and
begin repeating at a point in the sound other than the beginning. This information
is picked up from the 8SVX IFF file, when LoadSound is used to create the sound, or
from the offset parameter of InitSound.</longDescription>
  </command>
  <command name="InitSound">
    <keyword>InitSound</keyword>
    <fullCommand>InitSound Sound#,Length[,Period[,Repeat]]</fullCommand>
    <parameters>Sound#,Length[,Period[,Repeat]]</parameters>
    <shortDescription />
    <longDescription>InitSound initializes a sound object in preparation for the creation of custom sound
data. This allows simple sound waves such as sine or square waves to be
algorithmically created. SoundData should be used to create the actual wave data.

Length refers to the length, in bytes, the sound object is required to be. Length
MUST be less than 128K, and MUST be even.

Period allows you to specify a default pitch for the sound. A period of 428 will
cause the sound to be played at approximately middle 'C'.

Offset is used in conjunction with LoopSound, and specifies a position in the sound
at which repeating should begin. Please refer to LoopSound for more information on
repeating sounds.</longDescription>
  </command>
  <command name="SoundData">
    <keyword>SoundData</keyword>
    <fullCommand>SoundData Sound#,Offset,Data</fullCommand>
    <parameters>Sound#,Offset,Data</parameters>
    <shortDescription />
    <longDescription>SoundData allows you to manually specify the waveform of a sound object. The sound
object should normally have been created using InitSound, although altering IFF
sounds is perfectly legal.

SoundData alters one byte of sound data at the specified Offset. Data refers to the
actual byte to place into the sound, and should be in the range -128 to +127.</longDescription>
  </command>
  <command name="PeekSound">
    <keyword>PeekSound</keyword>
    <fullCommand>PeekSound(Sound#,Offset)</fullCommand>
    <parameters>(Sound#,Offset)</parameters>
    <shortDescription />
    <longDescription>PeekSound returns the byte of a sample at the specified offset of the sound object
specified.</longDescription>
  </command>
  <command name="DecodeSound">
    <keyword>DecodeSound</keyword>
    <fullCommand>DecodeSound Sound#,MemoryLocation</fullCommand>
    <parameters>Sound#,MemoryLocation</parameters>
    <shortDescription />
    <longDescription>DecodeSound, similar to the other new Decode commands allows the programmer to
include sound files within their program's object code.</longDescription>
  </command>
  <command name="SetPeriod">
    <keyword>SetPeriod</keyword>
    <fullCommand>SetPeriod Sound#,Period</fullCommand>
    <parameters>Sound#,Period</parameters>
    <shortDescription />
    <longDescription>This command allows the programmer to manually adjust the period of the sound object
to change it's effective pitch.</longDescription>
  </command>
  <command name="Bank">
    <keyword>Bank</keyword>
    <fullCommand>Bank(bank#)</fullCommand>
    <parameters>(bank#)</parameters>
    <shortDescription>returns location of bank, 0 if not in use.</shortDescription>
    <longDescription>Returns the meniory location of the given memory Bank, replaces the older and more
stupidly named BankLoc command.</longDescription>
  </command>
  <command name="InitBank">
    <keyword>InitBank</keyword>
    <fullCommand>InitBank bank#,size,memtype</fullCommand>
    <parameters>bank#,size,memtype</parameters>
    <shortDescription>0=fast 2=chip 65536=clrmem.</shortDescription>
    <longDescription>InitBank allocates a block of memory and assigns it to the Bank specified. The
memtype is the same as the Amiga operating system memory flags:

1 = public
2 = chip
65536 = clear memory.</longDescription>
  </command>
  <command name="FreeBank">
    <keyword>FreeBank</keyword>
    <fullCommand>FreeBank bank#</fullCommand>
    <parameters>bank#</parameters>
    <shortDescription />
    <longDescription>FreeBank de-allocates any memory block allocated tor the Bank specified.</longDescription>
  </command>
  <command name="LoadBank">
    <keyword>LoadBank</keyword>
    <fullCommand>LoadBank bank#,filename$[,memtype]</fullCommand>
    <parameters>bank#,filename$[,memtype]</parameters>
    <shortDescription />
    <longDescription>The LoadBank command has been modified, instead of having to initialise the bank
before loading a file, LoadBank will now initialise the bank to the size of the file
if it is not already large enough or has not been initialised at all.</longDescription>
  </command>
  <command name="SaveBank">
    <keyword>SaveBank</keyword>
    <fullCommand>SaveBank bank#,filename$</fullCommand>
    <parameters>bank#,filename$</parameters>
    <shortDescription />
    <longDescription>SaveBank will save the memory assigned to the Bank to the filename specified.</longDescription>
  </command>
  <command name="BankLoc">
    <keyword>BankLoc</keyword>
    <fullCommand>BankLoc(bank#)</fullCommand>
    <parameters>(bank#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BankSize">
    <keyword>BankSize</keyword>
    <fullCommand>BankSize(bank#)</fullCommand>
    <parameters>(bank#)</parameters>
    <shortDescription />
    <longDescription>BankSize returns the size of the memory hlock allocated for the specified Bank#.</longDescription>
  </command>
  <command name="AllocMem">
    <keyword>AllocMem</keyword>
    <fullCommand>AllocMem(size,memtype) memtype: 0=fast 2=chip 65536=clrmem</fullCommand>
    <parameters>(size,memtype) memtype: 0=fast 2=chip 65536=clrmem</parameters>
    <shortDescription />
    <longDescription>Unlike calling Exec's AllocMem command directly Blitz will automatically free any
allocated memory when the program ends. Programmers are advised to use the InitBank
command.

Flags that can be used with the memory type parameter are:

1=public    ;fast if present
2=chipmem
65536=clear ;clears all memory allocated with 0's.</longDescription>
  </command>
  <command name="FreeMem">
    <keyword>FreeMem</keyword>
    <fullCommand>FreeMem address,size</fullCommand>
    <parameters>address,size</parameters>
    <shortDescription />
    <longDescription>Used to tree any memory allocated with the AllocMem command.</longDescription>
  </command>
  <command name="ASLFileRequest$">
    <keyword>ASLFileRequest$</keyword>
    <fullCommand>ASLFileRequest$ Title$,Pathname$,Filename$ [,Pattern$] [,x,y,w,h]</fullCommand>
    <parameters>Title$,Pathname$,Filename$ [,Pattern$] [,x,y,w,h]</parameters>
    <shortDescription />
    <longDescription>The ASL File Requester is nice. Except tor the highlight bar being invisible on
directories you get to use keyboard for everything, stick in a pattern$ to hide
certain files and of course you get what ever size you want.

I made it call the Blitz file requester if the program is running under 1.3 (isn't
that nice!). There is a fix that patches the ReqTools file requester but that
doesn't have the date field.

I couldn't get the Save-Only tag or the "Create Directory" option working maybe next
upgrade.</longDescription>
  </command>
  <command name="ASLFontRequest">
    <keyword>ASLFontRequest</keyword>
    <fullCommand>ASLFontRequest enable flags (1=pen 2=bckgrnd 4=style 8=drawmode 16=fixedsize)</fullCommand>
    <parameters>enable flags (1=pen 2=bckgrnd 4=style 8=drawmode 16=fixedsize)</parameters>
    <shortDescription />
    <longDescription>The ASL Font Requester is also pretty useful. The flags parameter enables the user
to modify the following options:

#pen=1:#bckgrnd=2:#style=4:#drawmode=8:#fixsize=16

It doesn't seem to handle colour fonts, no keyboard shortcuts so perhaps patching
ReqTools is an option for this one.

The following code illustrates how a .fontinfo structure is created by a call to
ASLFontRequest (just like programming in a high level language man!).


Those who are just getting to grips with 2.0 and above will find this command makes
your programs look really good, however I haven't got time to explain the
difficulties of developing programs that work in all screen resolutions (what are
ya?).


NEWTYPE .fontinfo
    name.s
    ysize.w
    style.b:flags.b
    pen1.b:pen2:drawmode:pad
End NEWTYPE

FindScreen 0

*f.fontinfo=ASLFontRequest(15)

If *f

   NPrint *f\name
   NPrint *f\ysize
   NPrint *f\pen1
   NPrint *f\pen2
   NPrint *f\drawmode

Else

   NPrint "cancelled"

Endif

MouseWait.</longDescription>
  </command>
  <command name="ASLScreenRequest">
    <keyword>ASLScreenRequest</keyword>
    <fullCommand>ASLScreenRequest enable flags (1=width 2=height 4=depth 8=overscan 16=scroll)</fullCommand>
    <parameters>enable flags (1=width 2=height 4=depth 8=overscan 16=scroll)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ASLPathRequest$">
    <keyword>ASLPathRequest$</keyword>
    <fullCommand>ASLPathRequest$ Title$,Pathname$ [,x,y,w,h]</fullCommand>
    <parameters>Title$,Pathname$ [,x,y,w,h]</parameters>
    <shortDescription />
    <longDescription>Same as ASLFileRequest$ except will just prompt the user for a path name (directory)
rather than an actual file.</longDescription>
  </command>
  <command name="ASLMultiSelect">
    <keyword>ASLMultiSelect</keyword>
    <fullCommand>ASLMultiSelect Title$,Pathname$,Filename$[,x,y,w,h]</fullCommand>
    <parameters>Title$,Pathname$,Filename$[,x,y,w,h]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ASLGetFile">
    <keyword>ASLGetFile</keyword>
    <fullCommand>ASLGetFile(argnum)</fullCommand>
    <parameters>(argnum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ASLNextFile">
    <keyword>ASLNextFile</keyword>
    <fullCommand>ASLNextFile</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ASLFreeRequest">
    <keyword>ASLFreeRequest</keyword>
    <fullCommand>ASLFreeRequest</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ASLNumFiles">
    <keyword>ASLNumFiles</keyword>
    <fullCommand>ASLNumFiles</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTButton">
    <keyword>GTButton</keyword>
    <fullCommand>GTButton GTList#,id.w,x.w,y.w,w.w,h.w,Text$,flags.l[,UserData.l]</fullCommand>
    <parameters>GTList#,id.w,x.w,y.w,w.w,h.w,Text$,flags.l[,UserData.l]</parameters>
    <shortDescription />
    <longDescription>Same as Blitz's TextGadget but with the added flexibility of placing the label Text$
above, below to the left or right of the button (see flags).</longDescription>
  </command>
  <command name="GTCheckBox">
    <keyword>GTCheckBox</keyword>
    <fullCommand>GTCheckBox GTList#,id,x,y,w,h,Text$,flags</fullCommand>
    <parameters>GTList#,id,x,y,w,h,Text$,flags</parameters>
    <shortDescription />
    <longDescription>A box with a check mark that toggles on and off, best used for options that are
either enabled or disabled.</longDescription>
  </command>
  <command name="GTCycle">
    <keyword>GTCycle</keyword>
    <fullCommand>GTCycle GTList#,id,x,y,w,h,Text$,flags,Options$[,active]</fullCommand>
    <parameters>GTList#,id,x,y,w,h,Text$,flags,Options$[,active]</parameters>
    <shortDescription />
    <longDescription>Used for offering the user a range of options, the options string should be a list
of options separated by the 1 character ea. "HIRES 1 LORES 1 SUPER HIRES 1".</longDescription>
  </command>
  <command name="GTInteger">
    <keyword>GTInteger</keyword>
    <fullCommand>GTInteger GTList#,id,x,y,w,h,Text$,flags,default</fullCommand>
    <parameters>GTList#,id,x,y,w,h,Text$,flags,default</parameters>
    <shortDescription />
    <longDescription>A string gadget that allows only numbers to be entered by the user. See GTSetInteger
and GTGetInteger for information about accessing the contents of a GTInteger gadget.</longDescription>
  </command>
  <command name="GTListView">
    <keyword>GTListView</keyword>
    <fullCommand>GTListView GTList#,id,x,y,w,h,Text$,flags,list()[,selected[,top]]</fullCommand>
    <parameters>GTList#,id,x,y,w,h,Text$,flags,list()[,selected[,top]]</parameters>
    <shortDescription />
    <longDescription>The ListView gadget enables the user to scroll through a list of options. These
options must be contained in a string field of a Blitz LINKed list.

Currently this string field must be the second field, the first being a word type.
*See the GTChangeList command for more details.</longDescription>
  </command>
  <command name="GTMX">
    <keyword>GTMX</keyword>
    <fullCommand>GTMX GTList#,id,x,y,w,h,Text$,flags,Options$[,active]</fullCommand>
    <parameters>GTList#,id,x,y,w,h,Text$,flags,Options$[,active]</parameters>
    <shortDescription />
    <longDescription>GTMX is an exclusive selection gadget, the Options$ is the same as GTCycle in
format, GadTools then displays all the options in a vertical list each with a
hi-light beside them.</longDescription>
  </command>
  <command name="GTNumber">
    <keyword>GTNumber</keyword>
    <fullCommand>GTNumber GTList#,id,x,y,w,h,Text$,flags,value</fullCommand>
    <parameters>GTList#,id,x,y,w,h,Text$,flags,value</parameters>
    <shortDescription />
    <longDescription>This is a readonly gadget (user cannot interact with it) used to display numbers.
See GTSetInteger to update the contents of this read only "display" gadget.</longDescription>
  </command>
  <command name="GTPalette">
    <keyword>GTPalette</keyword>
    <fullCommand>GTPalette GTList#,id,x,y,w,h,Text$,flags,depth[,Color]</fullCommand>
    <parameters>GTList#,id,x,y,w,h,Text$,flags,depth[,Color]</parameters>
    <shortDescription />
    <longDescription>Creates a number of coloured boxes relating to a colour palette,.</longDescription>
  </command>
  <command name="GTScroller">
    <keyword>GTScroller</keyword>
    <fullCommand>GTScroller GTList#,id,x,y,w,h,Text$,flags,Visible,Total[,Top]</fullCommand>
    <parameters>GTList#,id,x,y,w,h,Text$,flags,Visible,Total[,Top]</parameters>
    <shortDescription />
    <longDescription>A prop type gadget for the user to control an amount or level, is accompanied by a
set of arrow gadgets.</longDescription>
  </command>
  <command name="GTSlider">
    <keyword>GTSlider</keyword>
    <fullCommand>GTSlider GTList#,id,x,y,w,h,Text$,flags,Min,Max[,Level]</fullCommand>
    <parameters>GTList#,id,x,y,w,h,Text$,flags,Min,Max[,Level]</parameters>
    <shortDescription />
    <longDescription>Same as Scroller but for controlling the position of the display inside a larger
view.</longDescription>
  </command>
  <command name="GTString">
    <keyword>GTString</keyword>
    <fullCommand>GTString GTList#,id,x,y,w,h,Text$,flags,MaxChars [,default$]</fullCommand>
    <parameters>GTList#,id,x,y,w,h,Text$,flags,MaxChars [,default$]</parameters>
    <shortDescription />
    <longDescription>A standard string type gadget. See GTSetString and GTGetString for accessing the
contents of a GTString gadget.</longDescription>
  </command>
  <command name="GTText">
    <keyword>GTText</keyword>
    <fullCommand>GTText GTList#,id,x,y,w,h,Text$,flags,Display$</fullCommand>
    <parameters>GTList#,id,x,y,w,h,Text$,flags,Display$</parameters>
    <shortDescription />
    <longDescription>A read only gadget (see GTNumber) for displaying text messages. See GTSetString for
updating the contents of this read only "display" gadget.</longDescription>
  </command>
  <command name="AttachGTList">
    <keyword>AttachGTList</keyword>
    <fullCommand>AttachGTList GTList#,Window#</fullCommand>
    <parameters>GTList#,Window#</parameters>
    <shortDescription />
    <longDescription>The AttachGTList command is used to attach a set of GadTools gadgets to a Window
after it has been opened.</longDescription>
  </command>
  <command name="GTTags">
    <keyword>GTTags</keyword>
    <fullCommand>GTTags Tag,Value [,Tag,Value...]</fullCommand>
    <parameters>Tag,Value [,Tag,Value...]</parameters>
    <shortDescription />
    <longDescription>The GTTags command can be used prior to initialisation of any of the 12 gadtools
gadgets to preset any relevant Tag fields. The following are some useful Tags that
can be used with GTTags:

#tag              =$80080000
#GTCB Checked     =#tag+4    ; State of checkbox
#GTLV_Top         =#tag+5    ; Top visible item in listview
#GTLV_ReadOnly    =#tag+7    ; Set TRUE if lisiview is ReadOnly
#GTMX_Active      =#tag+10   ; Active one in mx gadget
#GTTX_Text        =#tag+11   ; Text to display
#GTNM_Number      =#tag+13   ; Number to display
#GTCY_Active      =#tag+15   ; The active one in the cycle gad
#GTPA_Color       =#tag+17   ; Palette color
#GTPA ColorOffset =#tag+18   ; First color to use in palette
#GTSC_Top         =#tag+21   ; Top visible in scroller
#GTSC_Total       =#tag+22   ; Total in scroller area
#GTSC_Visible     =#tag+23   ; Number visible in scroller
#GTSL_Level       =#tag+40   ; Slider level
#GTSL_MaxLevelLen =#tag+41   ; Max length of printed level
#GTSL_LevelFormat =#tag+42   ;* Format string for level
#GTSL_LevelPlace  =#tag+43   ;* Where level should be placed
#GTLV_Selected    =#tag+54   ; Set ordinal number of selected
#GTMX_Spacing     =#tag+61   ;* Added to font height

All of the above except for those marked * can be set after initialisation of the
Gadget using the GTSetAttrs command.

The following is an example of creating a slider gadget with a numeric display:

f$="%21d"
GTTags #GTSLLevelFormat,&amp;f$,#GTSLMaxLevelLen,4
GTSlider 2,10,320,120,200,20,"GTSLIDER",2,0,10.</longDescription>
  </command>
  <command name="GTGadPtr">
    <keyword>GTGadPtr</keyword>
    <fullCommand>GTGadPtr(GTList#,id)</fullCommand>
    <parameters>(GTList#,id)</parameters>
    <shortDescription />
    <longDescription>GTGadPtr returns the actual location of the specified GadTools gadget in memory.</longDescription>
  </command>
  <command name="GTBevelBox">
    <keyword>GTBevelBox</keyword>
    <fullCommand>GTBevelBox GTList#,x.l,y.l,w.l,h.l,flags.l[,type.l]</fullCommand>
    <parameters>GTList#,x.l,y.l,w.l,h.l,flags.l[,type.l]</parameters>
    <shortDescription />
    <longDescription>GTBevelBox is the GadTools library equivalent of the Borders command and can be used
to render frames and boxes in the currently used Window.</longDescription>
  </command>
  <command name="GTChangeList">
    <keyword>GTChangeList</keyword>
    <fullCommand>GTChangeList GTList#,id [ ,List() ]</fullCommand>
    <parameters>GTList#,id [ ,List() ]</parameters>
    <shortDescription />
    <longDescription>GTChangeList must be used whenever a List attached to a GTListView needs to be
modified. Call GTChangeList without the List() parameter to free the List, modify it
then reattach it with another call to GTChangeList this time using the List()
parameter.</longDescription>
  </command>
  <command name="GTSetAttrs">
    <keyword>GTSetAttrs</keyword>
    <fullCommand>GTSetAttrs GTList#,id [,Tag,Value...]</fullCommand>
    <parameters>GTList#,id [,Tag,Value...]</parameters>
    <shortDescription />
    <longDescription>GTSetAttrs can be used to modify the status of certain GadTools gadgets with the
relevant Tags. See GTTags for more information.</longDescription>
  </command>
  <command name="GTSetString">
    <keyword>GTSetString</keyword>
    <fullCommand>GTSetString GTList#,id,string$</fullCommand>
    <parameters>GTList#,id,string$</parameters>
    <shortDescription />
    <longDescription>Used with both GTString and GTText gadgets, GTSetString will not only update the
contents of the gadget but redraw it also.</longDescription>
  </command>
  <command name="GTSetInteger">
    <keyword>GTSetInteger</keyword>
    <fullCommand>GTSetInteger GTList#,id,value</fullCommand>
    <parameters>GTList#,id,value</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTGetString">
    <keyword>GTGetString</keyword>
    <fullCommand>GTGetString GTList#,id</fullCommand>
    <parameters>GTList#,id</parameters>
    <shortDescription />
    <longDescription>Used to read the contents from a GTString gadget.</longDescription>
  </command>
  <command name="GTGetInteger">
    <keyword>GTGetInteger</keyword>
    <fullCommand>GTGetInteger GTList#,id</fullCommand>
    <parameters>GTList#,id</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTShape">
    <keyword>GTShape</keyword>
    <fullCommand>GTShape GTList#,id,x,y,flags,Shape#[,Shape#]</fullCommand>
    <parameters>GTList#,id,x,y,flags,Shape#[,Shape#]</parameters>
    <shortDescription />
    <longDescription>Similar to the Blitz ShapeGadget allowing IFF graphics that are loaded into Blitz
shape objects to be used as gadgets in a window.</longDescription>
  </command>
  <command name="GTGetAttrs">
    <keyword>GTGetAttrs</keyword>
    <fullCommand>GTGetAttrs(GTList#,id,Tag)</fullCommand>
    <parameters>(GTList#,id,Tag)</parameters>
    <shortDescription />
    <longDescription>A 3.0 specific command. See C= documentation for more information.</longDescription>
  </command>
  <command name="GTEnable">
    <keyword>GTEnable</keyword>
    <fullCommand>GTEnable GTList#,Id</fullCommand>
    <parameters>GTList#,Id</parameters>
    <shortDescription />
    <longDescription>Allows GTGadgets to be enabled and disabled.</longDescription>
  </command>
  <command name="GTDisable">
    <keyword>GTDisable</keyword>
    <fullCommand>GTDisable GTList#,Id</fullCommand>
    <parameters>GTList#,Id</parameters>
    <shortDescription />
    <longDescription>Allows GTGadgets to be enabled and disabled.</longDescription>
  </command>
  <command name="GTToggle">
    <keyword>GTToggle</keyword>
    <fullCommand>GTToggle GTList#,Id [,On|Off]</fullCommand>
    <parameters>GTList#,Id [,On|Off]</parameters>
    <shortDescription />
    <longDescription>GTToggle allows the programmer to set Boolean gadgets such as GTButton and
GTCheckbox to a desired state.</longDescription>
  </command>
  <command name="GTStatus">
    <keyword>GTStatus</keyword>
    <fullCommand>GTStatus GTList#,Id</fullCommand>
    <parameters>GTList#,Id</parameters>
    <shortDescription />
    <longDescription>GTStatus returns the status of the gadtools toggle gadgets, a value of 1 means the
the gadget is selected, 0 deselected.</longDescription>
  </command>
  <command name="GTArrowSize">
    <keyword>GTArrowSize</keyword>
    <fullCommand>GTArrowSize size</fullCommand>
    <parameters>size</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DetachGTList">
    <keyword>DetachGTList</keyword>
    <fullCommand>DetachGTList GTList#</fullCommand>
    <parameters>GTList#</parameters>
    <shortDescription>Removes a GTList from a window.</shortDescription>
    <longDescription />
  </command>
  <command name="GTGZZPosition">
    <keyword>GTGZZPosition</keyword>
    <fullCommand>GTGZZPosition On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>Turn on/off adding of window borders to gadget positions.</shortDescription>
    <longDescription />
  </command>
  <command name="GTSetHighlight">
    <keyword>GTSetHighlight</keyword>
    <fullCommand>GTSetHighlight GTList#,id,value</fullCommand>
    <parameters>GTList#,id,value</parameters>
    <shortDescription>Set highlighted item in GTListview.</shortDescription>
    <longDescription />
  </command>
  <command name="GTFreeGadget">
    <keyword>GTFreeGadget</keyword>
    <fullCommand>GTFreeGadget [(]GTList#,id[)]</fullCommand>
    <parameters>[(]GTList#,id[)]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTActivateGadget">
    <keyword>GTActivateGadget</keyword>
    <fullCommand>GTActivateGadget GTList#,id</fullCommand>
    <parameters>GTList#,id</parameters>
    <shortDescription>Activates a string/custom gadget.</shortDescription>
    <longDescription />
  </command>
  <command name="GTNewLookProp">
    <keyword>GTNewLookProp</keyword>
    <fullCommand>GTNewLookProp [Mode=On/Off] or [GTList,ID,On/Off]</fullCommand>
    <parameters>[Mode=On/Off] or [GTList,ID,On/Off]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTListAddress">
    <keyword>GTListAddress</keyword>
    <fullCommand>GTListAddress(List())  Returns address of List header structure</fullCommand>
    <parameters>(List())  Returns address of List header structure</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTUserData">
    <keyword>GTUserData</keyword>
    <fullCommand>GTUserData UserData.l</fullCommand>
    <parameters>UserData.l</parameters>
    <shortDescription>Set userdata for next gadget created.</shortDescription>
    <longDescription />
  </command>
  <command name="GTChangeCycle">
    <keyword>GTChangeCycle</keyword>
    <fullCommand>GTChangeCycle [(]GTList.w,ID.w,Option$[)]</fullCommand>
    <parameters>[(]GTList.w,ID.w,Option$[)]</parameters>
    <shortDescription>Change contents of GTCycle gadget.</shortDescription>
    <longDescription />
  </command>
  <command name="GTGetInternal">
    <keyword>GTGetInternal</keyword>
    <fullCommand>GTGetInternal Returns pointer to internal list of memory allocations</fullCommand>
    <parameters>Returns pointer to internal list of memory allocations</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTUnderscore">
    <keyword>GTUnderscore</keyword>
    <fullCommand>GTUnderscore char.w</fullCommand>
    <parameters>char.w</parameters>
    <shortDescription>Sets the ASCII code of the character to use as the underscore indicator.</shortDescription>
    <longDescription />
  </command>
  <command name="GTEventSeconds">
    <keyword>GTEventSeconds</keyword>
    <fullCommand>GTEventSeconds</fullCommand>
    <parameters />
    <shortDescription>Tells you the seconds at which the last event occurred.</shortDescription>
    <longDescription />
  </command>
  <command name="GTEventMicros">
    <keyword>GTEventMicros</keyword>
    <fullCommand>GTEventMicros</fullCommand>
    <parameters />
    <shortDescription>Tells you the microseconds at which the last event occurred.</shortDescription>
    <longDescription />
  </command>
  <command name="Buffer">
    <keyword>Buffer</keyword>
    <fullCommand>Buffer Buffer#,Memorylen</fullCommand>
    <parameters>Buffer#,Memorylen</parameters>
    <shortDescription />
    <longDescription>The Buffer command is used to create a buffer object. Buffers are similar to queues
in concept, but operate slightly differently. If you have not yet read the
description of the Queue command, it would be a good idea to do so before continuing
here.

The buffer related commands are very similar to the queue related commands - Buffer,
BBlit, and UnBuffer, and are used in exactly the same way. Where buffers differ from
queues, however, is in their ability to preserve background graphics.

Whereas an UnQueue command normally trashes any background graphics, UnBuffer will
politely restore whatever the BBlits may have overwritten. This is achieved by the
BBlit command actually performing two blits.


The first blit transfers the area on the bitmap which the shape is about to cover to
a temporary storage area - the second blit actually draws the shape onto the bitmap.
When the time comes to UnBuffer all those BBlits, the temporary storage areas will
be transferred back to the disrupted bitmap.

The Memorylen parameter of the Buffer command refers to how much memory, in bytes,
should be put aside as temporary storage for the preservation of background
graphics. The value of this parameter varies depending upon the size of shapes to be
BBlited, and the maximum number of shapes to be BBlited between UnBuffers.

A Memorylen of 16384 should be plenty for most situations, but may need to be
increased if you start getting 'Buffer Overflow' error messages.</longDescription>
  </command>
  <command name="BBlit">
    <keyword>BBlit</keyword>
    <fullCommand>BBlit Buffer#,Shape#,X,Y[,Excessonoff]</fullCommand>
    <parameters>Buffer#,Shape#,X,Y[,Excessonoff]</parameters>
    <shortDescription />
    <longDescription>The BBlit command is used to draw a shape onto the currently used bitmap, and
preserve the overwritten area into a previously initialized buffer. For more
information on how buffers work, please refer to the Buffer command.

The optional Excessonoff parameter works identically to the Excessonoff parameter
used by the Blit command. Please refer to the Blit command for more information on
this parameter.</longDescription>
  </command>
  <command name="UnBuffer">
    <keyword>UnBuffer</keyword>
    <fullCommand>UnBuffer Buffer#</fullCommand>
    <parameters>Buffer#</parameters>
    <shortDescription />
    <longDescription>UnBuffer is used to 'replace' areas on a bitmap overwritten by a series of BBlit
commands. For more information on buffers, please refer to the Buffer command.</longDescription>
  </command>
  <command name="BBlitMode">
    <keyword>BBlitMode</keyword>
    <fullCommand>BBlitMode BLTCON0</fullCommand>
    <parameters>BLTCON0</parameters>
    <shortDescription />
    <longDescription>BBlitMode allows you to control how the blister operates when BBlitting shapes to
bitmaps. Please refer to BlitMode for more information on this command.</longDescription>
  </command>
  <command name="ShowStencil">
    <keyword>ShowStencil</keyword>
    <fullCommand>ShowStencil Buffer#,Stencil#</fullCommand>
    <parameters>Buffer#,Stencil#</parameters>
    <shortDescription />
    <longDescription>ShowStencil is used in connection with BBlits and stencil objects to produce a
'stencil' effect. Stencils allow you create the effect of shapes moving 'between'
background and foreground graphics. Used properly, stencils can add a sense of
'depth' or 'three dimensionality' to animations.

So what steps are involved in using stencils? To begin with, you need both a bitmap
and a stencil object. A stencil object is similar to a bitmap in that it contains
various graphics. Stencils differ, however, in that they contain no colour
information. They simply determine where graphics are placed on the stencil. The
graphics on a stencil usually correspond to the graphics representing 'foreground'
scenery on a bitmap.

So the first step is to set up a bitmap with both foreground and background scenery
on it. Next, a stencil is set up with only the foreground scenery on it. This may be
done using either the Stencil or SBlit command. Now, we BBlit our shapes. This will,
of course, place all the shapes in front of both the background and the foreground
graphics. However, once all shapes have been BBlitted, executing the ShowStencil
command will repair the damage done to the foreground graphics!.</longDescription>
  </command>
  <command name="FlushBuffer">
    <keyword>FlushBuffer</keyword>
    <fullCommand>FlushBuffer Buffer#</fullCommand>
    <parameters>Buffer#</parameters>
    <shortDescription />
    <longDescription>FlushBuffer will force the specified buffer object to be 'emptied', causing the next
UnBuffer command to have no effect.</longDescription>
  </command>
  <command name="BitMap">
    <keyword>BitMap</keyword>
    <fullCommand>BitMap BitMap#,Width,Height,Depth</fullCommand>
    <parameters>BitMap#,Width,Height,Depth</parameters>
    <shortDescription />
    <longDescription>BitMap creates and initializes a bitmap object. Once created, the specified bitmap
becomes the currently used bitmap. Width and Height specify the size of the bitmap.
Depth specifies how many colours may be drawn onto the bitmap, and may be in the
range one through six. The actual colours available on a bitmap can be calculated
using 2^depth. For example, a bitmap of depth three allows for 2^3 or eight colours.</longDescription>
  </command>
  <command name="LoadBitMap">
    <keyword>LoadBitMap</keyword>
    <fullCommand>LoadBitMap BitMap#,Filename$[,Palette#]</fullCommand>
    <parameters>BitMap#,Filename$[,Palette#]</parameters>
    <shortDescription />
    <longDescription>LoadBitMap allows you to load an ILBM IFF graphic into a previously initialized
bitmap object. You may optionally load in the graphics's colour palette into a
palette object specified by Palette#. An error will be generated if the specified
Filename$ is not in the correct IFF format.</longDescription>
  </command>
  <command name="ScreensBitMap">
    <keyword>ScreensBitMap</keyword>
    <fullCommand>ScreensBitMap Screen#,BitMap#</fullCommand>
    <parameters>Screen#,BitMap#</parameters>
    <shortDescription />
    <longDescription>Blitz allows you the option of attaching a bitmap object to any Intuition Screens
you open. If you open a Screen without attaching a bitmap, a bitmap will be created
anyway. You may then find this bitmap using the ScreensBitMap command. Once
ScreensBitMap is executed, the specified bitmap becomes the currently used bitmap.</longDescription>
  </command>
  <command name="CopyBitMap">
    <keyword>CopyBitMap</keyword>
    <fullCommand>CopyBitMap Src BitMap#,Dest BitMap#</fullCommand>
    <parameters>Src BitMap#,Dest BitMap#</parameters>
    <shortDescription />
    <longDescription>CopyBitMap will make an exact copy of a bitmap object into another bitmap object.
The first BitMap# parameter specifies the source bitmap for the copy, the second
BitMap# the destination.

Any graphics rendered onto the source bitmap will also be copied.</longDescription>
  </command>
  <command name="ShapesBitMap">
    <keyword>ShapesBitMap</keyword>
    <fullCommand>ShapesBitMap Shape#,BitMap#</fullCommand>
    <parameters>Shape#,BitMap#</parameters>
    <shortDescription />
    <longDescription>ShapesBitMap creates a dummy BitMap so drawing commands can be used directly on a
shapes image data.</longDescription>
  </command>
  <command name="CludgeBitMap">
    <keyword>CludgeBitMap</keyword>
    <fullCommand>CludgeBitMap BitMap#,Width,Height,Depth,Memory</fullCommand>
    <parameters>BitMap#,Width,Height,Depth,Memory</parameters>
    <shortDescription />
    <longDescription>CludgeBitMap will create a bitmap object with the proportions for that specified
using the memory location given. Of course, the memory location specified must be in
chipmem and it is upto the user to ensure that sufficient memory has been allocated.
This command is most useful for games where memory fragmentation can be a big
problem, by allocating one block of memory on program initialisation for all bitmaps
CludgeBitMap can be used so that creating and freeing of BitMaps is not necessary.</longDescription>
  </command>
  <command name="Blit">
    <keyword>Blit</keyword>
    <fullCommand>Blit Shape#,X,Y[,Excessonoff]</fullCommand>
    <parameters>Shape#,X,Y[,Excessonoff]</parameters>
    <shortDescription />
    <longDescription>Blit is the simplest of all the blitting commands. Blit will simply draw a shape
object onto the currently used bitmap at the pixel position specified by X,Y. The
shape's handle, if any, will be taken into account when positioning the blit.

The optional Excessonoff parameter only comes into use if you are blitting a shape
which has less bitplanes (colours) than the bitmap to which it is being blitted. In
this case, Excessonoff allows you to specify an on/off value for the excess
bitplanes - ie, the bitplanes beyond those altered by the shape. Bit zero of
Excessonoff will specify an on/off value for the first excess bitplane, bit one an
on/off value for the second excess bitplane and so on.

The manner in which the shape is drawn onto the bitmap may be altered by use of the
BlitMode command.</longDescription>
  </command>
  <command name="BlitMode">
    <keyword>BlitMode</keyword>
    <fullCommand>BlitMode BLTCON0</fullCommand>
    <parameters>BLTCON0</parameters>
    <shortDescription />
    <longDescription>The BlitMode command allows you to specify just how the Blit command uses the
blister when drawing shapes to bitmaps. By default, BlitMode is set to a
'cookiemode' which simply draws shapes 'as is'. However, this mode may be altered to
produce other useful ways of drawing. Here are just some of the possible BLTCON0
parameters and their effects:

CookieMode :

Shapes are drawn 'as is'.

EraseMode :

An area the size and shape of the shape willbe 'erased' on the destination bitmap.

InvMode :

An area the size and shape of the shape willbe 'inversed' on the destination bitmap.

SolidMode :

The shape will be drawn as a solid area of one colour.


Actually, these modes are all just special functions which return a useful value.
Advanced programmers may be interested to know that the BLTCON0 parameter is used by
the Blit command's blister routine to determine the blister MINITERM and CHANNEL USE
flags. Bits zero through seven specify the miniterm, and bits eight through eleven
specify which of the blister channels are used. For the curious out there, all the
blister routines in Blitz assume the following blister channel setup:

BlitterChannel Used For 

A              Pointer to shape's cookie cut
B              Pointer to shape data
C              Pointer to destination
D              Pointer to destination.</longDescription>
  </command>
  <command name="CookieMode">
    <keyword>CookieMode</keyword>
    <fullCommand>CookieMode</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>The CookieMode function returns a value which may be used by one of the commands
involved in blitting modes.

Using CookieMode as a blitting mode will cause a shape to be blitted cleanly, 'as
is', onto a bitmap.</longDescription>
  </command>
  <command name="EraseMode">
    <keyword>EraseMode</keyword>
    <fullCommand>EraseMode</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>The EraseMode function returns a value which may be used by one the commands
involved in blitting modes.

Using EraseMode as a blitting mode will cause a blitted shape to erase a section of
a bitmap corresponding to the outline of the shape.</longDescription>
  </command>
  <command name="InvMode">
    <keyword>InvMode</keyword>
    <fullCommand>InvMode</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>The InvMode function returns a value which may be used by one the commands involved
in blitting modes.

Using InvMode as a blitting mode will cause a shape to 'invert' a section of a
bitmap corresponding to the outline of the blitted shape.</longDescription>
  </command>
  <command name="SolidMode">
    <keyword>SolidMode</keyword>
    <fullCommand>SolidMode</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>The SolidMode function returns a value which may be used by one the commands
involved in blitting modes.

Using SolidMode as a blitting mode will cause a shape to overwrite a section of a
bitmap corresponding to the outline of the blitted shape.</longDescription>
  </command>
  <command name="Block">
    <keyword>Block</keyword>
    <fullCommand>Block Shape#,X,Y</fullCommand>
    <parameters>Shape#,X,Y</parameters>
    <shortDescription />
    <longDescription>Block is an extremely fast version of the Blit command with some restrictions. Block
should only be used with shapes that are 16,32,48,64... pixels wide and that are
being blitted to an x position of 0,16,32,48,64... Note that the height and y
destination of the shape are not limited by the Block command.

Block is intended tor use with map type displays.</longDescription>
  </command>
  <command name="BlitColl">
    <keyword>BlitColl</keyword>
    <fullCommand>BlitColl(Shape#,x,y)</fullCommand>
    <parameters>(Shape#,x,y)</parameters>
    <shortDescription />
    <longDescription>BlitColl is a fast way of collision detection when blitting shapes. BlitColl returns
-1 if a collision occurs, 0 if no collision. A collision occurs if any pixel on the
current BitMap is non zero where your shape would have been blitted.

ShapesHit is faster but less accurate as it checks only the rectangular area of each
shape, where as BlitColl takes into account the shape of the shape and of course can
not tell you what shape you have collided with.</longDescription>
  </command>
  <command name="Slice">
    <keyword>Slice</keyword>
    <fullCommand>Slice [Slice#,Y,Flags]|[Slice#,Y,Width,Hite,Flgs,Bitplns,Sprts,Colrs,Fscrnw,Bscrnw]</fullCommand>
    <parameters>[Slice#,Y,Flags]|[Slice#,Y,Width,Hite,Flgs,Bitplns,Sprts,Colrs,Fscrnw,Bscrnw]</parameters>
    <shortDescription />
    <longDescription>Slice#,Y,Width,Height,Flags,BitPlanes,Sprites,Colours,w1,w2


The Slice command is used to create a Blitz slice object. Slices are primarily of
use in Blitz mode, allowing you to create highly customized displays.

In both forms of the Slice command, the Y parameter specifies the vertical pixel
position of the top of the slice. A Y value of 44 will position slices at about the
top of the display.

In the first torm of the Slice command, Flags refers to the number of bitplanes in
any bitmaps (the bitmap's depth) to be shown in the slice. This form of the Slice
command will normally create a lo-res slice, however this may be changed to a hi-res
slice by adding eight to the Flags parameter. For instance, a Flags value of tour
will set up a lo-res, 4 bitplane (16 colour) slice, whereas a Flags value of ten
will set up a hi- res, 2 bitplane (4 colour) slice. The width of a slice set up in
this way will be 320 pixels for a lo-res slice, or 640 pixels for a hi-res slice.
The height of a slice set up using this syntax will be 200 pixels on an NTSC Amiga,
or 256 pixels on a PAL Amiga.

The second form of the Slice command is far more versatile, but a little more
complex. Width and Height allow you to use specific values for the slice's
dimensions. These parameters are specified in pixel amounts.

BitPlanes refers to the depth of any bitmaps you will be showing in this slice.

Sprites refers to how many sprite channels should be available in this slice. Each
slice may have up to eight sprite channels, allow, ing sprites to be 'multiplexed'.
This is one way to overcome the Amiga's 'eight sprite limit'. It is recommended that
the top-most slice be created with all eight sprite channels, as this will prevent
sprite flicker caused by unused sprites.

Colours refers to how many colour palette entries should be available for this
slice, and should not be greater than 32.

Width1 and Width2 specify the width, in pixels, of any bitmaps to be shown in this
slice. If a slice is set up to be a dual-playfield slice, Width1 refers to the width
of the 'foreground' bitmap, and Width2 refers to the width of the 'background'
bitmap. If a slice is NOT set up to be a dual- playfield slice, both Width1 and
Width2 should be set to the same value. These parameters allow you to show bitmaps
which are wider than the slice, introducing the ability to smooth scroll through
large bitmaps.

The Flags parameter has been let to last because it is the most complex. Flags
allows you control over many aspects of the slices appearance, and just what ettect
the slice has. Here are some example settings for Flags:

Flags   Effect                        Max BitPlanes 

$ftf8A  Standard lo-res slice               6
$fft9A  Standard hi-res slice               4
$fitaA  Lo-res, dual-playfield slice        6
$tfibA  Hi-res, dual-playfiled slice        4
$fffcA  HAM slice                           6

WARNING - the next bit is definitely for the more advanced users out there!
Knowledge of the following is NOT necessary to make good use of slices.

Flags is actually a collection of individual bit-flags. The bit-flags control how
the slices 'copper list' is created Here is a list of the bits numbers and their
ettect:

Bit#    Effect 

15  Create copper MOVE BPLCON0
14  Create copper MOVE BPLCON1
13  Create copper MOVE BPLCON2
12  Create copper MOVE DIWSTRT and MOVE DIWSTOP
I0  Create copper MOVE DDFSTRT and MOVE DDFSTOP
8   Create copper MOVE BPL1MOD
7   Create copper MOVE BPL2MOD
4   Create a 2 line 'blank' above top of slice
3   Allow for smooth horizontal scrolling
2   HAM slice
1   Dual-playtield slice
0   Hi-res slice
-   default is lo-res

Clever selection of these bits allows you to create 'minimal' slices which may only
attect specific system registers.

The BitPlanes parameter may also be modified to specify 'odd only' or 'even only'
bitplanes. This is of use when using dual playfield displays, as it allowing you to
create a mid display slice which may show a different foreground or background
bitmap leaving the other intact. To specify creation of foreground bitplanes only,
simply set bit 15 of the BitPlanes parameter. To specify creation of background
bitplanes only, set bit 14 of the BitPlanes parameter.</longDescription>
  </command>
  <command name="CopLoc">
    <keyword>CopLoc</keyword>
    <fullCommand>CopLoc</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>CopLoc returns the memory address of the Blitz mode copper list. All Slices,
ColSplits, and CustomCops executed are merged into a single copper list, the address
of which may found using the CopLoc function.</longDescription>
  </command>
  <command name="CustomCop">
    <keyword>CustomCop</keyword>
    <fullCommand>CustomCop Copins$,Y</fullCommand>
    <parameters>Copins$,Y</parameters>
    <shortDescription />
    <longDescription>CustomCop allows advanced programmers to introduce their own copper instructions at
a specified position down the display. Copin$ refers to a string of characters
equivalent to a series of copper instructions. Y refers to a position down the
display.</longDescription>
  </command>
  <command name="Show">
    <keyword>Show</keyword>
    <fullCommand>Show Bitmap#[,X,Y]</fullCommand>
    <parameters>Bitmap#[,X,Y]</parameters>
    <shortDescription />
    <longDescription>Show is used to display a bitmap in the currently used slice. This slice should not
be a dual-playfield type slice. Optional X and Y parameters may be used to position
the bitmap at a point other than it's top-left. This is normally only of use in
cases where a bitmap larger than the slice width and/or height has been set up.</longDescription>
  </command>
  <command name="ShowF">
    <keyword>ShowF</keyword>
    <fullCommand>ShowF Bitmap#[,X,Y[,ShowB X]]</fullCommand>
    <parameters>Bitmap#[,X,Y[,ShowB X]]</parameters>
    <shortDescription />
    <longDescription>ShowF is used to display a bitmap in the foreground of the currently used slice. The
slice must have been created with the appropriate Flags parameter in order to
support dual-playfield display.

Optional X and Y parameters may be used to show the bitmap at a point other than
it's top-left. Omitting the X and Y parameters is identical to supplying X and Y
values of 0.

The optional ShowB x parameter is only of use in special situations where a
dual-playfield slice has been created to display ONLY a foreground bitmap. In this
case, the X offset of the background bitmap should be specified in the ShowB x
parameter.</longDescription>
  </command>
  <command name="ShowB">
    <keyword>ShowB</keyword>
    <fullCommand>ShowB Bitmap#[,X,Y[,ShowF X]]</fullCommand>
    <parameters>Bitmap#[,X,Y[,ShowF X]]</parameters>
    <shortDescription />
    <longDescription>ShowB is used to display a bitmap in the background of the currently used slice. The
slice must have been created with the appropriate Flags parameter in order to
support dual-playfield display.

Optional X and Y parameters may be used to show the bitmap at a point other than
it's top-lett. Omitting the X and Y parameters is identical to supplying X and Y
values of 0.

The optional ShowF x parameter is only of use in special situations where a
dual-playfield slice has been created to display ONLY a background bitmap. In this
case, the X offset of the foreground bitmap should be specified in the ShowF x
parameter.</longDescription>
  </command>
  <command name="CopLen">
    <keyword>CopLen</keyword>
    <fullCommand>CopLen</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>CopLen returns the length, in bytes, of the Blitz mode copper list. All Slices,
ColSplits, and CustomCops executed are merged into a single copper list, the length
of which may found using the CopLen function.</longDescription>
  </command>
  <command name="ColSplit">
    <keyword>ColSplit</keyword>
    <fullCommand>ColSplit Colour Register,Red,Green,Blue,Y</fullCommand>
    <parameters>Colour Register,Red,Green,Blue,Y</parameters>
    <shortDescription />
    <longDescription>ColSplit allows you to change any of the palette colour registers at a position
relative to the top of the currently used slice. This allows you to 're-use' colour
registers at different positions down the screen to display different colours.

Y specifies a vertical offset fi-om the top of the currently used slice.</longDescription>
  </command>
  <command name="ShowBlitz">
    <keyword>ShowBlitz</keyword>
    <fullCommand>ShowBlitz</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>ShowBlitz redisplays the entire set up of slices. This may be necessary if you have
made a quick trip into Amiga mode, and wish to return to Blitz mode with previously
created slices intact.</longDescription>
  </command>
  <command name="FreeSlices">
    <keyword>FreeSlices</keyword>
    <fullCommand>FreeSlices</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>FreeSlices is used to completely free all slices currently in use. As there is no
capability to Free individual slices, this is the only means by which slices may be
deleted.</longDescription>
  </command>
  <command name="DisplayOff">
    <keyword>DisplayOff</keyword>
    <fullCommand>DisplayOff</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DisplayOn">
    <keyword>DisplayOn</keyword>
    <fullCommand>DisplayOn</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetBPLCON0">
    <keyword>SetBPLCON0</keyword>
    <fullCommand>SetBPLCON0 BPLCON0 Default</fullCommand>
    <parameters>BPLCON0 Default</parameters>
    <shortDescription />
    <longDescription>The SetBPLCON0 command has been added for advanced control of Slice display modes.
The BPLCON0 hardware register is on page A4-1 of the reference manual (appendix 4).
The bits of interest are as follows:

bit#1 ERSY external sync (for genlock enabling)
bit#2 LACE interlace mode
bit#3 LPEN light pen enable

&lt;pre&gt;
&lt;!-- Start actual data --&gt;.</longDescription>
  </command>
  <command name="SetBLWait">
    <keyword>SetBLWait</keyword>
    <fullCommand>SetBLWait Wait move for line 256 (eg:$ffe1fffe</fullCommand>
    <parameters>Wait move for line 256 (eg:$ffe1fffe</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BlitzKeys">
    <keyword>BlitzKeys</keyword>
    <fullCommand>BlitzKeys On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription>BlitzKeys is used to turn on or off Blitz mode keyboard reading. If Blitz mode
keyboard reading is enabled, the Inkey$ function may be used to gain information
about keystrokes in Blitz mode.</longDescription>
  </command>
  <command name="RawStatus">
    <keyword>RawStatus</keyword>
    <fullCommand>RawStatus(Rawkey)</fullCommand>
    <parameters>(Rawkey)</parameters>
    <shortDescription />
    <longDescription>The RawStatus function can be used to determine if an individual key is being held
down or not. Rawkey is the rawcode of the key to check for. If the specified key is
being held down, a value of -1 will be returned. If the specified key is not being
held down, a value of zero will be returned.

RawStatus is only available if Blitz mode keyboard reading has been enabled. This is
done using the BlitzKeys command.</longDescription>
  </command>
  <command name="BlitzRepeat">
    <keyword>BlitzRepeat</keyword>
    <fullCommand>BlitzRepeat Delay,Speed</fullCommand>
    <parameters>Delay,Speed</parameters>
    <shortDescription />
    <longDescription>BlitzRepeat allows you to determine key repeat characteristics in Blitz mode. Delay
specifies the amount of time, in fiftieths of a second, before a key will start
repeating. Speed specifies the amount of time, again in fiftieths of a second,
between repeats of a key once it has started repeating.

BlitzRepeat is only effective when the Blitz mode keyboard reading is enabled. This
is done using the BlitzKeys command.</longDescription>
  </command>
  <command name="BlitzQualifier">
    <keyword>BlitzQualifier</keyword>
    <fullCommand>BlitzQualifier</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>BlitzQualifier returns any qualifier keys that were held down in combination with
the last inkey$ during BlitzMode input.</longDescription>
  </command>
  <command name="HandleRawKey">
    <keyword>HandleRawKey</keyword>
    <fullCommand>HandleRawKey</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="BlitzKey">
    <keyword>BlitzKey</keyword>
    <fullCommand>BlitzKey</fullCommand>
    <parameters />
    <shortDescription>same as inkey$ after a bitmapinput.</shortDescription>
    <longDescription />
  </command>
  <command name="InitPage">
    <keyword>InitPage</keyword>
    <fullCommand>InitPage Page#,BitMap#,NumBoxes</fullCommand>
    <parameters>Page#,BitMap#,NumBoxes</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreePage">
    <keyword>FreePage</keyword>
    <fullCommand>FreePage Page#</fullCommand>
    <parameters>Page#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddBox">
    <keyword>AddBox</keyword>
    <fullCommand>AddBox Page#,Box#,x,y,w,h,type[,text$]|[,shape,shape]</fullCommand>
    <parameters>Page#,Box#,x,y,w,h,type[,text$]|[,shape,shape]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RedrawPage">
    <keyword>RedrawPage</keyword>
    <fullCommand>RedrawPage</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RedrawBox">
    <keyword>RedrawBox</keyword>
    <fullCommand>RedrawBox Box#</fullCommand>
    <parameters>Box#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SelectBox">
    <keyword>SelectBox</keyword>
    <fullCommand>SelectBox [Box#]|[x+,y+][0,x,y]</fullCommand>
    <parameters>[Box#]|[x+,y+][0,x,y]</parameters>
    <shortDescription>deselects previously selected.</shortDescription>
    <longDescription />
  </command>
  <command name="DeSelectBox">
    <keyword>DeSelectBox</keyword>
    <fullCommand>DeSelectBox</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ActivateSelectedBox">
    <keyword>ActivateSelectedBox</keyword>
    <fullCommand>ActivateSelectedBox</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetBox">
    <keyword>SetBox</keyword>
    <fullCommand>SetBox Box#[,Value]|[xprop,yprop]</fullCommand>
    <parameters>Box#[,Value]|[xprop,yprop]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BoxValue">
    <keyword>BoxValue</keyword>
    <fullCommand>BoxValue(Box#)|(Page#,Box#)</fullCommand>
    <parameters>(Box#)|(Page#,Box#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetBoxString">
    <keyword>SetBoxString</keyword>
    <fullCommand>SetBoxString Box#,String$</fullCommand>
    <parameters>Box#,String$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BoxString">
    <keyword>BoxString</keyword>
    <fullCommand>BoxString(Box#)|(Page#,Box#)</fullCommand>
    <parameters>(Box#)|(Page#,Box#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BoxShow">
    <keyword>BoxShow</keyword>
    <fullCommand>BoxShow Box#[,Bitmap#,x,y]|[dx,dy]</fullCommand>
    <parameters>Box#[,Bitmap#,x,y]|[dx,dy]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BoxSelected">
    <keyword>BoxSelected</keyword>
    <fullCommand>BoxSelected</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="BoxPrint">
    <keyword>BoxPrint</keyword>
    <fullCommand>BoxPrint Box#[,String$]|[Bank#,Line]</fullCommand>
    <parameters>Box#[,String$]|[Bank#,Line]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetBoxColor">
    <keyword>SetBoxColor</keyword>
    <fullCommand>SetBoxColor Box#,color</fullCommand>
    <parameters>Box#,color</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BlitzEvent">
    <keyword>BlitzEvent</keyword>
    <fullCommand>BlitzEvent</fullCommand>
    <parameters />
    <shortDescription>handles user input and returns event.</shortDescription>
    <longDescription />
  </command>
  <command name="SetBoxTitle">
    <keyword>SetBoxTitle</keyword>
    <fullCommand>SetBoxTitle Box#,String$</fullCommand>
    <parameters>Box#,String$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DisableBox">
    <keyword>DisableBox</keyword>
    <fullCommand>DisableBox Box#</fullCommand>
    <parameters>Box#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EnableBox">
    <keyword>EnableBox</keyword>
    <fullCommand>EnableBox Box#</fullCommand>
    <parameters>Box#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MouseEnabled">
    <keyword>MouseEnabled</keyword>
    <fullCommand>MouseEnabled</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPagePens">
    <keyword>SetPagePens</keyword>
    <fullCommand>SetPagePens Page#,c0,c1,c2,c3 (defaults: 3,1,2,3)</fullCommand>
    <parameters>Page#,c0,c1,c2,c3 (defaults: 3,1,2,3)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BoxPropX">
    <keyword>BoxPropX</keyword>
    <fullCommand>BoxPropX Box#</fullCommand>
    <parameters>Box#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BoxPropY">
    <keyword>BoxPropY</keyword>
    <fullCommand>BoxPropY Box#</fullCommand>
    <parameters>Box#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChangeBox">
    <keyword>ChangeBox</keyword>
    <fullCommand>ChangeBox Page#,Box#,Value</fullCommand>
    <parameters>Page#,Box#,Value</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ToggleBox">
    <keyword>ToggleBox</keyword>
    <fullCommand>ToggleBox Box#</fullCommand>
    <parameters>Box#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SpotBox">
    <keyword>SpotBox</keyword>
    <fullCommand>SpotBox</fullCommand>
    <parameters />
    <shortDescription>returns box that mouse is over.</shortDescription>
    <longDescription />
  </command>
  <command name="Record">
    <keyword>Record</keyword>
    <fullCommand>Record [Tape#]</fullCommand>
    <parameters>[Tape#]</parameters>
    <shortDescription />
    <longDescription>Record allows you to create a tape object. Tape objects are sequences of mouse
and/or keyboard events which may be played back at any time.

When a tape# parameter is supplied to the Record command, recording will begin. From
that point on, all mouse and keyboard activity will be recorded onto the specified
tape.

The Record command with no parameters will cause any recording to finish.</longDescription>
  </command>
  <command name="PlayBack">
    <keyword>PlayBack</keyword>
    <fullCommand>PlayBack [Tape#]</fullCommand>
    <parameters>[Tape#]</parameters>
    <shortDescription />
    <longDescription>PlayBack begins playback of a previously created tape object. When a Tape# parameter
is supplied, playback of the specified tape will commence. If no parameter is
supplied, any tape which may be in the process of being played back will finish.</longDescription>
  </command>
  <command name="SaveTape">
    <keyword>SaveTape</keyword>
    <fullCommand>SaveTape Tape#,Filename$</fullCommand>
    <parameters>Tape#,Filename$</parameters>
    <shortDescription />
    <longDescription>SaveTape allows you to save a previously created tape object out to disk. This tape
may later be reloaded using LoadTape.</longDescription>
  </command>
  <command name="LoadTape">
    <keyword>LoadTape</keyword>
    <fullCommand>LoadTape Tape#,filename$</fullCommand>
    <parameters>Tape#,filename$</parameters>
    <shortDescription />
    <longDescription>LoadTape allows you to load a tape object previously saved with SaveTape for use
with the PlayBack command.</longDescription>
  </command>
  <command name="AbsMouse">
    <keyword>AbsMouse</keyword>
    <fullCommand>AbsMouse X,Y</fullCommand>
    <parameters>X,Y</parameters>
    <shortDescription />
    <longDescription>AbsMouse allows you to position the mouse pointer at an absolute display location.
The X parameter specifies how far across the display the pointer is to be
positioned, while the Y parameter specifies how far down the display.

X must be in the range zero through 639. Y must be in the range zero through 399 for
NTSC machines, or zero through 511 for PAL machines.</longDescription>
  </command>
  <command name="RelMouse">
    <keyword>RelMouse</keyword>
    <fullCommand>RelMouse X Offset,Y Offset</fullCommand>
    <parameters>X Offset,Y Offset</parameters>
    <shortDescription />
    <longDescription>RelMouse allows you to move the mouse pointer a relative distance from it's current
location.

Positive offset parameters will move the pointer rightwards and downwards, while
negative offset parameters will move the pointer leftwards and upwards.</longDescription>
  </command>
  <command name="MouseButton">
    <keyword>MouseButton</keyword>
    <fullCommand>MouseButton Button,On|Off : 0=Left</fullCommand>
    <parameters>Button,On|Off : 0=Left</parameters>
    <shortDescription />
    <longDescription>MouseButton allows you to alter the status of the Amiga's left or right mouse
buttons. Button should be set to zero to alter the left mouse button, or one to
alter the right mouse button.

On/Off refers to whether the mouse button should be pressed (On) or released (Off).</longDescription>
  </command>
  <command name="ClickButton">
    <keyword>ClickButton</keyword>
    <fullCommand>ClickButton Button : 0=Left</fullCommand>
    <parameters>Button : 0=Left</parameters>
    <shortDescription />
    <longDescription>ClickButton is identical to executing two MouseButton commands - one for pressing
the mouse button down, and one for releasing it. This can be used for such things as
gadget selection.</longDescription>
  </command>
  <command name="MacroKey">
    <keyword>MacroKey</keyword>
    <fullCommand>MacroKey Tape#,Rawkey,Qualifier</fullCommand>
    <parameters>Tape#,Rawkey,Qualifier</parameters>
    <shortDescription />
    <longDescription>MacroKey causes a previously defined tape object to be attached to a particular
keyboard key. RawKey and Qualifier define the key the tape should be attached to.</longDescription>
  </command>
  <command name="TapeTrap">
    <keyword>TapeTrap</keyword>
    <fullCommand>TapeTrap [Tape#]</fullCommand>
    <parameters>[Tape#]</parameters>
    <shortDescription />
    <longDescription>TapeTrap allows you to record a sequence of AbsMouse, RelMouse, MouseButton and
ClickButton events to a tape object.

TapeTrap works similarly to Record, in that both commands are used to create a tape.
However, whereas Record receives information from the actual mouse and keyboard,
TapeTrap receives information from any AbsMouse, RelMouse, MouseButton and
ClickButton commands which may be executed. TapeTrap with no parameter will finish
tape creation.</longDescription>
  </command>
  <command name="QuietTrap">
    <keyword>QuietTrap</keyword>
    <fullCommand>QuietTrap On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription>QuietTrap determines the way in which any TapeTrapping will be executed.

QuietTrap On will cause any AbsMouse, RelMouse, MouseButton and ClickButton commands
to be recorded to tape, but not to actually have any effect on the porgram currently
running.

QuietTrap Off will cause any AbsMouse, RelMouse, MouseButton and ClickButton
commands to be recorded to tape, AND to cause their usual effects. QuietTrap Off is
the default mode.</longDescription>
  </command>
  <command name="Type">
    <keyword>Type</keyword>
    <fullCommand>Type String$</fullCommand>
    <parameters>String$</parameters>
    <shortDescription />
    <longDescription>Type causes Intution to behave exactly as if a certain series of keyboard characters
had been entered. These are normally sent to the currently active window.</longDescription>
  </command>
  <command name="QuickPlay">
    <keyword>QuickPlay</keyword>
    <fullCommand>QuickPlay On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XStatus">
    <keyword>XStatus</keyword>
    <fullCommand>XStatus</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>XStatus returns a value depending upon the current state of the BRexx system.
Possible return values and their meanings are as follows:

0 BRexx is currently inactive. No tapes are either being recorded or played back.
1 BRexx is currently in the process of recording a tape. This may be due to either
  the Record or TapeTrap commands.
2 BRexx is currently playing a tape back.</longDescription>
  </command>
  <command name="PlayWait">
    <keyword>PlayWait</keyword>
    <fullCommand>PlayWait</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>PlayWait may be used to halt program flow until a PlayBack of a tape has finished.</longDescription>
  </command>
  <command name="FreeMacroKey">
    <keyword>FreeMacroKey</keyword>
    <fullCommand>FreeMacroKey Rawkey,Qualifier</fullCommand>
    <parameters>Rawkey,Qualifier</parameters>
    <shortDescription />
    <longDescription>FreeMacroKey causes a previously defined macro key to be removed so that a BRexx
tape is no longer attatched to it.</longDescription>
  </command>
  <command name="NumPars">
    <keyword>NumPars</keyword>
    <fullCommand>NumPars</fullCommand>
    <parameters />
    <shortDescription>pars.w=NumPars  Number of paramters passed to program.</shortDescription>
    <longDescription>The NumPars function allows an executable file to determine how many parameters were
passed to it by either Workbench or the CLI. Parameters passed from the CLI are
typed following the program name and separated by spaces.

For example. Let's say you have created an executable program called myprog, and run
it trom the CLI in the following way:

myprog file1 file2

In this case, NumPars would return the value '2' - 'file1' and 'file2' beng the 2
parameters.

Programs run from Workbench are only capable of picking up 1 parameter through the
use of either the parameter file's 'Default Tool' entry in it's '.info' file, or by
use of multiple selection through the 'Shift' key.

If no parameters are supplied to an executable file, NumPars will return 0. During
program development, the 'CLI Arguement' menu item in the 'COMPILER' menu allows you
to test out CLI parameters.</longDescription>
  </command>
  <command name="Par$">
    <keyword>Par$</keyword>
    <fullCommand>Par$</fullCommand>
    <parameters />
    <shortDescription>parameter$=Par$(Paramter#)   Returns the string value of a parameter.</shortDescription>
    <longDescription>Par$ return a string equivalent to a parameter passed to an executable file through
either the CLI or Workbench. Please refer to NumPars for more information on
parameter passing.</longDescription>
  </command>
  <command name="FromCLI">
    <keyword>FromCLI</keyword>
    <fullCommand>FromCLI</fullCommand>
    <parameters />
    <shortDescription>result=FromCLI   0=Run from WorkBench, -1=Run from CLI.</shortDescription>
    <longDescription>Returns TRUE (-1) if your program was run from the CLI, or FALSE (0) if run from the
WorkBench.</longDescription>
  </command>
  <command name="ParPath$">
    <keyword>ParPath$</keyword>
    <fullCommand>ParPath$</fullCommand>
    <parameters />
    <shortDescription>path$=ParPath$(Par#,#type)  Full/Dir path of WB arg. (v36+ only!).</shortDescription>
    <longDescription>ParPath$ returns the path that the parameter resides in, 'type' specifies how you
want the path returned:

0  You want only the directory of the parameter returned.
1  You want the directory along with the parameter name returned.

If you passed the parameter "FRED" to your program from WorkBench, and FRED resides
in the directory "work:mystuff/myprograms" then:

ParPath$(0,0) will return "work:mystuff/myprograms", but:
ParPath$(0,1) will return "work:mystuff/myprograms/FRED".

The way WB handles argument passing of directories is different to that of files.
When a directory is passed as an argument, ArgsLib gets an empty string for the
name, and the directory string holds the path to the passed directory AND the
directory name itself.</longDescription>
  </command>
  <command name="SetCollOdd">
    <keyword>SetCollOdd</keyword>
    <fullCommand>SetCollOdd</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>SetCollOdd is used to control the detection of sprite/bitmap collisions. SetCollOdd
will cause ONLY the collisions between sprites and 'odd coloured' bitmap graphics to
be reported. Odd coloured bitmap graphics refers to any bitmap graphics rendered in
an odd colour number (de: 1,3,5...). This allows you to design bitmap graphics in
such a way that even coloured areas are 'safe' (de: they will not report a
collision) whereas odd colour areas are 'unsafe' (de: they will report a collision).

The DoColl and PColl commands are used to detect the actual sprite/bitmap
collisions.</longDescription>
  </command>
  <command name="SetColl">
    <keyword>SetColl</keyword>
    <fullCommand>SetColl Colour,Bitplanes[,Playfield 1=front, 2=back]</fullCommand>
    <parameters>Colour,Bitplanes[,Playfield 1=front, 2=back]</parameters>
    <shortDescription />
    <longDescription>There are 3 different commands involved in controlling sprite/bitmap collision
detection, of which SetColl is one (the other 2 being SetCollOdd and SetCollHi). All
three determine what colours in a bitmap will cause a collision with sprites. This
allows you to design bitmaps with 'safe' and 'unsafe' areas.

SetColl allows you to specify a single colour which, when present in a bitmap, and
in contact with a sprite, will cause a collision. The Colour parameter refers to the
'collidable' colour. Bitplanes refers to the number of bitplanes (depth) that bitmap
collision are to be tested in.

The optional PlayField parameter is only used in a dualplayfield slice. If Playfield
is 1, then Colour refers to a colour in the foreground bitmap. If Playfield is 0,
then Colour refers to a colour in the background bitmap.

DoColl and PColl are the commands used for actually detecting the collisions.</longDescription>
  </command>
  <command name="SetCollHi">
    <keyword>SetCollHi</keyword>
    <fullCommand>SetCollHi Bitplanes</fullCommand>
    <parameters>Bitplanes</parameters>
    <shortDescription />
    <longDescription>SetCollHi may be used to enable sprite/bitmap collisions between sprites and the
'high half' colour range of a bitmap. For example, if you have a 16 colour bitmap,
the high half of the colours would be colours 8 through 15.

The BitPlanes parameter should be set to the number of bitplanes (depth) of the
bitmap with which collisions should be detected.

Please refer to the SetColl command for more information on sprite/bitmap
collisions.</longDescription>
  </command>
  <command name="ShapesHit">
    <keyword>ShapesHit</keyword>
    <fullCommand>ShapesHit(Shape#,X,Y,Shape#,X,Y)</fullCommand>
    <parameters>(Shape#,X,Y,Shape#,X,Y)</parameters>
    <shortDescription />
    <longDescription>The ShapesHit function will calculate whether the rectangular areas occupied by 2
shapes overlap. ShapesHit will automatically take the shape handles into account. If
the 2 shapes overlap, ShapesHit will return true (-1), otherwise ShapesHit will
return false (0).</longDescription>
  </command>
  <command name="ShapeSpriteHit">
    <keyword>ShapeSpriteHit</keyword>
    <fullCommand>ShapeSpriteHit(Shape#,X,Y,Sprite#,X,Y)</fullCommand>
    <parameters>(Shape#,X,Y,Sprite#,X,Y)</parameters>
    <shortDescription />
    <longDescription>The ShapeSpriteHit function will calculate whether the rectangular area occupied by
a shape at one position, and the rectangular area occupied by a sprite at another
position are overlapped. If the areas do overlap,

ShapeSpriteHit will return true (-1), otherwise ShapeSpriteHit will return false
(0). ShapeSpriteHit automatically takes the handles of both the shape and the sprite
into account.</longDescription>
  </command>
  <command name="SpritesHit">
    <keyword>SpritesHit</keyword>
    <fullCommand>SpritesHit(Sprite#,X,Y,Sprite#,X,Y)</fullCommand>
    <parameters>(Sprite#,X,Y,Sprite#,X,Y)</parameters>
    <shortDescription />
    <longDescription>The SpritesHit function will calculate whether the rectangular areas occupied by 2
sprites overlap. SpritesHit will automatically take the sprite handles into account.
If the 2 sprites overlap, SpritesHit will return true (-1), otherwise SpritesHit
will return false (0).

Care should be taken with the pronunciation of this command.</longDescription>
  </command>
  <command name="RectsHit">
    <keyword>RectsHit</keyword>
    <fullCommand>RectsHit(X1,Y1,Width1,Height1,X2,Y2,Width2,Height2)</fullCommand>
    <parameters>(X1,Y1,Width1,Height1,X2,Y2,Width2,Height2)</parameters>
    <shortDescription />
    <longDescription>The RectsHit function may be used to determine whether 2 arbitrary rectangular areas
overlap. If the specified rectangular areas overlap, RectsHit will return true (-1),
otherwise RectsHit will return false (0).

Care should be taken with the pronunciation of this command.</longDescription>
  </command>
  <command name="SColl">
    <keyword>SColl</keyword>
    <fullCommand>SColl(Sprite Channel,Sprite Channel)</fullCommand>
    <parameters>(Sprite Channel,Sprite Channel)</parameters>
    <shortDescription />
    <longDescription>SColl may be used to determine whether the 2 sprites currently displayed through the
specified sprite channels have collided. If they have, SColl will return true (-1),
otherwise SColl will return false (0). DColl must have been executed prior to using
SColl.</longDescription>
  </command>
  <command name="PColl">
    <keyword>PColl</keyword>
    <fullCommand>PColl(Sprite Channel)</fullCommand>
    <parameters>(Sprite Channel)</parameters>
    <shortDescription />
    <longDescription>The PColl function may be used to find out if a particular sprite has collided with
any bitmaps. Sprite Channel refers to the sprite channel of the sprite you wish to
check is being displayed through.

If the specified sprite has collided with any bitmap graphics, PColl will return a
true (-1) value, otherwise PColl will return false (0).

Before using PColl, a DoColl must previously have been executed. Please refer to
DoColl for more information.</longDescription>
  </command>
  <command name="DoColl">
    <keyword>DoColl</keyword>
    <fullCommand>DoColl</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>DoColl is used to perform sprite/bitmap collision checking. Once DoColl is executed,
the PColl and/or SColl functions may be used to check for sprite/bitmap or
sprite/sprite collisions.

Before DoColl may be used with PColl, the type of bitmap collisions to be detected
must have been specified using one of the SetColl, SetCollOdd or SetCollHi commands.

After executing a DoColl, PColl and SColl will return the same values until the next
time DoColl is executed.</longDescription>
  </command>
  <command name="Implode">
    <keyword>Implode</keyword>
    <fullCommand>Implode Error/CrunchedLen=Bufferadr,DataLen,?Callback</fullCommand>
    <parameters>Error/CrunchedLen=Bufferadr,DataLen,?Callback</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Deplode">
    <keyword>Deplode</keyword>
    <fullCommand>Deplode Success=Startadr</fullCommand>
    <parameters>Success=Startadr</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CrMDecrunch">
    <keyword>CrMDecrunch</keyword>
    <fullCommand>CrMDecrunch Bufferadr [,Destinationadr]</fullCommand>
    <parameters>Bufferadr [,Destinationadr]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PPDecrunch">
    <keyword>PPDecrunch</keyword>
    <fullCommand>PPDecrunch Bufferadr,Bufferend,Destinationadr</fullCommand>
    <parameters>Bufferadr,Bufferend,Destinationadr</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitCopList">
    <keyword>InitCopList</keyword>
    <fullCommand>InitCopList CopList#[,type]|[,ypos,height,type,sprites,colors,numcustoms]</fullCommand>
    <parameters>CopList#[,type]|[,ypos,height,type,sprites,colors,numcustoms]</parameters>
    <shortDescription />
    <longDescription>InitCopList is used to create a CopList for use with the CreateDisplay command.

The ypos and height parameters define the vertical section of the screen the display
will take up.

Sprites, Colors and Customs will allocate instructions for that many sprites
(always=8!) colors (yes, as many as 256!) and custom copper instructions (which need
to be allocated to take advantage of the custom commands listed at the end of this
section).

A shortened version of the InitCopList command is available that simply requires the
CopList# and the Type. From the Type it fills in the missing parameters.

As with slices several lines must be left between coplists when displaying more than
one.

The following constants make up the type patameter, add the number of bitplanes to
the total to make up the type parameter:

Type            Value 

#smoothscroll   $10     #dualplayfield   $20     #extrahalibrite   $40
#ham            $80     #lores           $000    #hires            $100
#super          $200    #loressprites    $400    #hiressprites     $800
#supersprites   $c00
#fmode0         $0000   #fmode1          $1000   #fmode2          $2000
#fmode3         $3000   #agapalette      $10000

For displays on non-AGA machines only #fmode0 and #loressprites are allowed.

More documentation, examples and fixes will be published soon for creating displays.</longDescription>
  </command>
  <command name="CreateDisplay">
    <keyword>CreateDisplay</keyword>
    <fullCommand>CreateDisplay CopList#[,CopList#..]</fullCommand>
    <parameters>CopList#[,CopList#..]</parameters>
    <shortDescription />
    <longDescription>CreateDisplay is used to setup a new screen display with the new display library.
Any number of CopLists can be passed to CreateDisplay although at present they must
be in order of vertical position and not overlap. CreateDisplay then LINKs the
Coplists together using internal pointers. bitmaps, colours and sprites attached to
coplists are not affected.</longDescription>
  </command>
  <command name="DisplayBitMap">
    <keyword>DisplayBitMap</keyword>
    <fullCommand>DisplayBitMap CopList#,bmap[,x,y] [,bmap[,x,y]]</fullCommand>
    <parameters>CopList#,bmap[,x,y] [,bmap[,x,y]]</parameters>
    <shortDescription />
    <longDescription>The DisplayBitMap command is similar in usage to the slice libraries' show commands.
Instead of different commands for front and back playfields and smooth scroll
options there is only the one DisplayBitMap command with various parameter options.
With AGA machines, the x positioning of lores and hires coplists uses the fractional
part of the x parameter for super smooth scrolling. The CopList must be initialised
with the smooth scrolling flag set if the x,y parameters are used, same goes tor
dualplayfield.</longDescription>
  </command>
  <command name="DisplaySprite">
    <keyword>DisplaySprite</keyword>
    <fullCommand>DisplaySprite CopList#,Sprite#,X,Y,Sprite Channel</fullCommand>
    <parameters>CopList#,Sprite#,X,Y,Sprite Channel</parameters>
    <shortDescription />
    <longDescription>DisplaySprite is similar to the slice libraries ShowSprite cotnmand with the added
advantage of super hires positioning and extra wide sprite handling. See also
SpriteMode and the Usage discussion above.</longDescription>
  </command>
  <command name="DisplayPalette">
    <keyword>DisplayPalette</keyword>
    <fullCommand>DisplayPalette CopList#,Palette# [,coloroffset] [,coloroffset,bankoffset]</fullCommand>
    <parameters>CopList#,Palette# [,coloroffset] [,coloroffset,bankoffset]</parameters>
    <shortDescription />
    <longDescription>DisplayPalette copies colour information from a Palette to the CopList specified.</longDescription>
  </command>
  <command name="DisplayControls">
    <keyword>DisplayControls</keyword>
    <fullCommand>DisplayControls CopList#,BPLCON2,BPLCON3,BPLCON4</fullCommand>
    <parameters>CopList#,BPLCON2,BPLCON3,BPLCON4</parameters>
    <shortDescription />
    <longDescription>DisplayControls allows access to the more remote options available in the Amiga's
display system. The following are the most important bits from these registers
(still unpublished by Commodore!)

The default values are given at the top of the table, the parameters are exclusive
or'd with these values.

To set all the sprite color offsets to 1 so that sprite colours are fetched from
color registers 240..255 instead of 16..31 we would use the parameters:

DisplayControls 0,0,0,$ee

Bit#    BPLCON2       BPLCON3                      BPLCON4
        ($224)        ($c00)                       ($11)

15          *         BANK2 *activecolorbank       BPLAM7 ;xorithbitplane
14      ZDBPSEL2      BANK1 *                      BPLAM6 ;DMA altering
13      ZDBPSEL1      BANK0 *                      BPLAM5 ;effectivecolour
12      ZDBPSEL0      PF20F2 coloffset pfield 2    BPLAM4 ;look up
11      ZDBPEN        PF20F1                       BPLAM3
10      ZDCTEN        PF20F0                       BPLAM2
09      KILLEHB *     LOCT *palette hi/lo nibble   BPLAM1
08      RDRAM=0 *                                  BPLAM0
07      SOGEN         SPRESI *sprite res           ESPRM7 high order color
06      PF2PRI H      SPRES0 *                     ESPRM6 offset for even
05      PF2P2         BRDRBLANK border             ESPRM5 sprites
04      PF2P1         BRDNTRAN zd=border           ESPRM4
03      PFIP0                                      OSPRM7 hiorder color
02      PFIP2         ZDCLCKEN zd= 14mhz           OSPRM6 offset for odd
01      PFIP1         BRDSPRT spritesinborders!    OSPRM5 sprites
00      PFIP0         EXTBLKEN blank output?       OSPRM4


! = Don't touch
H - See standard hardware reference manual
* - controlled by display.library
ZD- any reference to ZD is only a guess (just sold my genlock).</longDescription>
  </command>
  <command name="DisplayAdjust">
    <keyword>DisplayAdjust</keyword>
    <fullCommand>DisplayAdjust CopList#,fetchwid,ddfstrt,ddfstop,diwstrt,diwstop</fullCommand>
    <parameters>CopList#,fetchwid,ddfstrt,ddfstop,diwstrt,diwstop</parameters>
    <shortDescription />
    <longDescription>Temporary control of display registers until I get the widthadjust parameter working
with InitCopList. Currently only standard width displays are available but you can
modify the width manually (just stick a screwdriver in the back of your 1084) or
with some knowledge of Commodores AGA circuitry. Ha ha ha. No to be quite serious I
really do not have a clue how they cludeged up the Amiga chip set. When ECS was
introduced suddenly all display fetching moved to the right. Now they seem to have
done the same to sprites so it is near impossible to have them all going without
limiting yourself to a seriously thin display.

If you hack around with the system copperlists you'll find they actually change
fetch modes as you scroll a viewport across the display and

Commodore say you should not use sprites anyway so as to be compatible with their
new hardware which is rumoured to run WindowsNT, yipeee. By then we will be
hopefully shipping the Jaguarlib for Blitz. (close than you think)...</longDescription>
  </command>
  <command name="CustomColors">
    <keyword>CustomColors</keyword>
    <fullCommand>CustomColors CopList#,CCOffset,YPos,Palette,startcol,numcols[,thru256flag]</fullCommand>
    <parameters>CopList#,CCOffset,YPos,Palette,startcol,numcols[,thru256flag]</parameters>
    <shortDescription>ecs=2+n aga=2+n+n+n/16.</shortDescription>
    <longDescription>Using the custom copper space in a display, CustomColors will alter the displays
palette at the given YPos. The number of customcops required is either 2+numcols for
ECS displays and 2+n+n+n/16 for AGA displays. In AGA, numcols must be a multiple of
32.

Note that large AGA palette changes may take several lines of the display to be complete.</longDescription>
  </command>
  <command name="CustomString">
    <keyword>CustomString</keyword>
    <fullCommand>CustomString CopList#,CCOffset,YPos,Copper$</fullCommand>
    <parameters>CopList#,CCOffset,YPos,Copper$</parameters>
    <shortDescription>2+n {n=len(a$)/4}.</shortDescription>
    <longDescription>CustomString allows the user to insert their own copper commands (contained in a
string) into the display's copper list at a given vertical position. The amount of
space required is equal to the number of copper instructions in the Copper$ (length
of string divide by 4) plus 2 which of course have to be allocated with InitCopList
before CustomString is used.</longDescription>
  </command>
  <command name="DisplayDblScan">
    <keyword>DisplayDblScan</keyword>
    <fullCommand>DisplayDblScan CopList#,Mode[,copoffset]</fullCommand>
    <parameters>CopList#,Mode[,copoffset]</parameters>
    <shortDescription>2.</shortDescription>
    <longDescription>DisplayDblScan is used to divide the vertical resolution of the display by 2,4,8 or
16 using Modes 1,2,3 and 4. This is most useful for fast bitmap based zooms. A Mode
of 0 will return the display to 100% magnification.

As with the DisplayRainbow, DisplayRGB, DisplayUser and DisplayScroll commands
DisplayDblScan uses the new line by line copper control of the display library. To
initialise this mode a negative parameter is used in the CustomCops parameter of the
InitCopList command. DisplayDblScan requires 2 copper instructions per line (make
CustomCops=-2).</longDescription>
  </command>
  <command name="DisplayRainbow">
    <keyword>DisplayRainbow</keyword>
    <fullCommand>DisplayRainbow CopList#,Register,Palette[,copoffset]</fullCommand>
    <parameters>CopList#,Register,Palette[,copoffset]</parameters>
    <shortDescription>ecs=1 aga=4.</shortDescription>
    <longDescription>DisplayRainbow is used to alter a certain colour register vertically down a display.
It simple maps each colour in a palette to the coresponding vertical position of the
display. ECS displays require one copper instruction per line while AGA displays
require 4.</longDescription>
  </command>
  <command name="DisplayRGB">
    <keyword>DisplayRGB</keyword>
    <fullCommand>DisplayRGB CopList#,Register,line,r,g,b[,copoffset]</fullCommand>
    <parameters>CopList#,Register,line,r,g,b[,copoffset]</parameters>
    <shortDescription>ecs=1 aga=4.</shortDescription>
    <longDescription>DisplayRGB is a single line version of DisplayRainbow allowing the programmer to
alter any register of any particular line. As with DisplayRainbow ECS displays
require 1 copper instruction while AGA requires 4.</longDescription>
  </command>
  <command name="DisplayUser">
    <keyword>DisplayUser</keyword>
    <fullCommand>DisplayUser CopList#,Line,String[,Offset]</fullCommand>
    <parameters>CopList#,Line,String[,Offset]</parameters>
    <shortDescription />
    <longDescription>DisplayUser allows the programmer to use their own Copper$ at any line of the
display. Of course copper instructions have to be allocated with the number of
copper instructions in the InitCoplist multiplied by - 1.</longDescription>
  </command>
  <command name="DisplayScroll">
    <keyword>DisplayScroll</keyword>
    <fullCommand>DisplayScroll CopList#,&amp;xpos.q(n),&amp;xpos.q(n)[,Offset]</fullCommand>
    <parameters>CopList#,&amp;xpos.q(n),&amp;xpos.q(n)[,Offset]</parameters>
    <shortDescription>3.</shortDescription>
    <longDescription>DisplayScroll allows the program to dynamically display any part of a bitmap on any
line of the display. DisplayScroll should always follow the DisplayBitMap command.
The parameters are two arrays holding a list of xoffsets that represent the
difference in horizontal position from the line above. AGA machines are able to use
the fractional part of each entry for super hiresolution positioning of the bitmap.
Three instructions per line are required for the DisplayScroll command.</longDescription>
  </command>
  <command name="CustomSprites">
    <keyword>CustomSprites</keyword>
    <fullCommand>CustomSprites CopList#,CCOffset,YPos,NumSprites</fullCommand>
    <parameters>CopList#,CCOffset,YPos,NumSprites</parameters>
    <shortDescription>4n+2.</shortDescription>
    <longDescription>CustomSprites inserts a copper list that reinitialises the sprites hardware at a
certain vertical position in the display. These lower sprites are assigned sprite
numbers of 8..15. CustomCops required = 4 x numsprites + 2.</longDescription>
  </command>
  <command name="CustomChunky">
    <keyword>CustomChunky</keyword>
    <fullCommand>CustomChunky CopList#,CCOffset,YPos,width,height,res[,splitpos]</fullCommand>
    <parameters>CopList#,CCOffset,YPos,width,height,res[,splitpos]</parameters>
    <shortDescription>4n+2.</shortDescription>
    <longDescription />
  </command>
  <command name="CustomChunkySize">
    <keyword>CustomChunkySize</keyword>
    <fullCommand>CustomChunkySize width,height</fullCommand>
    <parameters>width,height</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DisplayGenlock">
    <keyword>DisplayGenlock</keyword>
    <fullCommand>DisplayGenlock BPLCON0</fullCommand>
    <parameters>BPLCON0</parameters>
    <shortDescription>2=use external sync 4=interlace.</shortDescription>
    <longDescription />
  </command>
  <command name="SystemDate">
    <keyword>SystemDate</keyword>
    <fullCommand>SystemDate Returns system date as number of days since 1/1/1978</fullCommand>
    <parameters>Returns system date as number of days since 1/1/1978</parameters>
    <shortDescription />
    <longDescription>SystemDate returns the system date as the number of days passed since 1/1/1978.</longDescription>
  </command>
  <command name="Date$">
    <keyword>Date$</keyword>
    <fullCommand>Date$ days.l</fullCommand>
    <parameters>days.l</parameters>
    <shortDescription>converts days since 1/1/1978 to date string.</shortDescription>
    <longDescription>Date$ converts the format returned by SystemDate (days passed since 1/1/1978) into a
string format of dd/mm/yyyy or mm/dd/yyyy depending on the dateformat (defaults to
0).</longDescription>
  </command>
  <command name="NumDays">
    <keyword>NumDays</keyword>
    <fullCommand>NumDays date$</fullCommand>
    <parameters>date$</parameters>
    <shortDescription>converts dd/mm/yyyy to days since 1/1/1978.</shortDescription>
    <longDescription>Numdays converts a Date$ in the above format to the day count format, where numdays
is the number of days since 1/1/1978.</longDescription>
  </command>
  <command name="DateFormat">
    <keyword>DateFormat</keyword>
    <fullCommand>DateFormat 0=dd/mm/yyyy 1=mm/dd/yyyy</fullCommand>
    <parameters>0=dd/mm/yyyy 1=mm/dd/yyyy</parameters>
    <shortDescription />
    <longDescription>DateFormat configures the way both date$ and numdays treat a string representation
of the date: 0=dd/mm/yyyy and 1=mm/dd/yyyy.</longDescription>
  </command>
  <command name="Days">
    <keyword>Days</keyword>
    <fullCommand>Days</fullCommand>
    <parameters />
    <shortDescription>;returns day calculated in last call to date$.</shortDescription>
    <longDescription>Days Months and Years each return the particular value relevant to the last call to
SystemDate. They are most useful for when the program needs to format the output of
the date other than that produced by date$. WeekDay returns which day of the week it
is with Sunday=0 through to Saturday=6.</longDescription>
  </command>
  <command name="Months">
    <keyword>Months</keyword>
    <fullCommand>Months</fullCommand>
    <parameters />
    <shortDescription>;returns month calculated in last call to date$.</shortDescription>
    <longDescription>See description of Days.</longDescription>
  </command>
  <command name="Years">
    <keyword>Years</keyword>
    <fullCommand>Years</fullCommand>
    <parameters />
    <shortDescription>;returns year calculated in last call to date$.</shortDescription>
    <longDescription>See description of Days.</longDescription>
  </command>
  <command name="WeekDay">
    <keyword>WeekDay</keyword>
    <fullCommand>WeekDay</fullCommand>
    <parameters />
    <shortDescription>;returns day of week calculated in last call to date$.</shortDescription>
    <longDescription>See description of Days.</longDescription>
  </command>
  <command name="Hours">
    <keyword>Hours</keyword>
    <fullCommand>Hours</fullCommand>
    <parameters />
    <shortDescription>;gets system time and returns hour of day.</shortDescription>
    <longDescription>Hours, Mins and Secs return the time of day when SystemDate was last called.</longDescription>
  </command>
  <command name="Mins">
    <keyword>Mins</keyword>
    <fullCommand>Mins</fullCommand>
    <parameters />
    <shortDescription>;returns minutes calculated at last call to hour.</shortDescription>
    <longDescription>Hours, Mins and Secs return the time of day when SystemDate was last called.</longDescription>
  </command>
  <command name="Secs">
    <keyword>Secs</keyword>
    <fullCommand>Secs</fullCommand>
    <parameters />
    <shortDescription>;returns seconds calculated at last call to hour.</shortDescription>
    <longDescription>Hours, Mins and Secs return the time of day when SystemDate was last called.</longDescription>
  </command>
  <command name="Edit$">
    <keyword>Edit$</keyword>
    <fullCommand>Edit$([DefaultString$,]Characters)</fullCommand>
    <parameters>([DefaultString$,]Characters)</parameters>
    <shortDescription />
    <longDescription>Edit$ is Blitz's standard text input command. When used with Window and BitMap Input
Edit$ causes the optional DefaultString$ and a cursor to be printed to the display.
It then waits for the user to hit RETURN. Edit$ returns the text entered by the
program user as a string of character.

During FileInput Edit$ reads the next n characters from the open file or until the
next endofline character (chr$(10)). To read data from files that is not standard
ascii (ignore EOL terminators) Inkey$ should be used instead of Edit$. Characters
specifies a maximum number of allowable characters for input. This is extremely
useful in preventing Edit$ from destroying display contents.</longDescription>
  </command>
  <command name="Inkey$">
    <keyword>Inkey$</keyword>
    <fullCommand>Inkey$ [(Characters)]</fullCommand>
    <parameters>[(Characters)]</parameters>
    <shortDescription />
    <longDescription>Inkey$ may be used to collect one or more characters from the current input channel.
The current input channel may be selected using commands such as WindowInput,
Filelnput or BitMapInput. Inkey$ MAY NOT he used from the Defaultinput input channel
as the CLI does not pass input back to the program until the user hits return.
Characters refers to the number of characters to collect. The default is one
character.</longDescription>
  </command>
  <command name="Edit">
    <keyword>Edit</keyword>
    <fullCommand>Edit([DefaultValue,]Characters)</fullCommand>
    <parameters>([DefaultValue,]Characters)</parameters>
    <shortDescription />
    <longDescription>Edit is Blitz's standard numeric input command. The same characteristics apply as
those for Edit$ however Edit of course only accepts numeric input.</longDescription>
  </command>
  <command name="WBWidth">
    <keyword>WBWidth</keyword>
    <fullCommand>WBWidth</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>The functions WBWidth, WBHeight, WBDepth &amp; WBViewMode return the width, height,
depth &amp; viewmode of the current WorkBench screen as configured by preferences.</longDescription>
  </command>
  <command name="WBHeight">
    <keyword>WBHeight</keyword>
    <fullCommand>WBHeight</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>See Description of WBWidth.</longDescription>
  </command>
  <command name="WBDepth">
    <keyword>WBDepth</keyword>
    <fullCommand>WBDepth</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>See Description of WBWidth.</longDescription>
  </command>
  <command name="WBViewMode">
    <keyword>WBViewMode</keyword>
    <fullCommand>WBViewMode</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>See Description of WBWidth.</longDescription>
  </command>
  <command name="Processor">
    <keyword>Processor</keyword>
    <fullCommand>Processor</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>The function Processor returns the type of processor in the computer on which the
program is currently running.

0=68000
1=68010
2=68020
3=68030
4=68040.</longDescription>
  </command>
  <command name="cr_vbr">
    <keyword>cr_vbr</keyword>
    <fullCommand>cr_vbr</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExecVersion">
    <keyword>ExecVersion</keyword>
    <fullCommand>ExecVersion</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>The function ExecVersion returns the relevant information about the system the
program is running on.

33=1.2
34=1.3
36=2.0
39=3.0.</longDescription>
  </command>
  <command name="WBExtViewMode">
    <keyword>WBExtViewMode</keyword>
    <fullCommand>WBExtViewMode</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="FadeIn">
    <keyword>FadeIn</keyword>
    <fullCommand>FadeIn Palette#[,Rate[,Low Colour,High Colour]]</fullCommand>
    <parameters>Palette#[,Rate[,Low Colour,High Colour]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FadeOut">
    <keyword>FadeOut</keyword>
    <fullCommand>FadeOut Palette#[,Rate[,Low Colour,High Colour]]</fullCommand>
    <parameters>Palette#[,Rate[,Low Colour,High Colour]]</parameters>
    <shortDescription />
    <longDescription>Fadeout will cause the colour palette of the currently used slice to be 'faded out'
from the RGB values contained in the specified Palette# down to black.

Rate# allows you to control the speed of the fade, wilh 0 being the fastest fade.
Low Colour and High Colour allow you to control which colour palette registers are
affected by the fade.

For FadeOut to work properly, the RGB values in the currently used slice should be
set to the specified Palette# prior to using FadeOut.</longDescription>
  </command>
  <command name="ASyncFade">
    <keyword>ASyncFade</keyword>
    <fullCommand>ASyncFade On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription>ASyncFade allows you control over how the FadeIn and FadeOut commands work.
Normally, FadeIn and FadeOut will halt program flow, execute the entire fade, and
then continue program flow. This is ASyncFade Off mode.

ASyncFade On will cause FadeIn and FadeOut to work differently. Instead of
performing the whole fade at once, the programmer must execute the DoFade command to
perform the next step of the fade. This allows fading to occur in parallel with
program flow.</longDescription>
  </command>
  <command name="DoFade">
    <keyword>DoFade</keyword>
    <fullCommand>DoFade</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>DoFade will cause the next step of a fade to be executed. ASyncFade On, and a FadeIn
or FadeOut must be executed prior to calling DoFade.

The FadeStatus function may be used to determine whether there are any steps of
fading left to perform.</longDescription>
  </command>
  <command name="FadeStatus">
    <keyword>FadeStatus</keyword>
    <fullCommand>FadeStatus</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>FadeStatus is used in conjunction with the DoFade command to determine if any steps
of fading have yet to be performed. If a fade process has not entirely finished yet
(de: more DoFades are required), then FadeStatus will return true (-1). If not,
FadeStatus will return false (0). Please refer to ASyncFade and DoFade for more
information.</longDescription>
  </command>
  <command name="OpenFile">
    <keyword>OpenFile</keyword>
    <fullCommand>OpenFile(File#,Filename$)</fullCommand>
    <parameters>(File#,Filename$)</parameters>
    <shortDescription />
    <longDescription>OpenFile attempts to open the file specified by Filename$. If the file was
successfully opened, OpenFile will return true (-l), otherwise, OpenFile will return
false (0).

Files opened using OpenFile may be both written to and read from. If the file
specified by Filename$, did not already exist before the file was opened, it will be
created by OpenFile.

Files opened with OpenFile are intended for use by the random access file commands,
although it is quite legal to use these files in a sequential manner.</longDescription>
  </command>
  <command name="CloseFile">
    <keyword>CloseFile</keyword>
    <fullCommand>CloseFile File#</fullCommand>
    <parameters>File#</parameters>
    <shortDescription />
    <longDescription>CloseFile is used to close a file opened using one of the file open functions
(FileOpen, ReadFile, WriteFile). This should be done to all files when they are no
longer required.</longDescription>
  </command>
  <command name="KillFile">
    <keyword>KillFile</keyword>
    <fullCommand>KillFile Filename$</fullCommand>
    <parameters>Filename$</parameters>
    <shortDescription />
    <longDescription>The KillFile command will simply attempt to delete the specified file. No error will
be returned if the file could not be deleted.</longDescription>
  </command>
  <command name="Fields">
    <keyword>Fields</keyword>
    <fullCommand>Fields File#,Var1[,Var2...]</fullCommand>
    <parameters>File#,Var1[,Var2...]</parameters>
    <shortDescription />
    <longDescription>Fields is used to set up fields of a random access file record. Once Fields is
executed, Get and Put may be used to read and write information to and from the
file. The Var parameters specify a list of variables you wish to be either read
from, or written to the file.

When a Put is executed, the values held in these variables will be transferred to
the file. When a Get is executed, these variables will take on values read from the
file.

Any string variables in the variable list MUST have been initialized to contain a
maximum number of characters. This is done using the MaxLen command. These string
variables must NEVER grow to be longer than their defined maximum length.</longDescription>
  </command>
  <command name="Put">
    <keyword>Put</keyword>
    <fullCommand>Put File#,Record</fullCommand>
    <parameters>File#,Record</parameters>
    <shortDescription />
    <longDescription>Put is used to transfer the values contained in a Fields variable list to a
particular record in a random access file. When using Put to increase the size of a
random access file, you may only add to the immediate end of file. For example, if
you have a random access file with 5 records in it, it is illegal to put record
number 7 to the file until record number 6 has been created.</longDescription>
  </command>
  <command name="Get">
    <keyword>Get</keyword>
    <fullCommand>Get File#,Record</fullCommand>
    <parameters>File#,Record</parameters>
    <shortDescription />
    <longDescription>Get is used to transfer information from a particular record of a random access file
into a variable list set up by the Fields command. Only records which also exist may
be 'got'.</longDescription>
  </command>
  <command name="FileOutput">
    <keyword>FileOutput</keyword>
    <fullCommand>FileOutput File#</fullCommand>
    <parameters>File#</parameters>
    <shortDescription />
    <longDescription>The FileOutput command causes the output of all subsequent Print and NPrint commands
to be sent to the specified sequential file. When the file is later closed, Print
statements should be returned to an appropriate output channel.

(eg: DefaultOutput or WindowOutput).</longDescription>
  </command>
  <command name="FileInput">
    <keyword>FileInput</keyword>
    <fullCommand>FileInput File#</fullCommand>
    <parameters>File#</parameters>
    <shortDescription />
    <longDescription>The FileInput command causes all subsequent Edit, Edit$ and Inkey$ commands to
receive their input from the specified file. When the file is later closed, input
should be redirected to an appropriate channel.

(eg: DefaultInput or WindowInput).</longDescription>
  </command>
  <command name="Lof">
    <keyword>Lof</keyword>
    <fullCommand>Lof(File#)</fullCommand>
    <parameters>(File#)</parameters>
    <shortDescription />
    <longDescription>Lof will return the length, in bytes, of the specified file.</longDescription>
  </command>
  <command name="FileSeek">
    <keyword>FileSeek</keyword>
    <fullCommand>FileSeek File#,Position</fullCommand>
    <parameters>File#,Position</parameters>
    <shortDescription />
    <longDescription>FileSeek allows you to move to a particular point in the specified file. The first
piece of data in a file is at position 0, the second at position 1 and so on.
Position must not be set to a value greater than the length of the file.

Used in conjunction with OpenFile and Lof, FileSeek may be used to 'append' to a
file.</longDescription>
  </command>
  <command name="Loc">
    <keyword>Loc</keyword>
    <fullCommand>Loc(File#)</fullCommand>
    <parameters>(File#)</parameters>
    <shortDescription />
    <longDescription>Loc may be used to determine your current position in the specified file. When a
file is first opened, you will be at position 0 in the file.</longDescription>
  </command>
  <command name="Eof">
    <keyword>Eof</keyword>
    <fullCommand>Eof(File#)</fullCommand>
    <parameters>(File#)</parameters>
    <shortDescription />
    <longDescription>The Eof function allows you to determine if you are currently positioned at the end
of the specified file. If so, Eof will return true (-1), otherwise Eof will return
false (0).

If you are at the end of a file, any further writing to the file will increase it's
length, while any further reading from the file will cause an error.</longDescription>
  </command>
  <command name="DosBuffLen">
    <keyword>DosBuffLen</keyword>
    <fullCommand>DosBuffLen Bytes</fullCommand>
    <parameters>Bytes</parameters>
    <shortDescription />
    <longDescription>All Blitz file handling is done through the use of special buffering routines. This
is done to increase the speed of file handling, especially in the case of sequential
files.

Initially, each file opened is allocated a 2048 byte buffer. However, if memory is
tight this buffer size may be lowered using the DosBuffLen command.</longDescription>
  </command>
  <command name="ReadFile">
    <keyword>ReadFile</keyword>
    <fullCommand>ReadFile(File#,Filename$)</fullCommand>
    <parameters>(File#,Filename$)</parameters>
    <shortDescription />
    <longDescription>ReadFile opens an already existing file specified by Filename$ for sequential
reading. If the specified file was successfully opened, ReadFile will return true
(-1), otherwise ReadFile will return false (0).

Once a file is open using ReadFile, FileInput may be used to read information from
it.</longDescription>
  </command>
  <command name="WriteFile">
    <keyword>WriteFile</keyword>
    <fullCommand>WriteFile(File#,Filename$)</fullCommand>
    <parameters>(File#,Filename$)</parameters>
    <shortDescription />
    <longDescription>WriteFile creates a new file, specified by Filename$, for the purpose of sequential
file writing. If the file was successfully opened, WriteFile will return true (-1),
otherwise, WriteFile will return false (0).

A file opened using WriteFile may be written to by using the FileOutput command.</longDescription>
  </command>
  <command name="WriteMem">
    <keyword>WriteMem</keyword>
    <fullCommand>WriteMem File#,Address,Length</fullCommand>
    <parameters>File#,Address,Length</parameters>
    <shortDescription />
    <longDescription>WriteMem allows you to write a number of bytes, determined by Length, from an
absolute memory location, determined by Address, to an open file specified by File#.</longDescription>
  </command>
  <command name="ReadMem">
    <keyword>ReadMem</keyword>
    <fullCommand>ReadMem File#,Address,Length</fullCommand>
    <parameters>File#,Address,Length</parameters>
    <shortDescription />
    <longDescription>ReadMem allows you to read a number of bytes, determined by Length, into an absolute
memory location, determined by Address, from an open file specified by File#.

Be careful using ReadMem, as writing to absolute memory may have serious
consequences if you don't known what you're doing!.</longDescription>
  </command>
  <command name="Exists">
    <keyword>Exists</keyword>
    <fullCommand>Exists(Filename$)</fullCommand>
    <parameters>(Filename$)</parameters>
    <shortDescription />
    <longDescription>Exists actually returns the length of the file, unlike Lof() Exists() is for files
that have not already been opened. If 0 the file either does not exist or is empty
or is perhaps not a file at all!

Hmmm, anyway the following poke turns off the "Please Insert Volume Blah:" requester
so you can use Exists to wait for disk changes:

Poke.l Peek.l(Peek.l(4)+276)+184,-1.</longDescription>
  </command>
  <command name="LoadBlitzFont">
    <keyword>LoadBlitzFont</keyword>
    <fullCommand>LoadBlitzFont BlitzFont#,Fontname.font$</fullCommand>
    <parameters>BlitzFont#,Fontname.font$</parameters>
    <shortDescription />
    <longDescription>LoadBlitzFont creates a blitzfont object. Blitzfonts are used in the rendering of
text to bitmaps. Normally, the standard rom resident topaz font is used to render
text to bitmaps. However, you may use LoadBlitzFont to select a font of your choice
for bitmap output.

The specified Fontname.font$ parameter specifies the name of the font to load, which
MUST be in your FONTS: directory.

LoadBlitzFont may only be used to load eight by eight non-proportional fonts.</longDescription>
  </command>
  <command name="BitMapOutput">
    <keyword>BitMapOutput</keyword>
    <fullCommand>BitMapOutput Bitmap#</fullCommand>
    <parameters>Bitmap#</parameters>
    <shortDescription />
    <longDescription>BitMapOutput may be used to redirect Print statements to be rendered onto a bitmap.
The font used for rendering may be altered using LoadBlitzFont. Fonts used for
bitmap output must be eight by eight non-proportional fonts.

BitMapOutput is mainly of use in Blitz mode, as other forms of character output
become unavailable in Blitz mode.</longDescription>
  </command>
  <command name="Colour">
    <keyword>Colour</keyword>
    <fullCommand>Colour Foreground Colour[,Background Colour]</fullCommand>
    <parameters>Foreground Colour[,Background Colour]</parameters>
    <shortDescription />
    <longDescription>Colour allows you to alter the colours use to render text to bitmaps. Foreground
colour allows you to specify the colour text is rendered in, and the optional
Background colour allows you to specify the colour of the text background.

The palette used to access these colours will depend upon whether you are in Blitz
mode or in Amiga mode. In Blitz mode, colours will come from the palette of the
currently used slice. In Amiga mode, colours will come from the palette of the
screen the bitmap is attached to.</longDescription>
  </command>
  <command name="Locate">
    <keyword>Locate</keyword>
    <fullCommand>Locate X,Y</fullCommand>
    <parameters>X,Y</parameters>
    <shortDescription />
    <longDescription>If you are using BitMapOutput to render text, Locate allows you to specify the
cursor position at which characters are rendered.

X specifies a character position across the bitmap, and is always rounded down to a
multiple of an eighth.

Y specifies a character position down the bitmap, and may be a fractional value. For
example, a Y of 1.5 will set a cusor position one and a half characters down from
the top of the bitmap.</longDescription>
  </command>
  <command name="CursX">
    <keyword>CursX</keyword>
    <fullCommand>CursX</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>When using BitMapOutput to render text to a bitmap, CursX may be used to find the
horizontal character position at which the next character Printed will appear.

CursX will reflect the cursor position of the bitmap specified in the most recently
executed BitMapOutput statement.</longDescription>
  </command>
  <command name="CursY">
    <keyword>CursY</keyword>
    <fullCommand>CursY</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>When using BitMapOutput to render text to a bitmap, CursY may be used to find the
vertical character position at which the next character Printed will appear. CursY
will reflect the cursor position of the bitmap specified in the most recently
executed BitMapOutput statement.</longDescription>
  </command>
  <command name="BitMapInput">
    <keyword>BitMapInput</keyword>
    <fullCommand>BitMapInput</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="FileRequest$">
    <keyword>FileRequest$</keyword>
    <fullCommand>FileRequest$ Title$,Pathname$,Filename$</fullCommand>
    <parameters>Title$,Pathname$,Filename$</parameters>
    <shortDescription />
    <longDescription>The FileRequest$ function will open up a standard Amiga-style file requester on the
currently used screen. Program flow will halt until the user either selects a file,
or hits the requester's 'Cancel' button. If a file was selected, FileRequest$ will
return the full file name as a string. If 'Cancel' was selected, FileRequest$ will
return a null (empty) string.

Title$ may be any string expression to be used as a title for the file requester.
Pathname$ MUST be a string variable with a MaxLen of at least 160. Filename$ MUST be
a string variable with a MaxLen of at least 64.</longDescription>
  </command>
  <command name="TextGadget">
    <keyword>TextGadget</keyword>
    <fullCommand>TextGadget GadgetList#,X,Y,Flags,Id,Text$</fullCommand>
    <parameters>GadgetList#,X,Y,Flags,Id,Text$</parameters>
    <shortDescription />
    <longDescription>The TextGadget command adds a text gadget to a gadgetlist. A text gadget is the
simplest type of gadget consisting of a sequence of characters optionally surrounded
by a border.

Flags should be selected from the table at the start of the chapter.

Boolean gadgets are the simplest type of gadget available. Boolean gadgets are 'off'
until the program user clicks on them with the mouse, which turns them 'on'. When
the mouse button is released, these gadgets revert back to their 'off' state.
Boolean gadgets are most often used for 'Ok' or 'CANCEL' type gadgets.

Toggle gadgets differ in that each time they are clicked on they change their state
between 'on' and 'off'. For example, clicking on a toggle gadget which is 'on' will
cause the gadget to be turned 'off, and vice versa.

X and Y specify where in the window the gadget is to appear. Depending upon the
Flags setting, gadgets may be positioned relative to any of the 4 window edges. If a
gadget is to be positioned relative to either the right or bottom edge of a window,
the appropriate X or Y parameter should be negative.

Id is an identification value to be attached to this gadget. All gadgets in a
gadgetlist should have unique Id numbers, allowing you to detect which gadget has
been selected. Id may be any positive, non-zero number.

Text$ is the actual text you want the gadget to contain.</longDescription>
  </command>
  <command name="StringGadget">
    <keyword>StringGadget</keyword>
    <fullCommand>StringGadget GadgetList#,X,Y,Flags,Id,Maxlen,Width</fullCommand>
    <parameters>GadgetList#,X,Y,Flags,Id,Maxlen,Width</parameters>
    <shortDescription />
    <longDescription>StringGadget allows you to create an Intuition style 'text entry' gadget. When
clicked on, a string gadget brings up a text cursor, and is ready to accept text
entry trom the keyboard.

X and Y specifies the gadgets, position, relative to the top left of the window it
is to appear in. See the beginning of the chapter for the relevant Flags tor a
string gadget.

Id is an identification value to be attached to this gadget. All gadgets in a
gadgetlist should have unique Id numbers, allowing you to detect which gadgets has
been selected. Id may be any positive, non-zero number.

Maxlen refers to the maximum number of characters which may appear in this gadgets.

Width refers to how wide, in pixels, the gadget should be. A string gadget may have
a width less than the maximum number of characters it may contain, as characters
will be scrolled through the gadget when necessary.

You may read the current contents of a string gadget using the StringText function.</longDescription>
  </command>
  <command name="PropGadget">
    <keyword>PropGadget</keyword>
    <fullCommand>PropGadget GadgetList#,X,Y,Flags,Id,Width,Height</fullCommand>
    <parameters>GadgetList#,X,Y,Flags,Id,Width,Height</parameters>
    <shortDescription />
    <longDescription>The PropGadget command is used to create a 'proportional gadget'. Proportional
gadgets present a program user with a 'slider bar', allowing them to adjust the
slider to achieve a desired effect. Proportional gadgets are commonly used for the
'R G B' sliders seen in many paint packages.

Proportional gadgets have 2 main qualities - a 'pot' (short for potentiometer)
setting, and a'body' setting.

The pot setting refers to the current position of the slider bar, and is in the
range 0 through 1. For example, a proportional gadget which has been moved to 'half
way' would have a pot setting of '.5'.

The body setting refers to the size of the units the proportional gadget represents,
and is again in the range 0 through 1. Again taking the RGB colour sliders as an
example, each slider is intended to show a particular value in the range 0 through
15 -giving a unit size, or body setting, of 1/16 or '.0625'.

Put simply, the pot setting describes 'where' the slider bar is, while the body
setting describes 'how big' it is.

Proportional gadgets may be represented as either horizontal slider bars, vertical
slider bars, or a combination of both.

See the beginning of the chapter for relevant Flags settings for prop gadgets.

X and Y refer to the gadgets position, relative to the top left of the window it is
opened in. Width and Height refer to the size of the area the slider should be
allowed to move in.

Id is a unique, non zero number which allows you to identify when the gadget is
mampulated.

Proportional gadgets may be altered using the SetVProp and SetHProp commands, and
read using the VPropPot, VPropBody, HPropPot and HPropBody functions.</longDescription>
  </command>
  <command name="ShapeGadget">
    <keyword>ShapeGadget</keyword>
    <fullCommand>ShapeGadget GadgetList#,X,Y,Flags,Id,Shape#[,Shape#]</fullCommand>
    <parameters>GadgetList#,X,Y,Flags,Id,Shape#[,Shape#]</parameters>
    <shortDescription />
    <longDescription>The ShapeGadget command allows you to create gadgets with graphic imagery. The
Shape# parameter refers to a shape object containing the graphics you wish the
gadget to contain.

The ShapeGadget command has been extended to allow an alternative image to be
displayed when the gadget is selected.

All other parameters are identical to those in TextGadget.</longDescription>
  </command>
  <command name="SetHProp">
    <keyword>SetHProp</keyword>
    <fullCommand>SetHProp GadgetList#,Id,Pot,Body</fullCommand>
    <parameters>GadgetList#,Id,Pot,Body</parameters>
    <shortDescription />
    <longDescription>SetHProp is used to alter the horizontal slider qualities of a proportional gadget.
Both Pot and Body should be in the range 0 through 1.

If SetHProp is executed while the specified gadget is already displayed, execution
of the ReDraw command will be necessary to display the changes.

For a full discussion on proportional gadgets, please refer to the PropGadget
command.</longDescription>
  </command>
  <command name="SetVProp">
    <keyword>SetVProp</keyword>
    <fullCommand>SetVProp GadgetList#,Id,Pot,Body</fullCommand>
    <parameters>GadgetList#,Id,Pot,Body</parameters>
    <shortDescription />
    <longDescription>SetVProp is used to alter the vertical slider qualities of a proportional gadget.
Both Pot and Body should be in the range 0 through 1.

If SetVProp is executed while the specified gadget is already displayed, execution
of the ReDraw command will be necessary to display the changes.</longDescription>
  </command>
  <command name="HPropPot">
    <keyword>HPropPot</keyword>
    <fullCommand>HPropPot(GadgetList#,Id)</fullCommand>
    <parameters>(GadgetList#,Id)</parameters>
    <shortDescription />
    <longDescription>The HPropPot function allows you to determine the current 'pot' setting of a
proportional gadget.

HPropPot will return a number from 0 up to, but not including, 1, reflecting the
gadgets current horizontal pot setting.</longDescription>
  </command>
  <command name="HPropBody">
    <keyword>HPropBody</keyword>
    <fullCommand>HPropBody(GadgetList#,Id)</fullCommand>
    <parameters>(GadgetList#,Id)</parameters>
    <shortDescription />
    <longDescription>The HPropBody function allows you to determine the current 'body' setting of a
proportional gadget.

HPropBody will return a number from 0 up to, but not including, 1, reflecting the
gadgets current horizontal body setting.</longDescription>
  </command>
  <command name="VPropPot">
    <keyword>VPropPot</keyword>
    <fullCommand>VPropPot(GadgetList#,Id)</fullCommand>
    <parameters>(GadgetList#,Id)</parameters>
    <shortDescription />
    <longDescription>The VPropPot function allows you to determine the current 'pot' setting of a
proportional gadget.

VPropPot will return a number from 0 up to, but not including, 1, reflecting the
gadgets current vertical pot setting.</longDescription>
  </command>
  <command name="VPropBody">
    <keyword>VPropBody</keyword>
    <fullCommand>VPropBody(GadgetList#,Id)</fullCommand>
    <parameters>(GadgetList#,Id)</parameters>
    <shortDescription />
    <longDescription>The VPropBody function allows you to determine the current 'body' setting of a
proportional gadget.

VPropBody will return a number from 0 up to, but not including, 1, reflecting the
gadgets current vertical body setting.</longDescription>
  </command>
  <command name="Redraw">
    <keyword>Redraw</keyword>
    <fullCommand>Redraw Window#,Id</fullCommand>
    <parameters>Window#,Id</parameters>
    <shortDescription />
    <longDescription>ReDraw will redisplay the specified gadget in the specified window. This command is
mainly of use when a proportional gadget has been altered using SetHProp or SetVProp
and needs to be redrawn, or when a string gadget has been cleared using ClearString,
and, likewise, needs to be redrawn.</longDescription>
  </command>
  <command name="Toggle">
    <keyword>Toggle</keyword>
    <fullCommand>Toggle GadgetList#,Id [,On|Off]</fullCommand>
    <parameters>GadgetList#,Id [,On|Off]</parameters>
    <shortDescription />
    <longDescription>The Toggle command in the gadget library has been extended so it will actually
toggle a gadgets status if the On|Off parameter is missing.</longDescription>
  </command>
  <command name="GadgetBorder">
    <keyword>GadgetBorder</keyword>
    <fullCommand>GadgetBorder X,Y,Width,Height</fullCommand>
    <parameters>X,Y,Width,Height</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Borders">
    <keyword>Borders</keyword>
    <fullCommand>Borders [On|Off]|[Width,Height]</fullCommand>
    <parameters>[On|Off]|[Width,Height]</parameters>
    <shortDescription />
    <longDescription>Borders serves 2 purposes. First, Borders may be used to turn on or off the
automatic creation of borders around text and string gadgets. Borders are created
when either a Textgadget or StringGadget command is executed. If you wish to disable
this, Borders Off should be executed before the appropriate TextGadget or
StringGadget command.

Borders may also be used to specify the spacing between a gadget and it's border,
Width referring to the left/right spacing, and Height to the above/below spacing.</longDescription>
  </command>
  <command name="ActivateString">
    <keyword>ActivateString</keyword>
    <fullCommand>ActivateString Window#,Id</fullCommand>
    <parameters>Window#,Id</parameters>
    <shortDescription />
    <longDescription>ActivateString may be used to 'automatically' activate a string gadget. This is
identical to the program user having clicked in the string gadget themselves, as the
string gadget's cursor will appear, and further keystrokes will be sent to the
string gadget.

It is often nice of a program to activate Important string gadgets, as it saves the
user the hassle of having to reach t'or the mouse before the keyboard.</longDescription>
  </command>
  <command name="ResetString">
    <keyword>ResetString</keyword>
    <fullCommand>ResetString GadgetList#,Id</fullCommand>
    <parameters>GadgetList#,Id</parameters>
    <shortDescription />
    <longDescription>ResetString allows you to 'reset' a string gadget. This will cause the string
gadget's cursor position to be set to the leftmost position.</longDescription>
  </command>
  <command name="StringText$">
    <keyword>StringText$</keyword>
    <fullCommand>StringText$(GadgetList#,Id)</fullCommand>
    <parameters>(GadgetList#,Id)</parameters>
    <shortDescription />
    <longDescription>The Stringtext$ function allows you to determine the current contents of a string
gadget. StringText$ will return a string of characters representing the string
gadgets contents.</longDescription>
  </command>
  <command name="ClearString">
    <keyword>ClearString</keyword>
    <fullCommand>ClearString GadgetList#,Id</fullCommand>
    <parameters>GadgetList#,Id</parameters>
    <shortDescription />
    <longDescription>ClearString may be used to clear, or erase, the text in the specified string gadget.
The cursor position will also be moved to the leftmost position in the string
gadget.

If a string gadget is cleared while it is displayed in a window, the text will not
be erased from the actual display. To do this, ReDraw must be executed.</longDescription>
  </command>
  <command name="GadgetPens">
    <keyword>GadgetPens</keyword>
    <fullCommand>GadgetPens Foreground Colour[,Background Colour]</fullCommand>
    <parameters>Foreground Colour[,Background Colour]</parameters>
    <shortDescription />
    <longDescription>GadgetPens determines the text colours used when text gadgets are created using the
TextGadget command. The default values used for gadget colours are a foreground
colour of 1, and a background colour of 0.</longDescription>
  </command>
  <command name="BorderPens">
    <keyword>BorderPens</keyword>
    <fullCommand>BorderPens Highlight Colour,Shadow Colour</fullCommand>
    <parameters>Highlight Colour,Shadow Colour</parameters>
    <shortDescription />
    <longDescription>BorderPens allows you to control the colours used when gadget borders are created.
Gadget borders may be created by the TextGadget, StringGadget and GadgetBorder
commands.

HighLight Colour refers to the colour of the top and left edges of the border, while
Shadow Colour refers to the right and bottom edges.

The default value for HighLight Colour is 1. The default value for Shadow Colour is
2.</longDescription>
  </command>
  <command name="GadgetJam">
    <keyword>GadgetJam</keyword>
    <fullCommand>GadgetJam Jammode</fullCommand>
    <parameters>Jammode</parameters>
    <shortDescription />
    <longDescription>GadgetJam allows you to determine the text rendering method used when gadgets are
created using the TextGadget command. Please refer to the WJam command in the
windows chapter for a full description of jam modes available.</longDescription>
  </command>
  <command name="SelectMode">
    <keyword>SelectMode</keyword>
    <fullCommand>SelectMode 1=Box, 0=Inverse</fullCommand>
    <parameters>1=Box, 0=Inverse</parameters>
    <shortDescription />
    <longDescription>SelectMode is used to predefine how gadget rendering will show a gadget selection,
modes are 1 for box and 0 for inverse. Use prior to creation of gadgets.</longDescription>
  </command>
  <command name="SetString">
    <keyword>SetString</keyword>
    <fullCommand>SetString GadgetList#,Id,String$</fullCommand>
    <parameters>GadgetList#,Id,String$</parameters>
    <shortDescription />
    <longDescription>SetString may be used to initialize the contents of a string gadget created with the
StringGadget command. If the string gadget specified by GadgetList# and Id is
already displayed, you will also need to exeucte ReDraw to display the change.</longDescription>
  </command>
  <command name="ButtonGroup">
    <keyword>ButtonGroup</keyword>
    <fullCommand>ButtonGroup Group</fullCommand>
    <parameters>Group</parameters>
    <shortDescription />
    <longDescription>ButtonGroup allows you to determine which 'group' a number of button type gadgets
belong to. Following the execution of ButtonGroup, any button gadgets created will
be identified as belonging to the spiecified group. The upshot of all this is that
button gadgets are only mutually exclusive to other button gadgets within the same
group.

'Group' must be a positive number greater than 0. Any button gadgets created before
a'ButtonGroup' command is executed will belong to group 1.</longDescription>
  </command>
  <command name="GadgetStatus">
    <keyword>GadgetStatus</keyword>
    <fullCommand>GadgetStatus(GadgetList#,Id)</fullCommand>
    <parameters>(GadgetList#,Id)</parameters>
    <shortDescription />
    <longDescription>GadgetStatus may be used to determine the status of the specified gadget.

In the case of toggle' type gadget, GadgetStatus will return true (-1) if the gadget
is currently on, or false (0) if the gadget is currently off.

In the case of a cycling text gadget, GadgetStatus will return a value of 1 or
greater representing the currently displayed text within the gadget.</longDescription>
  </command>
  <command name="ButtonId">
    <keyword>ButtonId</keyword>
    <fullCommand>ButtonId(GadgetList#,ButtonGroup)</fullCommand>
    <parameters>(GadgetList#,ButtonGroup)</parameters>
    <shortDescription />
    <longDescription>ButtonId may be used to determine which gadget within a group of button type gadgets
is currently selected.

The value returned will be the GadgetId of the button gadget currently selected.</longDescription>
  </command>
  <command name="Enable">
    <keyword>Enable</keyword>
    <fullCommand>Enable(GadgetList#,Id)</fullCommand>
    <parameters>(GadgetList#,Id)</parameters>
    <shortDescription />
    <longDescription>A gadget when disabled is covered by a "mesh" and can not be accessed by the user.
The commands Enable and Disable allow the programmer to access this feature of
Intuition.</longDescription>
  </command>
  <command name="Disable">
    <keyword>Disable</keyword>
    <fullCommand>Disable(GadgetList#,Id)</fullCommand>
    <parameters>(GadgetList#,Id)</parameters>
    <shortDescription />
    <longDescription>A gadget when disabled is covered by a "mesh" and can not be accessed by the user.
The commands Enable and Disable allow the programmer to access this feature of
Intuition.</longDescription>
  </command>
  <command name="SetGadgetStatus">
    <keyword>SetGadgetStatus</keyword>
    <fullCommand>SetGadgetStatus(GadgetList#,Id,Value)</fullCommand>
    <parameters>(GadgetList#,Id,Value)</parameters>
    <shortDescription />
    <longDescription>SetGadgetStatus is used to set a cycling text gadget to a particular value, once set
ReDraw should be used to refresh the gadget to reflect it's new value.</longDescription>
  </command>
  <command name="SetTextGadget">
    <keyword>SetTextGadget</keyword>
    <fullCommand>SetTextGadget GadgetList#,Id,Text$</fullCommand>
    <parameters>GadgetList#,Id,Text$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Joyx">
    <keyword>Joyx</keyword>
    <fullCommand>Joyx(Port)</fullCommand>
    <parameters>(Port)</parameters>
    <shortDescription />
    <longDescription>Joyx will return the left/right status of a joystick plugged into the specified
port. Port must be either 0 or 1, 0 being the port the mouse is normally plugged
into. If the joystick is held to the left, Joyx will return -1. If the joystick is
held to the right, Joyx will return 1. If the joystick is held neither left or
right, Joyx will return 0.</longDescription>
  </command>
  <command name="Joyy">
    <keyword>Joyy</keyword>
    <fullCommand>Joyy(Port)</fullCommand>
    <parameters>(Port)</parameters>
    <shortDescription />
    <longDescription>Joyy will return the up/down status of a joystick plugged into the specified port.
Port must be either 0 or 1, 0 being the port the mouse is normally plugged into. If
the joystick is held upwards, Joyy will return -1. If the joystick is held
downwrads, Joyy will return 1. If the joystick is held neither upwards or downwards,
Joyy will return 0.</longDescription>
  </command>
  <command name="Joyr">
    <keyword>Joyr</keyword>
    <fullCommand>Joyr(Port)</fullCommand>
    <parameters>(Port)</parameters>
    <shortDescription />
    <longDescription>Joyr may be used to determine the rotational direction of a joystick plugged into
the specified port. Port must be either 0 or 1, port 0 being the port the mouse is
normally plugged into. Joyr returns a value from 0 through 8 based on the following
table:

Direction   Value

Up              0
Up-Right        1
Right           2
Down-Right      3
Down            4
Down-Left       5
Left            6
Up-Left         7
No Direction    8.</longDescription>
  </command>
  <command name="Joyb">
    <keyword>Joyb</keyword>
    <fullCommand>Joyb(Port)</fullCommand>
    <parameters>(Port)</parameters>
    <shortDescription />
    <longDescription>Joyb allows you to read the button status of the device plugged into the specified
port. Port must be either 0 or 1, 0 being the port the mouse is normally plugged
into. If the left button is held down, Joyb will return 1. If the right button is
held down, Joyb will return 2. If both buttons are held down, Joyb will return 3. If
no buttons are held down, Joyb will return 0.</longDescription>
  </command>
  <command name="Gameb">
    <keyword>Gameb</keyword>
    <fullCommand>Gameb(Port)</fullCommand>
    <parameters>(Port)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SaveBitmap">
    <keyword>SaveBitmap</keyword>
    <fullCommand>SaveBitmap BitMap#,Filename$[,Palette#]</fullCommand>
    <parameters>BitMap#,Filename$[,Palette#]</parameters>
    <shortDescription />
    <longDescription>SaveBitMap allows you to save a bitmap to disk in ILBM IFF format. An optional
palette may also be saved with the IFF.</longDescription>
  </command>
  <command name="SaveScreen">
    <keyword>SaveScreen</keyword>
    <fullCommand>SaveScreen Screen#,Filename$</fullCommand>
    <parameters>Screen#,Filename$</parameters>
    <shortDescription />
    <longDescription>SaveScreen will save a screen to disk as an IFF ILBM file. The screen you wish to
save is specified by the Screen#, and the name of the file you to create is
specified by Filename$.</longDescription>
  </command>
  <command name="SaveShape">
    <keyword>SaveShape</keyword>
    <fullCommand>SaveShape Shape#,Filename$[,Palette#]</fullCommand>
    <parameters>Shape#,Filename$[,Palette#]</parameters>
    <shortDescription />
    <longDescription>SaveShape will create an ILBM IFF file based on the specified shape object. If you
want the file to contain colour information, you should also specify a palette
object using the Palette# parameter.</longDescription>
  </command>
  <command name="SavePalette">
    <keyword>SavePalette</keyword>
    <fullCommand>SavePalette Palette#,Filename$</fullCommand>
    <parameters>Palette#,Filename$</parameters>
    <shortDescription />
    <longDescription>Creates a standard IFF "CMAP" file using the given Palette's colors.</longDescription>
  </command>
  <command name="ILBMInfo">
    <keyword>ILBMInfo</keyword>
    <fullCommand>ILBMInfo Filename$</fullCommand>
    <parameters>Filename$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ILBMWidth">
    <keyword>ILBMWidth</keyword>
    <fullCommand>ILBMWidth</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>ILBMWidth will return the width, in pixels, of an ILBM image examined with ILBMInfo.</longDescription>
  </command>
  <command name="ILBMHeight">
    <keyword>ILBMHeight</keyword>
    <fullCommand>ILBMHeight</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>ILBMHeight will return the height, in pixels, of an ILBM image examined with
ILBMInfo.</longDescription>
  </command>
  <command name="ILBMDepth">
    <keyword>ILBMDepth</keyword>
    <fullCommand>ILBMDepth</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>ILBMDepth wil1 return the depth, in bitplanes, of an ILBM image examined with
ILBMInfo.</longDescription>
  </command>
  <command name="ILBMViewMode">
    <keyword>ILBMViewMode</keyword>
    <fullCommand>ILBMViewMode</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>ILBMViewMode returns the viewmode of the file that was processed by ILBMInfo. This
is useful for opening a screen in the right mode before using LoadScreen etc. The
different values of ViewMode are as follows (add/or them for different
combinations):

Mode        Value 

HiRes       32768
Ham         2048
HalfBrite   128
Interlace   4
LoRes       0.</longDescription>
  </command>
  <command name="DecodeILBM">
    <keyword>DecodeILBM</keyword>
    <fullCommand>DecodeILBM Bitmap#,MemoryLocation</fullCommand>
    <parameters>Bitmap#,MemoryLocation</parameters>
    <shortDescription />
    <longDescription>A very fast method of unpacking standard iffilbm data to a bitmap. Not only does
this command allow a faster method of loading standard IFF files but allows the
programmer to "incbin" iff pictures in their programs.See the discussion above for
using DecodeILBM on both files and included memory.</longDescription>
  </command>
  <command name="DefaultInput">
    <keyword>DefaultInput</keyword>
    <fullCommand>DefaultInput</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DefaultOutput">
    <keyword>DefaultOutput</keyword>
    <fullCommand>DefaultOutput</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>DefaultOutput cause all future Print statements to send their output to the CLI
window the Blitz program was run from. This is the default output channel used when
a Blitz program is first run.</longDescription>
  </command>
  <command name="PopInput">
    <keyword>PopInput</keyword>
    <fullCommand>PopInput</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="PopOutput">
    <keyword>PopOutput</keyword>
    <fullCommand>PopOutput</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>After output has been re-directed (eg using WindowOutput/FileOutput), PopOutput may
be used to return the channel to it's previous condition.</longDescription>
  </command>
  <command name="LoadFont">
    <keyword>LoadFont</keyword>
    <fullCommand>LoadFont IntuiFont#,Fontname.font$,Y size [,style]</fullCommand>
    <parameters>IntuiFont#,Fontname.font$,Y size [,style]</parameters>
    <shortDescription />
    <longDescription>LoadFont is used to load a font from the fonts: directory. Unlike BlitzFonts any
size IntuiFont can be used. The command WindowFont is used to set text output to a
certain IntuiFont in a particular Window.

The LoadFont command has been extended with an optional style parameter. The
following constants may be combined:

#underlined=1
#bold=2
#italic=4
#extended=8  ;wider than normal
#colour=64   ;hmm use colour version I suppose.</longDescription>
  </command>
  <command name="FirstItem">
    <keyword>FirstItem</keyword>
    <fullCommand>FirstItem(Arrayname())</fullCommand>
    <parameters>(Arrayname())</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddItem">
    <keyword>AddItem</keyword>
    <fullCommand>AddItem(Arrayname())</fullCommand>
    <parameters>(Arrayname())</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NextItem">
    <keyword>NextItem</keyword>
    <fullCommand>NextItem(Arrayname())</fullCommand>
    <parameters>(Arrayname())</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ResetList">
    <keyword>ResetList</keyword>
    <fullCommand>ResetList Arrayname()</fullCommand>
    <parameters>Arrayname()</parameters>
    <shortDescription />
    <longDescription>ResetList is used in conjunction with a list array to prepare the list array for
NextItem processing. After executing a ResetList, the next Nextitem executed will
set the list array's 'current element' pointer to the list array's very first.</longDescription>
  </command>
  <command name="KillItem">
    <keyword>KillItem</keyword>
    <fullCommand>KillItem Arrayname()</fullCommand>
    <parameters>Arrayname()</parameters>
    <shortDescription />
    <longDescription>KillItem is used to delete the specified list array's current item. After executing
KillItem, the list array's 'current item' pointer will be set to the item before the
item deleted.</longDescription>
  </command>
  <command name="AddFirst">
    <keyword>AddFirst</keyword>
    <fullCommand>AddFirst(Arrayname())</fullCommand>
    <parameters>(Arrayname())</parameters>
    <shortDescription />
    <longDescription>The AddFirst function allows you to insert an array list item at the beginning of an
array list. AddFirst returns a true/false value reflecting whether or not there was
enough room in the array list to add an element. If an array element was available,
AddFirst returns a true value (-1), and sets the list array's 'current item' pointer
to the item added. If no array element was available, AddFirst returns false (0).</longDescription>
  </command>
  <command name="ClearList">
    <keyword>ClearList</keyword>
    <fullCommand>ClearList Arrayname()</fullCommand>
    <parameters>Arrayname()</parameters>
    <shortDescription />
    <longDescription>ClearList is used in conjunction with list arrays to completely 'empty' out the
specified list array. List arrays are automatically emptied when they are Dimmed.</longDescription>
  </command>
  <command name="AddLast">
    <keyword>AddLast</keyword>
    <fullCommand>AddLast(Arrayname())</fullCommand>
    <parameters>(Arrayname())</parameters>
    <shortDescription />
    <longDescription>The AddLast function allows you to insert an array list item at the end of an array
list. AddLast returns a true/false value reflecting whether or not there was enough
room in the array list to add an element. If an array element was available, AddLast
returns a true value (-1 ), and sets the list array's 'current item' pointer to the
item added. If no array element was available, AddLast returns false (0).</longDescription>
  </command>
  <command name="PushItem">
    <keyword>PushItem</keyword>
    <fullCommand>PushItem Arrayname()</fullCommand>
    <parameters>Arrayname()</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PopItem">
    <keyword>PopItem</keyword>
    <fullCommand>PopItem Arrayname()</fullCommand>
    <parameters>Arrayname()</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PrevItem">
    <keyword>PrevItem</keyword>
    <fullCommand>PrevItem Arrayname()</fullCommand>
    <parameters>Arrayname()</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LastItem">
    <keyword>LastItem</keyword>
    <fullCommand>LastItem Arrayname()</fullCommand>
    <parameters>Arrayname()</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ItemStackSize">
    <keyword>ItemStackSize</keyword>
    <fullCommand>ItemStackSize Max Items</fullCommand>
    <parameters>Max Items</parameters>
    <shortDescription />
    <longDescription>ItemStackSize determines how many 'list' items may be pushed (using the Pushltem
command), before items must be 'Pop'ped off again. For example, executing
ItemStackSize 1000 will allow you to push up to 1000 list items before you run out
of item stack space.</longDescription>
  </command>
  <command name="SortList">
    <keyword>SortList</keyword>
    <fullCommand>SortList Arrayname(),sizeof .type\offset</fullCommand>
    <parameters>Arrayname(),sizeof .type\offset</parameters>
    <shortDescription />
    <longDescription>The SortList command is used to rearrange the order of elements in a Blitz LINKed
list. The order in which the items are sorted depends on the first field of the
LINKed list type which must be a single integer word. Sorting criteria will be
extended in future releases.</longDescription>
  </command>
  <command name="ACos">
    <keyword>ACos</keyword>
    <fullCommand>ACos(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>This returns the ArcCosine of the value Float.</longDescription>
  </command>
  <command name="ASin">
    <keyword>ASin</keyword>
    <fullCommand>ASin(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>This returns the ArcSine of the value Float.</longDescription>
  </command>
  <command name="ATan">
    <keyword>ATan</keyword>
    <fullCommand>ATan(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>This returns the ArcTangent of the value Float.</longDescription>
  </command>
  <command name="Cos">
    <keyword>Cos</keyword>
    <fullCommand>Cos(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>Cos() returns the Cosine of the value Float.</longDescription>
  </command>
  <command name="HCos">
    <keyword>HCos</keyword>
    <fullCommand>HCos(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>This returns the hyperbolic Cosine of the value Float.</longDescription>
  </command>
  <command name="Exp">
    <keyword>Exp</keyword>
    <fullCommand>Exp(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>This returns e raised to the power of Float.</longDescription>
  </command>
  <command name="Log10">
    <keyword>Log10</keyword>
    <fullCommand>Log10(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>This returns the base 10 logarithm of Float.</longDescription>
  </command>
  <command name="Log">
    <keyword>Log</keyword>
    <fullCommand>Log(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>This returns the natural (base e) logarithm of Float.</longDescription>
  </command>
  <command name="Sin">
    <keyword>Sin</keyword>
    <fullCommand>Sin(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>This returns the Sine of the value Float.</longDescription>
  </command>
  <command name="HSin">
    <keyword>HSin</keyword>
    <fullCommand>HSin(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>This returns the hyperbolic Sine of the value Float.</longDescription>
  </command>
  <command name="Sqr">
    <keyword>Sqr</keyword>
    <fullCommand>Sqr(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>This returns the square root of Float.</longDescription>
  </command>
  <command name="Tan">
    <keyword>Tan</keyword>
    <fullCommand>Tan(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>This returns the Tangent of the value Float.</longDescription>
  </command>
  <command name="HTan">
    <keyword>HTan</keyword>
    <fullCommand>HTan(Float)</fullCommand>
    <parameters>(Float)</parameters>
    <shortDescription />
    <longDescription>This returns the hyperbolic Tangent of the value Float.</longDescription>
  </command>
  <command name="LoadMedModule">
    <keyword>LoadMedModule</keyword>
    <fullCommand>LoadMedModule MedModule#,Name</fullCommand>
    <parameters>MedModule#,Name</parameters>
    <shortDescription />
    <longDescription>The LoadMedModule command loads any version 4 channel Octamed module. The following
routines support upto and including version 3 of the Amiganut's Med standard.

The number of MedModules loaded in memory at one time is only limited by the
MedModules maximum set in the Blitz Options requester. Like any Blitz commands that
access files LoadMedModule can only be used in AmigaMode.</longDescription>
  </command>
  <command name="StartMedModule">
    <keyword>StartMedModule</keyword>
    <fullCommand>StartMedModule MedModule#</fullCommand>
    <parameters>MedModule#</parameters>
    <shortDescription />
    <longDescription>StartMedModule is responsible for initialising the module including LINKing after it
is loaded from disk using the LoadMedModule command. It can also be used to restart
a module from the beginning.</longDescription>
  </command>
  <command name="PlayMed">
    <keyword>PlayMed</keyword>
    <fullCommand>PlayMed</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>PlayMed is responsible for playing the current MedModule, it must be called every
50th of a second either on an interupt (#5) or after a VWait in a program loop.</longDescription>
  </command>
  <command name="StopMed">
    <keyword>StopMed</keyword>
    <fullCommand>StopMed</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>StopMed will cause any med module to stop playing. This not only means that PlayMed
will have no affect until the next StartMedModule but silences the audio channels so
they are not left ringing as is the effect when PlayMed is not called every vertical
blank.</longDescription>
  </command>
  <command name="JumpMed">
    <keyword>JumpMed</keyword>
    <fullCommand>JumpMed Pattern#</fullCommand>
    <parameters>Pattern#</parameters>
    <shortDescription />
    <longDescription>JumpMed will change the pattern being played in the current module.</longDescription>
  </command>
  <command name="SetMedVolume">
    <keyword>SetMedVolume</keyword>
    <fullCommand>SetMedVolume Volume</fullCommand>
    <parameters>Volume</parameters>
    <shortDescription />
    <longDescription>SetMedVolume changes the overall volume that the Med Library plays the module, all
the audio channels are affected. This is most useful for fading out music by slowly
decreasing the volume from 64 to 0.</longDescription>
  </command>
  <command name="GetMedVolume">
    <keyword>GetMedVolume</keyword>
    <fullCommand>GetMedVolume Channel</fullCommand>
    <parameters>Channel</parameters>
    <shortDescription />
    <longDescription>GetMedVolume returns the current volume setting of the specified audio channel. This
is useful for graphic effects that you may wish to sync to certain channels of the
music playing.</longDescription>
  </command>
  <command name="GetMedNote">
    <keyword>GetMedNote</keyword>
    <fullCommand>GetMedNote Channel</fullCommand>
    <parameters>Channel</parameters>
    <shortDescription />
    <longDescription>GetMedNote returns the current note playing from the specified channel. As with
GetMedVolume this is useful for producing graphics effects synced to the music the
Med Library is playing.</longDescription>
  </command>
  <command name="GetMedInstr">
    <keyword>GetMedInstr</keyword>
    <fullCommand>GetMedInstr Channel</fullCommand>
    <parameters>Channel</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetMedMask">
    <keyword>SetMedMask</keyword>
    <fullCommand>SetMedMask Channel Mask</fullCommand>
    <parameters>Channel Mask</parameters>
    <shortDescription />
    <longDescription>SetMedMask allows the user to mask out audio channels needed by sound effects
stopping the Med Library using them.</longDescription>
  </command>
  <command name="DecodeMedModule">
    <keyword>DecodeMedModule</keyword>
    <fullCommand>DecodeMedModule MedModule#,MemoryLocation</fullCommand>
    <parameters>MedModule#,MemoryLocation</parameters>
    <shortDescription />
    <longDescription>DecodeMedModule replaces the cludgemedmodule, as med modules are not packed but used
raw, DecodeMedModule simply checks to see the memory location passed is in ChipMem
(if not it copies the data to chip) and points the Blitz MedModule object to that
memory.</longDescription>
  </command>
  <command name="LoadPalette">
    <keyword>LoadPalette</keyword>
    <fullCommand>LoadPalette Palette#,Filename$[,Palette Offset]</fullCommand>
    <parameters>Palette#,Filename$[,Palette Offset]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Cycle">
    <keyword>Cycle</keyword>
    <fullCommand>Cycle Palette#</fullCommand>
    <parameters>Palette#</parameters>
    <shortDescription />
    <longDescription>Cycle will cause the colour cycling information contained in the specified palette
to be cycled on the currently used Screen. Colour cycling information is created
when LoadPalette is executed or with the SetCycle command.</longDescription>
  </command>
  <command name="RGB">
    <keyword>RGB</keyword>
    <fullCommand>RGB Colour Register,Red,Green,Blue</fullCommand>
    <parameters>Colour Register,Red,Green,Blue</parameters>
    <shortDescription />
    <longDescription>RGB enables you to set individual colour registers in a palette to an RGB colour
value.

If executed in Amiga mode, RGB sets colour registers in the currently used screen.
If executed in Blitz Mode, RGB sets colour registers in the currently used slice.

Note that RGB does not alter palette objects in any.</longDescription>
  </command>
  <command name="Red">
    <keyword>Red</keyword>
    <fullCommand>Red(Colour Register)</fullCommand>
    <parameters>(Colour Register)</parameters>
    <shortDescription />
    <longDescription>Red returns the amount of RGB red in a specified colour register.

If executed in Amiga mode, Red returns the amount of red in the specified colour
register of the currently used screen.

If executed in Blitz mode, Red returns the amount of red in the specified colour
register of the currently used slice.

Red will always return a value in the range zero to fifteen.</longDescription>
  </command>
  <command name="Green">
    <keyword>Green</keyword>
    <fullCommand>Green(Colour Register)</fullCommand>
    <parameters>(Colour Register)</parameters>
    <shortDescription />
    <longDescription>Green returns the amount of RGB green in a specified colour register.

If executed in Amiga mode, Green returns the amount of green in the specified colour
register of the currently used screen.

If executed in Blitz mode, Green returns the amount of green in the specified colour
register of the currently used slice.

Green will always return a value in the range zero to fifteen.</longDescription>
  </command>
  <command name="Blue">
    <keyword>Blue</keyword>
    <fullCommand>Blue(Colour Register)</fullCommand>
    <parameters>(Colour Register)</parameters>
    <shortDescription />
    <longDescription>Blue returns the amount of RGB blue in a specified colour register.

If executed in Amiga mode, Blue returns the amount of blue in the specified colour
register of the currently used screen.

If executed in Blitz mode, Blue returns the amount of blue in the specified colour
register of the currently used slice.

Blue will always return a value in the range zero to fifteen.</longDescription>
  </command>
  <command name="PalRGB">
    <keyword>PalRGB</keyword>
    <fullCommand>PalRGB Palette#,Colour Register,Red,Green,Blue</fullCommand>
    <parameters>Palette#,Colour Register,Red,Green,Blue</parameters>
    <shortDescription />
    <longDescription>PalRGB allows you to set an individual colour register within a palette object.
Unless an RGB has also been executed, the actual colour change will not come into
effect until the next time ShowPalette is executed.</longDescription>
  </command>
  <command name="SetCycle">
    <keyword>SetCycle</keyword>
    <fullCommand>SetCycle Palette#,Cycle,Low Colour,High Colour[,Speed]</fullCommand>
    <parameters>Palette#,Cycle,Low Colour,High Colour[,Speed]</parameters>
    <shortDescription />
    <longDescription>SetCycle is used to configure colour cycling information for the Cycle command. The
low and high colours specify the range of colours that will cycle. You may have a
maximum of 7 different cycles for a single palette. The optional parameter Speed
specifies how quickly the colours will cycle, a negative value will cycle the
colours backwards.</longDescription>
  </command>
  <command name="StopCycle">
    <keyword>StopCycle</keyword>
    <fullCommand>StopCycle</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>StopCycle will halt all colour cycling started with the Cycle command.</longDescription>
  </command>
  <command name="AGARGB">
    <keyword>AGARGB</keyword>
    <fullCommand>AGARGB Colour Register,Red,Green,Blue</fullCommand>
    <parameters>Colour Register,Red,Green,Blue</parameters>
    <shortDescription />
    <longDescription>The AGARGB command is the AGA equivalent of the RGB command. The 'Red', 'Green' and
'Blue' parameters must be in the range 0 through 255, while 'Colour Register' is
limited to the number of colours available on the currently used screen.</longDescription>
  </command>
  <command name="AGAPalRGB">
    <keyword>AGAPalRGB</keyword>
    <fullCommand>AGAPalRGB Palette#,Colour Register,Red,Green,Blue</fullCommand>
    <parameters>Palette#,Colour Register,Red,Green,Blue</parameters>
    <shortDescription />
    <longDescription>The AGAPalRGB command is the AGA equivalent of the PalRGB command. AGAPalRGB allows
you to set an individual colour register within a palette object. This command only
sets up an entry in a palette object, and will not alter the actual screen palette
until a 'ShowPalette' is executed.</longDescription>
  </command>
  <command name="AGARed">
    <keyword>AGARed</keyword>
    <fullCommand>AGARed(Colour Register)</fullCommand>
    <parameters>(Colour Register)</parameters>
    <shortDescription />
    <longDescription>The AGARed function returns the red component of the specified colour register
within the currently used screen. The returned value will be within the range 0
(being no red) through 255 (being full red).</longDescription>
  </command>
  <command name="AGAGreen">
    <keyword>AGAGreen</keyword>
    <fullCommand>AGAGreen(Colour Register)</fullCommand>
    <parameters>(Colour Register)</parameters>
    <shortDescription />
    <longDescription>The AGAGreen function returns the green component of the specified colour register
within the currently used screen. The returned value will be within the range 0
(being no green) through 255 (being full green).</longDescription>
  </command>
  <command name="AGABlue">
    <keyword>AGABlue</keyword>
    <fullCommand>AGABlue(Colour Register)</fullCommand>
    <parameters>(Colour Register)</parameters>
    <shortDescription />
    <longDescription>The AGABlue function returns the blue component of the specified colour register
within the currently used screen. The returned value will be within the range 0
(being no blue) through 255 (being full blue).</longDescription>
  </command>
  <command name="ShowPalette">
    <keyword>ShowPalette</keyword>
    <fullCommand>ShowPalette Palette#</fullCommand>
    <parameters>Palette#</parameters>
    <shortDescription />
    <longDescription>ShowPalette replaces Use Palette for copying a palette's colours to the current
Screen or Slice.</longDescription>
  </command>
  <command name="NewPaletteMode">
    <keyword>NewPaletteMode</keyword>
    <fullCommand>NewPaletteMode On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription>The NewPaletteMode flag has been added for compatibility with older Blitz programs.
By setting NewPaletteMode to On the Use Palette command merely makes the specified
palette the current object and does not try to copy the colour information to the
current Screen or Slice.</longDescription>
  </command>
  <command name="CyclePalette">
    <keyword>CyclePalette</keyword>
    <fullCommand>CyclePalette Palette#</fullCommand>
    <parameters>Palette#</parameters>
    <shortDescription />
    <longDescription>CyclePalette uses the standard color cycling parameters in the palette object to
cycle the colors. Unlike the Cycle command which copied the resulting palette to the
current screen the CyclePalette command just modifies the palette object and can
hence be used with the DisplayBitmap command in the new Display library.</longDescription>
  </command>
  <command name="FadePalette">
    <keyword>FadePalette</keyword>
    <fullCommand>FadePalette SrcPalette#,DestPalette#,Brightness.q</fullCommand>
    <parameters>SrcPalette#,DestPalette#,Brightness.q</parameters>
    <shortDescription />
    <longDescription>FadePalette multiplies all colours in a Palette by the Brightness argument and maces
the result in the DestPalette.</longDescription>
  </command>
  <command name="InitPalette">
    <keyword>InitPalette</keyword>
    <fullCommand>InitPalette Palette#,NumColors</fullCommand>
    <parameters>Palette#,NumColors</parameters>
    <shortDescription />
    <longDescription>InitPalette simply initialises a palette object to hold NumColors. All colors will
be set to black.</longDescription>
  </command>
  <command name="PaletteRange">
    <keyword>PaletteRange</keyword>
    <fullCommand>PaletteRange Palette#,StartCol,EndCol,r0,g0,b0,r1,g1,b1</fullCommand>
    <parameters>Palette#,StartCol,EndCol,r0,g0,b0,r1,g1,b1</parameters>
    <shortDescription />
    <longDescription>PaletteRange creates a spread of colors within a palette. Similar to DPaint's spread
function PaletteRange takes a start and end colour and creates the color tweens
between them.</longDescription>
  </command>
  <command name="DuplicatePalette">
    <keyword>DuplicatePalette</keyword>
    <fullCommand>DuplicatePalette SrcPalette#,DestPalette#</fullCommand>
    <parameters>SrcPalette#,DestPalette#</parameters>
    <shortDescription />
    <longDescription>DuplicatePalette simply creates a new Palette which exactly matches the SrcPalette.</longDescription>
  </command>
  <command name="DecodePalette">
    <keyword>DecodePalette</keyword>
    <fullCommand>DecodePalette Palette#,MemoryLocation[,Palette Offset]</fullCommand>
    <parameters>Palette#,MemoryLocation[,Palette Offset]</parameters>
    <shortDescription />
    <longDescription>DecodePalette allows the programmer to unpack included iff palette information to
Blitz palette objects.</longDescription>
  </command>
  <command name="MixPalette">
    <keyword>MixPalette</keyword>
    <fullCommand>MixPalette Palette#,Palette#,DestPalette#,fraction</fullCommand>
    <parameters>Palette#,Palette#,DestPalette#,fraction</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Scroll">
    <keyword>Scroll</keyword>
    <fullCommand>Scroll X1,Y1,Width,Height,X2,Y2[,BitMap#]</fullCommand>
    <parameters>X1,Y1,Width,Height,X2,Y2[,BitMap#]</parameters>
    <shortDescription />
    <longDescription>Scroll allows rectangular areas within a bitmap to be moved around. X1, Y1, Width
and Height specify the position and size of the rectangle to be moved. X2 and Y2
specify the position the rectangle is to be moved to.

An optional Source BitMap parameter allows you to move rectangular areas from one
bitmap to another.</longDescription>
  </command>
  <command name="Plot">
    <keyword>Plot</keyword>
    <fullCommand>Plot X,Y,Colour</fullCommand>
    <parameters>X,Y,Colour</parameters>
    <shortDescription />
    <longDescription>Plot is used to alter the colour of an individual pixel on the currently used
bitmap. X and Y specify the location of the pixel to be altered, and Colour
specifies the colour to change the pixel to. A Colour parameter of -1 will cause the
pixel at the specified pixel position to be 'inverted'.</longDescription>
  </command>
  <command name="Point">
    <keyword>Point</keyword>
    <fullCommand>Point X,Y,Colour</fullCommand>
    <parameters>X,Y,Colour</parameters>
    <shortDescription />
    <longDescription>The Point function will return the colour of a particular pixel in the currently
used bitmap. The pixel to be examined is specified by the X and Y parameters If X
and Y specify a point outside the edges of the bitmap, a value of -1 will be
returned.</longDescription>
  </command>
  <command name="Cls">
    <keyword>Cls</keyword>
    <fullCommand>Cls [Colour]</fullCommand>
    <parameters>[Colour]</parameters>
    <shortDescription />
    <longDescription>Cls allows you to fill the currently used bitmap with the colour specified by the
Colour parameter. If Colour is omitted, the currently used bitmap will be filled
with colour 0. A Colour parameter of -1 will cause the entire bitmap to be
'inverted'.</longDescription>
  </command>
  <command name="BlockScroll">
    <keyword>BlockScroll</keyword>
    <fullCommand>BlockScroll X1,Y1,Width,Height,X2,Y2[,BitMap#]</fullCommand>
    <parameters>X1,Y1,Width,Height,X2,Y2[,BitMap#]</parameters>
    <shortDescription />
    <longDescription>Same as the Scroll command except that BlockScroll is much faster but only works
with 16 bit aligned areas. This means that X1, X2 and Width must all be multiples of
16. Useful for block scrolling routines that render the same blocks to both sides of
the display, the programmer can now choose to render just one set and then copy the
result to the other side with the BlockScroll command.</longDescription>
  </command>
  <command name="Poke">
    <keyword>Poke</keyword>
    <fullCommand>Poke [.Type] Address,Data</fullCommand>
    <parameters>[.Type] Address,Data</parameters>
    <shortDescription />
    <longDescription>The Poke command will place the specified Data into the absolute memory location
specified by Address. The size of the Poke may be specified by the optional Type
parameter. For example, to poke a byte into memory, you would use Poke.b; to poke a
word into memory you would use Poke.w; and to poke a long word into memory you would
use Poke.l

In addition, strings may be poked into memory by use of Poke$. This will cause the
ascii code of all characters in the string specified by Data to be poked, byte by
byte, into consecutive memory locations. An extra 0 is also poked past the end of
the string.</longDescription>
  </command>
  <command name="Peek">
    <keyword>Peek</keyword>
    <fullCommand>Peek [.Type](Address)</fullCommand>
    <parameters>[.Type](Address)</parameters>
    <shortDescription />
    <longDescription>The Peek function returns the contents of the absolute memory location specified by
Address. The optional Type parameter allows peeking of different sizes. For example,
to peek a byte, you would use Peek.b; to peek a word, you would use Peek.w; and to
peek a long, you would use Peek.l

It is also possible to peek a string using Peek$. This will return a string of
characters read trom consecutive memory locations until a byte of 0 is found.</longDescription>
  </command>
  <command name="Peeks$">
    <keyword>Peeks$</keyword>
    <fullCommand>Peeks$(Address,Length)</fullCommand>
    <parameters>(Address,Length)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Call">
    <keyword>Call</keyword>
    <fullCommand>Call Address</fullCommand>
    <parameters>Address</parameters>
    <shortDescription />
    <longDescription>Call will cause program flow to be transferred to the absolute memory location
specified by Address.

PLEASE NOTE! Call is for advanced programmers only, as incorrect use of Call can
lead to severe problems - GURUS etc!

A 68000 JSR instruction is used to transfer program flow, so an RTS may be used to
transfer back to the Blitz program.

Please refer to the 'Assembler' section of the manual for the rules machine code
programs must follow to operate correctly within the Blitz environment. Page 127.</longDescription>
  </command>
  <command name="MenuTitle">
    <keyword>MenuTitle</keyword>
    <fullCommand>MenuTitle MenuList#,Menu,Title$</fullCommand>
    <parameters>MenuList#,Menu,Title$</parameters>
    <shortDescription />
    <longDescription>MenuTitle is used to add a menu title to a menulist. Menu titles appear when the
right mouse button is held down, and usually have menuitems attached to them.

Menu specifies which menu the title should be used for. Higher numbered menus appear
further to the right along the menu bar, with 0 being the leftmost menu.

Menutitles should be added in left to right order, with menu 0 being the first
created, then 1 and so on...

Title$ is the actual text you want to appear when the right mouse button is pressed.</longDescription>
  </command>
  <command name="SetMenu">
    <keyword>SetMenu</keyword>
    <fullCommand>SetMenu Menulist#</fullCommand>
    <parameters>Menulist#</parameters>
    <shortDescription />
    <longDescription>SetMenu is used to attach a menulist to the currently used window. Each window may
have only one menulist attached to it.</longDescription>
  </command>
  <command name="MenuItem">
    <keyword>MenuItem</keyword>
    <fullCommand>MenuItem MenuList#,Flags,Menu,Item,Itemtext$[,Shortcut$]</fullCommand>
    <parameters>MenuList#,Flags,Menu,Item,Itemtext$[,Shortcut$]</parameters>
    <shortDescription />
    <longDescription>Menultem is used to create a text menu item. Menu items appear vertically below menu
titles when the mouse is moved over a menu title with the right mouse button held
down.

Flags affects the operation of the menu item. A value of 0 creates a stand 'select'
menu item.

A value of 1 creates a 'toggle' menu item. Toggle menu items are used for 'on/off'
type options. When a toggle menu item is selected, it will change state between on
and off. An 'on' toggle item is identified by a 'tick' or check mark.

A value of 2 creates a special type of toggle menu item. Any menu items which appear
under the same menu with a Flags setting of 2 are said to be mutually exclusive.
This means that only 1 of them may begin the 'on' state at one time. If a menu item
of this nature is toggled into the 'on' state, any other mutually exclusive menu
items which may have previously been 'on' will be automatically turned 'off'.

Flags values of 3 and 4 correspond to values 1 and 2, only the item will initially
appear in the 'on' state.

Menu specifies the menu title under which the menu item should appear.

Item specifies the menu item number this menu item should be referenced as. Higher
numbered items appear further down a menu item list, with 0 being the topmost item.
Menu items should be added in 'top down' order, with menu item 0 being the first
item created.

Itemtext$ is the actual text for the menu item.

An optional Shortcut$ string allows you to select a one character 'keyboard
shortcut' for the menu item.</longDescription>
  </command>
  <command name="SubItem">
    <keyword>SubItem</keyword>
    <fullCommand>SubItem MenuList#,Flags,Menu,Item,Subitem,Subitemtext$[,Shortcut$]</fullCommand>
    <parameters>MenuList#,Flags,Menu,Item,Subitem,Subitemtext$[,Shortcut$]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ShapeItem">
    <keyword>ShapeItem</keyword>
    <fullCommand>ShapeItem MenuList#,Flags,Menu,Item,Shape#</fullCommand>
    <parameters>MenuList#,Flags,Menu,Item,Shape#</parameters>
    <shortDescription />
    <longDescription>ShapeItem is used to create a graphical menu item.

Shape# refers to a previously initialized shape object to be used as the menu item's
graphics. All other parameters are identical to those for MenuItem.</longDescription>
  </command>
  <command name="ShapeSub">
    <keyword>ShapeSub</keyword>
    <fullCommand>ShapeSub MenuList#,Flags,Menu,Item,Subitem,Shape#</fullCommand>
    <parameters>MenuList#,Flags,Menu,Item,Subitem,Shape#</parameters>
    <shortDescription />
    <longDescription>ShapeSub allows you to create a graphic sub menu item. Shape# specifies a previously
created shape object to be used as the sub item's graphics.

All other parameters are identical to those in SubItem.</longDescription>
  </command>
  <command name="MenuGap">
    <keyword>MenuGap</keyword>
    <fullCommand>MenuGap X Gap,Y Gap</fullCommand>
    <parameters>X Gap,Y Gap</parameters>
    <shortDescription />
    <longDescription>Executing MenuGap before creating any menu titles, items or sub items, allows you to
control the layout of the menu.

X Gap refers to an amount, specified in pixles, to be inserted to the left and right
of all menu items and sub menu items.

Y Gap refers to an amount, again in pixels, to be inserted above and below all menu
items and sub menu items.</longDescription>
  </command>
  <command name="SubItemOff">
    <keyword>SubItemOff</keyword>
    <fullCommand>SubItemOff X Offset,Y Offset</fullCommand>
    <parameters>X Offset,Y Offset</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MenuState">
    <keyword>MenuState</keyword>
    <fullCommand>MenuState MenuList#[,Menu[,Item[,Subitem]]],On|Off</fullCommand>
    <parameters>MenuList#[,Menu[,Item[,Subitem]]],On|Off</parameters>
    <shortDescription />
    <longDescription>The MenuState command allows you to turn menus, or sections of menus, on or off.

MenuState with just the MenuList# parameter may be used to turn an entire menu list
on or off.

MenuState with MenuList# and Menu parameters may be used to turn a menu on or off.

Similarly, menu items and sub items may be turned on or off by specifying the
appropriate parameters.</longDescription>
  </command>
  <command name="MenuColour">
    <keyword>MenuColour</keyword>
    <fullCommand>MenuColour Colour</fullCommand>
    <parameters>Colour</parameters>
    <shortDescription />
    <longDescription>MenuColour allows you to determine what colour any menu item or sub item text is
rendered in. MenuColour should be executed before the approprate menu item commands.</longDescription>
  </command>
  <command name="MenuChecked">
    <keyword>MenuChecked</keyword>
    <fullCommand>MenuChecked(MenuList#,Menu,Item[,Subitem])</fullCommand>
    <parameters>(MenuList#,Menu,Item[,Subitem])</parameters>
    <shortDescription />
    <longDescription>The MenuChecked function allows you to tell whether or not a 'toggle' type menu item
or menu sub item is currently 'checked' or ton'.

If the specified menu item or sub item is in fact checked, MenuChecked will return
'true' (-1). If not, MenuChecked will return 'false' (0).</longDescription>
  </command>
  <command name="Mouse">
    <keyword>Mouse</keyword>
    <fullCommand>Mouse On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription>The Mouse command turns on or off Blitz mode's ability to read the mouse. Once a
Mouse On has been executed, programs can read the mouse's position or speed in Blitz
mode.</longDescription>
  </command>
  <command name="Pointer">
    <keyword>Pointer</keyword>
    <fullCommand>Pointer Sprite#,Sprite Channel</fullCommand>
    <parameters>Sprite#,Sprite Channel</parameters>
    <shortDescription />
    <longDescription>The Pointer command allows you to attach a sprite object to the mouse's position in
the currently used slice in Blitz mode.

To properly attach a sprite to the mouse position, several commands must be executed
in the correct sequence. First, a sprite must be created using the LoadShape and
GetaSprite sequence of commands. Then, a slice must be created to display the sprite
in.

A Mouse On must then be executed to enable mouse reading.</longDescription>
  </command>
  <command name="MouseArea">
    <keyword>MouseArea</keyword>
    <fullCommand>MouseArea Minx,Miny,Maxx,Maxy</fullCommand>
    <parameters>Minx,Miny,Maxx,Maxy</parameters>
    <shortDescription />
    <longDescription>MouseArea allows you to limit Blitz mode mouse movement to a rectangular section of
the display. Minx and Miny define the top left corner of the area, Maxx and Maxy
define the lower right corner.

MouseArea defaults to an area from 0,0 to 320,200.</longDescription>
  </command>
  <command name="MouseX">
    <keyword>MouseX</keyword>
    <fullCommand>MouseX</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>If Blitz mode mouse reading has been enabled using a Mouse On command, the MouseX
function may be used to find the current horizontal location of the mouse. If mouse
reading is enabled, the mouse position will be updated every fiftieth of a second,
regardless of whether or not a mouse pointer sprite is attached.</longDescription>
  </command>
  <command name="MouseY">
    <keyword>MouseY</keyword>
    <fullCommand>MouseY</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>If Blitz mode mouse reading has been enabled using a Mouse On command, the MouseY
function may be used to find the current vertical location of the mouse. If mouse
reading is enabled, the mouse position will be updated every fiftieth of a second,
regardless of whether or not a mouse pointer sprite is attached.</longDescription>
  </command>
  <command name="MouseXSpeed">
    <keyword>MouseXSpeed</keyword>
    <fullCommand>MouseXSpeed</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>If Blitz mode mouse reading has been enabled using a Mouse On command, the
MouseXSpeed function may be used to find the current horizontal speed of mouse
movement, regardless of whether or not a sprite is attached to the mouse.

If MouseXSpeed returns a negative value, then the mouse has been moved to the left.
If a positive value is returned, the mouse has been moved to the right.

MouseXSpeed only has relevance after every vertical blank. Therefore, MouseXSpeed
should only be used after a VWait has been executed, or during a vertical blank
interupt.</longDescription>
  </command>
  <command name="MouseYSpeed">
    <keyword>MouseYSpeed</keyword>
    <fullCommand>MouseYSpeed</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>If Blitz mode mouse reading has been enabled using a Mouse On command, the
MouseYSpeed function may be used to find the current vertical speed of mouse
movement, regardless of whether or not a sprite is attached to the mouse.

If MouseYSpeed returns a negative value, then the mouse has been moved upwards. If a
positive value is returned, the mouse has been moved downwards.

MouseYSpeed only has relevance after every vertical blank. Therefore, MouseYSpeed
should only be used after a VWait has been executed, or during a vertical blank
interupt.</longDescription>
  </command>
  <command name="PositionMouse">
    <keyword>PositionMouse</keyword>
    <fullCommand>PositionMouse x,y</fullCommand>
    <parameters>x,y</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChunkyCLS">
    <keyword>ChunkyCLS</keyword>
    <fullCommand>ChunkyCLS color</fullCommand>
    <parameters>color</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChunkyPlot">
    <keyword>ChunkyPlot</keyword>
    <fullCommand>ChunkyPlot x,y,color,[,CLIP]</fullCommand>
    <parameters>x,y,color,[,CLIP]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChunkyVlin">
    <keyword>ChunkyVlin</keyword>
    <fullCommand>ChunkyVlin x,y1,y2,color,[,CLIP]</fullCommand>
    <parameters>x,y1,y2,color,[,CLIP]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChunkyPoly">
    <keyword>ChunkyPoly</keyword>
    <fullCommand>ChunkyPoly numpts,*coords.w,color[,noblitter]</fullCommand>
    <parameters>numpts,*coords.w,color[,noblitter]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BitMapPoly">
    <keyword>BitMapPoly</keyword>
    <fullCommand>BitMapPoly numpts,*coords.w,color[,ditherbitmap]</fullCommand>
    <parameters>numpts,*coords.w,color[,ditherbitmap]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RenderToBitmap">
    <keyword>RenderToBitmap</keyword>
    <fullCommand>RenderToBitmap BitMap#[,DitherBitMap#]</fullCommand>
    <parameters>BitMap#[,DitherBitMap#]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RenderToChunky">
    <keyword>RenderToChunky</keyword>
    <fullCommand>RenderToChunky CopList#[,split]</fullCommand>
    <parameters>CopList#[,split]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RenderPoly">
    <keyword>RenderPoly</keyword>
    <fullCommand>RenderPoly numpts,*coords.w,color</fullCommand>
    <parameters>numpts,*coords.w,color</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Print">
    <keyword>Print</keyword>
    <fullCommand>Print Expression[,Expression...]</fullCommand>
    <parameters>Expression[,Expression...]</parameters>
    <shortDescription />
    <longDescription>Print allows you to output either strings or numeric values to the current output
channel. Commands such as WindowOutput or BitMapOutput may be used to alter the
current output channel.</longDescription>
  </command>
  <command name="NPrint">
    <keyword>NPrint</keyword>
    <fullCommand>NPrint Expression[,Expression...]</fullCommand>
    <parameters>Expression[,Expression...]</parameters>
    <shortDescription />
    <longDescription>NPrint allows you to output either strings or numeric values to the current output
channel. Commands such as WindowOutput or BitMapOutput may be used to alter the
current output channel.

After all Expressions have been output, NPrint automatically prints a newline
character.</longDescription>
  </command>
  <command name="Str$">
    <keyword>Str$</keyword>
    <fullCommand>Str$(Expression)</fullCommand>
    <parameters>(Expression)</parameters>
    <shortDescription />
    <longDescription>This returns a string equivalent of the numeric value Expression. This now allows
you to perform string operations on this string.

If the Format command has been used to alter numeric output, this will be applied to
the resultant string.</longDescription>
  </command>
  <command name="Format">
    <keyword>Format</keyword>
    <fullCommand>Format FormatString</fullCommand>
    <parameters>FormatString</parameters>
    <shortDescription />
    <longDescription>Format allows you to control the output of any numeric values by the Print or NPrint
commands. FormatString is an 80 character or less string expression used for
formatting information by the Print command. Special characters in FormatString are
used to perform special formatting functions. These special characters are:

Char    Format effect 

#       If no digit to print, insert spaces into output
0       If no digit to print, insert zeros ('0') into output
.       Insert decimal point into output
+       Insert sign of value
-       Insert sign of value, only if negative
,       Insert commas every 3 digits to left of number

Any other characters in FormatString will appear at appropriate positions in the
output. Format also affects the operation of the Str$ function.</longDescription>
  </command>
  <command name="FloatMode">
    <keyword>FloatMode</keyword>
    <fullCommand>FloatMode Mode : -1=standard, 0=guess, 1=exp</fullCommand>
    <parameters>Mode : -1=standard, 0=guess, 1=exp</parameters>
    <shortDescription />
    <longDescription>FloatMode allows you to control how floating point numbers are output by the Print
or NPrint commands.

Floating point numbers may he displayed in one of two ways - in exponential format,
or in standard format. Exponential format displays a floating point number as a
value multiplied by ten raised to a power. For example, 10240 expressed
exponentially is displayed as '1.024E+4', ie: 1.024 times 10 to the power of 4.
Standard format simply prints values 'as is'.

A Mode parameter of 1 will cause floating point values to ALWAYS be displayed in
exponential format. A Mode parameter of -1 will cause floating point values to
ALWAYS be displayed in standard format. A Mode parameter of 0 will cause Blitz to
take a 'best guess' at the most appropriate format to use. This is the default mode
for floating point output.

Note that if Format has been used to alter numeric output, standard mode will always
be used to print floating point numbers.</longDescription>
  </command>
  <command name="UStr$">
    <keyword>UStr$</keyword>
    <fullCommand>UStr$(Expression)</fullCommand>
    <parameters>(Expression)</parameters>
    <shortDescription />
    <longDescription>This returns a string equivalent of the numeric value Expression. This now allows
you to perform string operations on this string.

Unlike Str$, UStr$ is not affected by any active Format commands.</longDescription>
  </command>
  <command name="Queue">
    <keyword>Queue</keyword>
    <fullCommand>Queue Queue#,Max Items</fullCommand>
    <parameters>Queue#,Max Items</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="QBlit">
    <keyword>QBlit</keyword>
    <fullCommand>QBlit Queue#,Shape#,X,Y[,Excessonoff]</fullCommand>
    <parameters>Queue#,Shape#,X,Y[,Excessonoff]</parameters>
    <shortDescription />
    <longDescription>QBlit performs similarly to Blit, and is also used to draw a shape onto the
currently used bitmap. Where QBlit differs, however, is in that it also remembers
(using a queue) where the shape was drawn, and how big it was. This allows a later
UnQueue command to erase the drawn shape.

Please refer to the Queue command for an explanation of the use of queues.

The optional Excessonoff parameter works identically to the Excessonoff parameter
used by the Blit command. Please refer to the Blit command for more information on
this parameter.</longDescription>
  </command>
  <command name="UnQueue">
    <keyword>UnQueue</keyword>
    <fullCommand>UnQueue Queue#[,BitMap#]</fullCommand>
    <parameters>Queue#[,BitMap#]</parameters>
    <shortDescription />
    <longDescription>UnQueue is used to erase all 'remembered' items in a queue. Items are placed in a
queue by use of the QBlit command. Please refer to Queue for a full explanation of
queues and their usage.

An optional BitMap# parameter may be supplied to cause items to be erased by way of
'replacement' from another bitmap, as opposed to the normal 'zeroing out' erasing.</longDescription>
  </command>
  <command name="QBlitMode">
    <keyword>QBlitMode</keyword>
    <fullCommand>QBlitMode BLTCON0</fullCommand>
    <parameters>BLTCON0</parameters>
    <shortDescription />
    <longDescription>QBlitMode allows you to control how the blister operates when QBlitting shapes to
bitmaps. Please refer to BlitMode for more information on this command.</longDescription>
  </command>
  <command name="FlushQueue">
    <keyword>FlushQueue</keyword>
    <fullCommand>FlushQueue Queue#</fullCommand>
    <parameters>Queue#</parameters>
    <shortDescription />
    <longDescription>FlushQueue will force the specified queue object to be 'emptied', causing the next
UnQueue command to have no effect.</longDescription>
  </command>
  <command name="Screen">
    <keyword>Screen</keyword>
    <fullCommand>Screen [Screen#,Mode[,Title$]]|[Screen#,X,Y,W,H,D,Viewmode,Title$,Dpen,Bpen[,BitMap#]</fullCommand>
    <parameters>[Screen#,Mode[,Title$]]|[Screen#,X,Y,W,H,D,Viewmode,Title$,Dpen,Bpen[,BitMap#]</parameters>
    <shortDescription />
    <longDescription>Screen#,X,Y,Width,Height,Depth,VMode,Title$,Dpen,Bpen[,BMap#]

Screen will open an Intuition screen. The are 2 formats of the screen command, a
quick format, and a long format.

The quick format of the Screen commands involves 3 parameters - Screen#, Mode and an
optional Title$.

Screen# specifies the screen object to create.

Mode specifies how many bitplanes the screen is to have, and should be in the range
1 through 6. Adding 8 to Mode will cause a hi-res screen to be opened, as opposed to
the default lo-res screen. A hi-res screen may only have from 1 to 4 bitplanes.
Adding 16 to Mode will cause an interlaced screen to be opened.

Title$ allows you to add a title to the screen.


The long format of Screen gives you much more control over how the screen is opened.

The VMode parameter refers to the resolution of the Screen, add the values together
to make up the screenmode you require:

hires=$8000
ham=$200
superhires=$20
interlace=4
lores=0.</longDescription>
  </command>
  <command name="WbToScreen">
    <keyword>WbToScreen</keyword>
    <fullCommand>WbToScreen Screen#</fullCommand>
    <parameters>Screen#</parameters>
    <shortDescription />
    <longDescription>WbToScreen will assign the Workbench screen a screen object number. This allows you
to perform any of the functions that you would normally do own your own screens, on
the Workbench screen. It's main usage is to allow you to open windows on the
Workbench screen.

After execution, the Workbench screen will become the currently used screen.</longDescription>
  </command>
  <command name="LoadScreen">
    <keyword>LoadScreen</keyword>
    <fullCommand>LoadScreen Screen#,Filename$[,Palette#]</fullCommand>
    <parameters>Screen#,Filename$[,Palette#]</parameters>
    <shortDescription />
    <longDescription>LoadScreen loads an IFF ILBM picture into the screen object specified by Screen#.
The file that is loaded is specified by Filename$.

You can also choose to load in the colour palette for the screen, by specifying the
optional Palette#. This value is the object number of the palette you want the
pictures colours to be loaded into. For the colours to be used on your screen, you
will have to use the statement.</longDescription>
  </command>
  <command name="FindScreen">
    <keyword>FindScreen</keyword>
    <fullCommand>FindScreen Screen#[,Title$]</fullCommand>
    <parameters>Screen#[,Title$]</parameters>
    <shortDescription />
    <longDescription>This command will find a screen and give it an object number so it can be referenced
in your programs. If Title$ is not specified, then the foremost screen is found and
given the object number Screen#. If the Title$ argument is specified, then a screen
will be searched for that has this name.

After execution, the found screen will automatically become the currently used
screen.</longDescription>
  </command>
  <command name="SMouseX">
    <keyword>SMouseX</keyword>
    <fullCommand>SMouseX</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>SMouseX returns the horizontal position of the mouse relative to the left edge of
the currently used screen.</longDescription>
  </command>
  <command name="SMouseY">
    <keyword>SMouseY</keyword>
    <fullCommand>SMouseY</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>SMouseY returns the vertical position of the mouse relative to the top of the
current screen.</longDescription>
  </command>
  <command name="ShowScreen">
    <keyword>ShowScreen</keyword>
    <fullCommand>ShowScreen Screen#</fullCommand>
    <parameters>Screen#</parameters>
    <shortDescription />
    <longDescription>ShowScreen will cause the specified screen object to be moved to the front of the
display.</longDescription>
  </command>
  <command name="ScreenPens">
    <keyword>ScreenPens</keyword>
    <fullCommand>ScreenPens Text,Shine,Shadow,Fill,FillText,Background,HighLight</fullCommand>
    <parameters>Text,Shine,Shadow,Fill,FillText,Background,HighLight</parameters>
    <shortDescription />
    <longDescription>ScreenPens configures the 10 default pens used for system gadgets in WorkBench 2.0.
Any Screens opened after a ScreenPens statement will use the pens defined. This
command will have no affect when used with Workbench 1.3 or earlier.</longDescription>
  </command>
  <command name="ViewPort">
    <keyword>ViewPort</keyword>
    <fullCommand>ViewPort(Screen#)</fullCommand>
    <parameters>(Screen#)</parameters>
    <shortDescription />
    <longDescription>The ViewPort function returns the location of the specified screens ViewPort. The
ViewPort address can be used with graphics.library commands and the like.</longDescription>
  </command>
  <command name="ShowBitMap">
    <keyword>ShowBitMap</keyword>
    <fullCommand>ShowBitMap [BitMap#]</fullCommand>
    <parameters>[BitMap#]</parameters>
    <shortDescription />
    <longDescription>The ShowBitMap command is the Amiga-mode version of the Show command. It enables you
to change a Screens bitmap allowing double buffered (flicker free) animation to
happen on a standard Intuition Screen.

Unlike Blitz mode it is better to do ShowBitMap then VWait to sync up with the
Amiga's display, this will make sure the new bitmap is being displayed before
modifying the previous BitMap.</longDescription>
  </command>
  <command name="CloseScreen">
    <keyword>CloseScreen</keyword>
    <fullCommand>CloseScreen Screen#</fullCommand>
    <parameters>Screen#</parameters>
    <shortDescription />
    <longDescription>CloseScreen has been added for convenience. Same as Free Screen but a little more
intuitive (especially for those that have complained about such matters (yes we
care)).</longDescription>
  </command>
  <command name="HideScreen">
    <keyword>HideScreen</keyword>
    <fullCommand>HideScreen Screen#</fullCommand>
    <parameters>Screen#</parameters>
    <shortDescription />
    <longDescription>Move Screen to back of all Screens open in the system.</longDescription>
  </command>
  <command name="BeepScreen">
    <keyword>BeepScreen</keyword>
    <fullCommand>BeepScreen Screen#</fullCommand>
    <parameters>Screen#</parameters>
    <shortDescription />
    <longDescription>Flash specified screen.</longDescription>
  </command>
  <command name="MoveScreen">
    <keyword>MoveScreen</keyword>
    <fullCommand>MoveScreen Screen#,deltax,deltay</fullCommand>
    <parameters>Screen#,deltax,deltay</parameters>
    <shortDescription />
    <longDescription>Move specified screen by specified amount. Good for system friendly special effects.</longDescription>
  </command>
  <command name="ScreenTags">
    <keyword>ScreenTags</keyword>
    <fullCommand>ScreenTags Screen#,Title$ [&amp;TagList] or [[,Tag,Data]...]</fullCommand>
    <parameters>Screen#,Title$ [&amp;TagList] or [[,Tag,Data]...]</parameters>
    <shortDescription />
    <longDescription>Full access to all the Amiga's new display resoutions is now available in Amiga mode
by use of the Screen Tags command.

The following tags are of most interest to Blitz programmers.

#Left      =$80000021 #Top           =$80000022 #Width          =$80000023
#Height    =$80000024 #Depth         =$80000025 #DetailPen      =$80000026
#BlockPen  =$80000027 #Title         =$80000028 #Colors         =$80000029
#ErrorCode =$8000002A #Font          =$8000002B #SysFont        =$8000002C
#Type      =$8000002D #BitMap        =$8000002E #PubName        =$8000002F
#PubSig    =$80000030 #PubTask       =$80000031 #DisplayID      =$80000032
#DClip     =$80000033 #Overscan      =$80000034 #ShowTitle      =$80000036
#Behind    =$80000037 #Quiet         =$80000038 #AutoScroll     =$80000039
#Pens      =$8000003A #FullPalette   =$8000003B #ColorMapEntries=$8000003C
#Parent    =$8000003D #Draggable     =$8000003E #Exclusive      =$8000003F
#SharePens =$80000040 #BackFill      =$80000041 #Interleaved    =$80000042
#Colors32  =$80000043 #VideoControl  =$80000044 #FrontChild     =$80000045
#BackChild =$80000046 #LikeWorkbench =$80000047 #Reserved       =$80000048.</longDescription>
  </command>
  <command name="OpenSerial">
    <keyword>OpenSerial</keyword>
    <fullCommand>OpenSerial device$,unit#,baud,io_serflags</fullCommand>
    <parameters>device$,unit#,baud,io_serflags</parameters>
    <shortDescription />
    <longDescription>OpenSerial is used to configure a Serial Port for use. As with OpenFile, OpenSerial
is a function and returns zero if it fails. If it succeeds advanced users may note
the return result is the location of the IOExtSer structure.

The device$ should be "serial.device" or compatible device driver. The baud rate
should be in the range of 110-292,000. The io_serflags parameter can include the
following flags:

#serf_xdisabled  =128 ;disable xon/xoff
#serf eofmode    =64  ;enable eof checking
#serf_shared     =32  ;set if you don't need exclusive use of port
#serf rad_boogie =16  ;high speed mode
#serf_queuedbrk  =8   ;if set a break command waits for buffer empty
#serf_7wire      =4   ;if set use 7 wire RS232
#serf_parity_odd =2   ;select odd parity (even if not set)
#serf_parity_on  =1   ;enable parity checking.</longDescription>
  </command>
  <command name="WriteSerial">
    <keyword>WriteSerial</keyword>
    <fullCommand>WriteSerial unit#,byte</fullCommand>
    <parameters>unit#,byte</parameters>
    <shortDescription />
    <longDescription>WriteSerial sends one byte to the serial port. Unit# defines which serial port is
used. If you are sending characters use the Asc() function to convert the character
to a byte e.g. WriteSerial 0,asc("b").</longDescription>
  </command>
  <command name="WriteSerialString">
    <keyword>WriteSerialString</keyword>
    <fullCommand>WriteSerialString unit#,string[,Flags 1=DoIO 2=TrueString]</fullCommand>
    <parameters>unit#,string[,Flags 1=DoIO 2=TrueString]</parameters>
    <shortDescription />
    <longDescription>WriteSerialString is similar to WriteSerial but sends a complete string to the
serial port.</longDescription>
  </command>
  <command name="ReadSerial">
    <keyword>ReadSerial</keyword>
    <fullCommand>ReadSerial(unit#[,flags 1=wait on])  returns -1 if nothing waiting</fullCommand>
    <parameters>(unit#[,flags 1=wait on])  returns -1 if nothing waiting</parameters>
    <shortDescription />
    <longDescription>ReadSerial returns the next byte waiting in the serial port's read buffer. If the
buffer is empty it returns a -1.

It is best to use a word type (var.w=ReadSerial(0)) as a byte will not be able to
differentiate between -1 and 255.</longDescription>
  </command>
  <command name="ReadSerialString">
    <keyword>ReadSerialString</keyword>
    <fullCommand>ReadSerialString(unit#)  returns null if nothing waiting</fullCommand>
    <parameters>(unit#)  returns null if nothing waiting</parameters>
    <shortDescription />
    <longDescription>ReadSerialString puts the serial port's read buffer into a string, if the buffer is
empty the function will return a null string (length=0).</longDescription>
  </command>
  <command name="CloseSerial">
    <keyword>CloseSerial</keyword>
    <fullCommand>CloseSerial unit#</fullCommand>
    <parameters>unit#</parameters>
    <shortDescription />
    <longDescription>The CloseSerial command will close the port, enabling other programs to use it.

Note: Blitz will automatically close all ports that are opened when a program ends.</longDescription>
  </command>
  <command name="SetSerialBuffer">
    <keyword>SetSerialBuffer</keyword>
    <fullCommand>SetSerialBuffer unit#,bufferlength</fullCommand>
    <parameters>unit#,bufferlength</parameters>
    <shortDescription />
    <longDescription>SetSerialBuffer changes the size of the ports read buffer. This may be useful if
your program is not always handling serial port data or is receiving and processing
large chunks of data.

The smallest size for the internal serial port (unit#0) is 64 bytes. The
bufferlength variable is in bytes.</longDescription>
  </command>
  <command name="SetSerialLens">
    <keyword>SetSerialLens</keyword>
    <fullCommand>SetSerialLens unit#,readlen,writelen,stopbits</fullCommand>
    <parameters>unit#,readlen,writelen,stopbits</parameters>
    <shortDescription />
    <longDescription>SetSerialLens allows you to change the size of characters read and written by the
serial device.

Generally readlen=writelen and should be set to either 7 or 8, stopbits should be
set to 1 or 2. Default values are 8,8,1.</longDescription>
  </command>
  <command name="SetSerialParams">
    <keyword>SetSerialParams</keyword>
    <fullCommand>SetSerialParams unit#</fullCommand>
    <parameters>unit#</parameters>
    <shortDescription />
    <longDescription>For advanced users, SetSerialParams tells the serial port when parameters are
changed This would only be necesary if they were changed by poking offsets from
IOExtSer which is returned by the OpenSerial command.</longDescription>
  </command>
  <command name="SerialEvent">
    <keyword>SerialEvent</keyword>
    <fullCommand>SerialEvent(unit#)</fullCommand>
    <parameters>(unit#)</parameters>
    <shortDescription />
    <longDescription>SerialEvent is used when your program is handling events from more than I source,
Windows, ARexx etc. This command is currently not implemented.</longDescription>
  </command>
  <command name="ReadSerialMem">
    <keyword>ReadSerialMem</keyword>
    <fullCommand>ReadSerialMem unit#,Address,Length</fullCommand>
    <parameters>unit#,Address,Length</parameters>
    <shortDescription />
    <longDescription>ReadSerialMem will fill the given memory space with data from the given serial port.</longDescription>
  </command>
  <command name="WriteSerialMem">
    <keyword>WriteSerialMem</keyword>
    <fullCommand>WriteSerialMem unit#,Address,Length</fullCommand>
    <parameters>unit#,Address,Length</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LoadShape">
    <keyword>LoadShape</keyword>
    <fullCommand>LoadShape Shape#,Filename$[,Palette#]</fullCommand>
    <parameters>Shape#,Filename$[,Palette#]</parameters>
    <shortDescription />
    <longDescription>LoadShape allows you to load an ILBM IFF file into a shape object. The optional
Palette# parameter lets you also load the colour information contained in the file
into a palette object.

The LoadShape command has now been extended to support anim brushes, if the file is
an anim brush the shapes are loaded into consecutive shapes starting with the Shape#
provided.</longDescription>
  </command>
  <command name="MakeCookie">
    <keyword>MakeCookie</keyword>
    <fullCommand>MakeCookie Shape#</fullCommand>
    <parameters>Shape#</parameters>
    <shortDescription />
    <longDescription>MakeCookie allows you to create a'cookiecut' for an individual shape. Cookiecuts are
necessary for shapes which are to be used by the various blitting commands (for
example, QBlit), and are normally made automatically whenever a shape is created
(for example, using LoadShape).

However, use of the AutoCookie command may mean you end up with a shape which has no
cookiecut, but which you wish to blit at some stage. You can then use MakeCookie to
make a cookiecut for this shape.</longDescription>
  </command>
  <command name="ShapeWidth">
    <keyword>ShapeWidth</keyword>
    <fullCommand>ShapeWidth(Shape#)</fullCommand>
    <parameters>(Shape#)</parameters>
    <shortDescription />
    <longDescription>The ShapeWidth function returns the width, in pixels, of a previously created shape
object.</longDescription>
  </command>
  <command name="ShapeHeight">
    <keyword>ShapeHeight</keyword>
    <fullCommand>ShapeHeight(Shape#)</fullCommand>
    <parameters>(Shape#)</parameters>
    <shortDescription />
    <longDescription>The ShapeHeight function returns the height, in pixels, of a previously created
shape object.</longDescription>
  </command>
  <command name="Handle">
    <keyword>Handle</keyword>
    <fullCommand>Handle Shape#,X,Y</fullCommand>
    <parameters>Shape#,X,Y</parameters>
    <shortDescription />
    <longDescription>All shapes have an associated 'handle'. A shape's handle refers to an offset from
the upper left of the shape to be used when calculating a shapes position when it
gets blitted to a bitmap. This is also often referred to as a 'hot spot'.

The X parameter specifies the 'acrosswards' offset for a handle, the Y parameter
specifies a 'downwards' offset.

Let's have a look at an example of how a handle works. Assume you have set a shapes
X handle to 5, and it's Y handle to 10. Now let's say we blit the shape onto a
bitmap at pixel position 160,100. The handle will cause the upper left corner of the
shape to actually end up at 155,90, while the point within the shape at 5,10 will
end up at 160,100.

When a shape is created, it's handle is automatically set to 0,0 - it's upper left
corner.</longDescription>
  </command>
  <command name="AutoCookie">
    <keyword>AutoCookie</keyword>
    <fullCommand>AutoCookie On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription>When shapes objects are used by any of the blitting routines (for example, Blit),
they usually require the presence of what is known as a'cookiecut'. These cookiecuts
are used for internal purposes by the various blitting commands, and in no way
affect the appearance or properties of a shape. They do, however, consume some of
your valuable Chip memory.

When a shape is created (for example, by using LoadShape or GetaShape), a cookiecut
is automatically made for it. However, this feature may be turned off by executing
an AutoCookie Off.

This is a good idea if you are not going to be using shapes for blitting - for
example, shapes used for gadgets or menus.</longDescription>
  </command>
  <command name="CopyShape">
    <keyword>CopyShape</keyword>
    <fullCommand>CopyShape Shape#,Shape#</fullCommand>
    <parameters>Shape#,Shape#</parameters>
    <shortDescription />
    <longDescription>CopyShape will produce an exact copy of one shape object in another shape object.
The first Shape# specifies the source shape for the copy, the second specifies the
destination shape.

CopyShape is often used when you require two copies of a shape in order to
manipulate (using, for example, XFlip) one of them.</longDescription>
  </command>
  <command name="GetaShape">
    <keyword>GetaShape</keyword>
    <fullCommand>GetaShape Shape#,X,Y,Width,Height</fullCommand>
    <parameters>Shape#,X,Y,Width,Height</parameters>
    <shortDescription />
    <longDescription>GetaShape lets you transfer a rectangular area of the currently used bitmap into the
specified shape object. X, Y, Width and Height specify the area of the bitmap to be
picked up and used as a shape.</longDescription>
  </command>
  <command name="SaveShapes">
    <keyword>SaveShapes</keyword>
    <fullCommand>SaveShapes Shape#,Shape#,Filename$</fullCommand>
    <parameters>Shape#,Shape#,Filename$</parameters>
    <shortDescription />
    <longDescription>SaveShapes allows you to create a file containing a range of shape objects. This
file may be later loaded using the LoadShapes command.

The range of shapes to be saved is specified by Shape#,Shape#, where the first
Shape# refers to the lowest shape to be saved and the second Shape# the highest.</longDescription>
  </command>
  <command name="LoadShapes">
    <keyword>LoadShapes</keyword>
    <fullCommand>LoadShapes Shape#[,Shape#],Filename$</fullCommand>
    <parameters>Shape#[,Shape#],Filename$</parameters>
    <shortDescription />
    <longDescription>LoadShapes lets you load a 'range' of shapes from disk into a series of shape
objects. The file specified by Filename$ should have been created using the
SaveShapes command.

The first Shape# parameter specifies the number of the first shape object to be
loaded. Further shapes will be loaded into increasingly higher shape objects.

If a second Shape# parameter is supplied, then only shapes up to and including the
second Shape# value will be loaded. If there are not enough shapes in the file to
fill this range, any excess shapes will remain untouched.</longDescription>
  </command>
  <command name="MidHandle">
    <keyword>MidHandle</keyword>
    <fullCommand>MidHandle Shape#</fullCommand>
    <parameters>Shape#</parameters>
    <shortDescription />
    <longDescription>MidHandle will cause the handle of the specified shape to be set to it's centre. For
example, these two commands achieve exactly the same result:

MidHandle 0
Handle 0,ShapeWidth(0)/2,ShapeHeight(0)/2

For more information on handles, please refer to the Handle command.</longDescription>
  </command>
  <command name="DecodeShapes">
    <keyword>DecodeShapes</keyword>
    <fullCommand>DecodeShapes Shape#[,Shape#],MemoryLocation</fullCommand>
    <parameters>Shape#[,Shape#],MemoryLocation</parameters>
    <shortDescription />
    <longDescription>DecodeShapes, similar to DecodeMedModule ensures the data is in chip and then
configures the Shape object(s) to point to the data.</longDescription>
  </command>
  <command name="InitShape">
    <keyword>InitShape</keyword>
    <fullCommand>InitShape Shape#,Width,Height,Depth</fullCommand>
    <parameters>Shape#,Width,Height,Depth</parameters>
    <shortDescription />
    <longDescription>InitShape has been added to simple create blank shape objects. Programmers who make
a habit of using ShapesBitMap to render graphics to a shape object will appreciate
this one for sure.</longDescription>
  </command>
  <command name="Scale">
    <keyword>Scale</keyword>
    <fullCommand>Scale Shape#,X Ratio,Y Ratio[,Palette#]</fullCommand>
    <parameters>Shape#,X Ratio,Y Ratio[,Palette#]</parameters>
    <shortDescription />
    <longDescription>Scale is a very powerful command which may be used to 'stretch' or'shrink' shape
objects. The Ratio parameters specify how much stretching or shrinking to perform. A
Ratio greater than one will cause the shape to be stretched (enlarged), while a
Ratio of less than one will cause the shape to be shrunk (reduced). A Ratio of
exactly one will cause no change in the shape's relevant dimension.

As there are separate Ratio parameters for both x and y, a shape may be stretched
along one axis and shrunk along the other!

The optional Palette# parameter allows you to specify a palette object for use in
the scaling operation. If a Palette# is supplied, the scale command will use a
'brightest pixel' method of shrinking. This means a shape may be shrunk to a small
size without detail being lost.</longDescription>
  </command>
  <command name="XFlip">
    <keyword>XFlip</keyword>
    <fullCommand>XFlip Shape#</fullCommand>
    <parameters>Shape#</parameters>
    <shortDescription />
    <longDescription>The XFlip command is one of Blitz's powerful shape manipulation commands. XFlip will
horizontally 'mirror' a shape object, causing the object to be 'turned back to
front'.</longDescription>
  </command>
  <command name="YFlip">
    <keyword>YFlip</keyword>
    <fullCommand>YFlip Shape#</fullCommand>
    <parameters>Shape#</parameters>
    <shortDescription />
    <longDescription>The YFlip command may be used to vertically 'mirror' a shape object. The resultant
shape will appear to have been 'turned upside down'.</longDescription>
  </command>
  <command name="Rotate">
    <keyword>Rotate</keyword>
    <fullCommand>Rotate Shape#,Angle Ratio</fullCommand>
    <parameters>Shape#,Angle Ratio</parameters>
    <shortDescription />
    <longDescription>The Rotate command allows you to rotate a shape object. Angle Ratio specifies how
much clockwise rotation to apply, and should be in the range zero to one. For
instance, an Angle Ratio of .5 will cause a shape to be rotated 180 degrees, while
an Angle Ratio of .25 will cause a shape to be rotated 90 degrees clockwise.</longDescription>
  </command>
  <command name="Circle">
    <keyword>Circle</keyword>
    <fullCommand>Circle x,y,rx[,ry],color</fullCommand>
    <parameters>x,y,rx[,ry],color</parameters>
    <shortDescription />
    <longDescription>Circle will draw an open circle onto the currently used bitmap. X and Y specify the
mid point of the circle. The Radius parameter specifies the radius of the circle. If
a Y Radius parameter is supplied, then an ellipse may be drawn. A Colour parameter
of -1 will cause an 'inverted' circle to be drawn.</longDescription>
  </command>
  <command name="Circlef">
    <keyword>Circlef</keyword>
    <fullCommand>Circlef x,y,rx[,ry],color</fullCommand>
    <parameters>x,y,rx[,ry],color</parameters>
    <shortDescription />
    <longDescription>Circlef will draw a filled circle onto the currently used bitmap. X and Y specify
the mid point of the circle - Colour, the colour in which to draw the circle. The
Radius parameter specifies the radius of the circle. If a Y Radius parameter is
supplied, then an ellipse may be drawn.

A Colour parameter of -1 will cause an 'inverted' circle to be drawn.</longDescription>
  </command>
  <command name="Box">
    <keyword>Box</keyword>
    <fullCommand>Box x1,y1,x2,y2,color</fullCommand>
    <parameters>x1,y1,x2,y2,color</parameters>
    <shortDescription />
    <longDescription>The Box command draws a rectangular outline onto the currently used bitmap. X1, Y1,
X2 and Y2 specify two corners of the box to be drawn. Colour refers to the colour to
draw the box in. A Colour parameter of -1 will cause an 'inverted' box to be drawn.</longDescription>
  </command>
  <command name="Boxf">
    <keyword>Boxf</keyword>
    <fullCommand>Boxf x1,y1,x2,y2,color</fullCommand>
    <parameters>x1,y1,x2,y2,color</parameters>
    <shortDescription />
    <longDescription>Boxf draws a solid rectangular shape on the currently used bitmap. X1,Y1,X2 and Y2
refer to two corners of the box. Colour specifies the colour to draw the box in. A
Colour parameter of -1 will cause the rectangular area to be 'inverted'.</longDescription>
  </command>
  <command name="Line">
    <keyword>Line</keyword>
    <fullCommand>Line [x1,y1,]x2,y2,color[,width]</fullCommand>
    <parameters>[x1,y1,]x2,y2,color[,width]</parameters>
    <shortDescription />
    <longDescription>The Line command draws a line connecting two pixels onto the currently used bitmap.
The X and Y parameters specify the pixels to be joined, and Colour specifies the
colour to draw the line in If X1 and Y1 are omitted, the end points (X2,Y2) of the
last line drawn will be used. A Colour parameter of -1 will cause an 'inverted' line
to be drawn.</longDescription>
  </command>
  <command name="FreeFill">
    <keyword>FreeFill</keyword>
    <fullCommand>FreeFill frees memory allocated for 2d fill routines</fullCommand>
    <parameters>frees memory allocated for 2d fill routines</parameters>
    <shortDescription />
    <longDescription>FreeFill will deallocate the memory that Blitz uses to execute the commands Circlef,
FloodFill, ReMap and Boxf.

Blitz uses a single monochrome bitmap the size of the bitmap being drawn to to do
it's filled routines, by using the FreeFill command this BitMap can be 'freed' up if
no more filled commands are to be executed.</longDescription>
  </command>
  <command name="AllocFill">
    <keyword>AllocFill</keyword>
    <fullCommand>AllocFill for internal use only (polylib.obj)</fullCommand>
    <parameters>for internal use only (polylib.obj)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReMap">
    <keyword>ReMap</keyword>
    <fullCommand>ReMap colour# to replace,destination colour# [,BitMap destintion</fullCommand>
    <parameters>colour# to replace,destination colour# [,BitMap destintion</parameters>
    <shortDescription />
    <longDescription>ReMap is used to change all the pixels on a BitMap in one colour to another colour.
The optional BitMap parameter will copy all the pixels in Colour#0 to their new
colour on the new bitmap.</longDescription>
  </command>
  <command name="FloodFill">
    <keyword>FloodFill</keyword>
    <fullCommand>FloodFill x,y,colour [,border colour]</fullCommand>
    <parameters>x,y,colour [,border colour]</parameters>
    <shortDescription />
    <longDescription>FloodFill will 'colour in' a region of the screen starting at the coordinates X,Y.
The first mode will fill all the region that is currently the colour at the
coordinates X,Y with the colour specified by Colour. The second mode will fill a
region starting at X,Y and surrounded by the BorderColour with Colour.</longDescription>
  </command>
  <command name="Poly">
    <keyword>Poly</keyword>
    <fullCommand>Poly numpts,*coords.w,color</fullCommand>
    <parameters>numpts,*coords.w,color</parameters>
    <shortDescription />
    <longDescription>Poly is a bitmap based commands such as Box and Line. It draws a polygon using
coordinates from an array or newtype of words.</longDescription>
  </command>
  <command name="Polyf">
    <keyword>Polyf</keyword>
    <fullCommand>Polyf numpts,*coords.w,color[,color2]</fullCommand>
    <parameters>numpts,*coords.w,color[,color2]</parameters>
    <shortDescription />
    <longDescription>Same as Poly except Polyf draws filled polygons and has an optional parameter
color2, if used this colour will be used if the coordinates are listed in
anti-clockwise order, useful for 3D type applications. If color2= -1 then the
polygon is not drawn if the verticies are listed in anti- clockwise order.</longDescription>
  </command>
  <command name="BitPlanesBitMap">
    <keyword>BitPlanesBitMap</keyword>
    <fullCommand>BitPlanesBitMap srcbitmap,destbitmap,planepick</fullCommand>
    <parameters>srcbitmap,destbitmap,planepick</parameters>
    <shortDescription />
    <longDescription>BitPlanesBitMap creates a 'dummy' bitmap from the SrcBitMap with only the bitplanes
specified by the PlanePick mask. This is useful for shadow effects etc. where
blitting speed can be speed up because of the fewer bitplanes involved.</longDescription>
  </command>
  <command name="ClipBlit">
    <keyword>ClipBlit</keyword>
    <fullCommand>ClipBlit Shape#,X,Y,[Excess]</fullCommand>
    <parameters>Shape#,X,Y,[Excess]</parameters>
    <shortDescription />
    <longDescription>ClipBlit is the same as the Blit command except ClipBlit will clip the shape to the
inside of the used bitmap, all blit commands in Blitz are due to be expanded with
this feature.</longDescription>
  </command>
  <command name="ClipBlitMode">
    <keyword>ClipBlitMode</keyword>
    <fullCommand>ClipBlitMode BPLCON0</fullCommand>
    <parameters>BPLCON0</parameters>
    <shortDescription />
    <longDescription>Same as BlitMode except applies to the ClipBlit command. Another oversight now
fixed.</longDescription>
  </command>
  <command name="BitMapWindow">
    <keyword>BitMapWindow</keyword>
    <fullCommand>BitMapWindow srcbitmap,destbitmap,x,y,w,h</fullCommand>
    <parameters>srcbitmap,destbitmap,x,y,w,h</parameters>
    <shortDescription />
    <longDescription>BitMapWindow creates a dummy bitmap inside another bitmap. Both x and w parameters
are rounded to the nearest 16 pixel boundary. Any rendering, printing and blitting
to the new bitmap will be clipped inside the area used.</longDescription>
  </command>
  <command name="BitMapOrigin">
    <keyword>BitMapOrigin</keyword>
    <fullCommand>BitMapOrigin BitMap#,x,y</fullCommand>
    <parameters>BitMap#,x,y</parameters>
    <shortDescription />
    <longDescription>BitMapOrigin allows the programmer to relocate the origin (0,0) of the bitmap used
by the drawing commands line, poly, box and circle.</longDescription>
  </command>
  <command name="Sort">
    <keyword>Sort</keyword>
    <fullCommand>Sort Arrayname()</fullCommand>
    <parameters>Arrayname()</parameters>
    <shortDescription />
    <longDescription>Sort will cause the specified array to be sorted.

The direction of the sort may be specified using either the SortUp or SortDown
commands. The default direction used for sorting is ascending - ie: array elements
are sorted into a 'low to high' order.</longDescription>
  </command>
  <command name="SortUp">
    <keyword>SortUp</keyword>
    <fullCommand>SortUp</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>SortUp may be used to force the Sort command to sort arrays into ascending order.
This means that, after being sorted, an array's contents will be ordered in a 'low
to high' manner.</longDescription>
  </command>
  <command name="SortDown">
    <keyword>SortDown</keyword>
    <fullCommand>SortDown</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>SortDown may be used to force the Sort command to sort arrays into descending order.
This means that, after being sorted, an array's contents will be ordered in a 'high
to low' manner.</longDescription>
  </command>
  <command name="By">
    <keyword>By</keyword>
    <fullCommand>By</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="Speak">
    <keyword>Speak</keyword>
    <fullCommand>Speak string</fullCommand>
    <parameters>string</parameters>
    <shortDescription />
    <longDescription>The Speak command will first convert the given string to phonetics and then pass it
to the Narrator.Device. Depending on the settings of the Narrator device (see
SetVoice) the Amiga will "speak" the string you have sent in the familiar Amiga
synthetic voice.</longDescription>
  </command>
  <command name="SetVoice">
    <keyword>SetVoice</keyword>
    <fullCommand>SetVoice rate(150),pitch(110),expression(1),sex,volume(64),freq(22200)</fullCommand>
    <parameters>rate(150),pitch(110),expression(1),sex,volume(64),freq(22200)</parameters>
    <shortDescription />
    <longDescription>SetVoice alters the sound of the Amiga's speech synthsiser by changing the vocal
characteristics listed in the parameters above.</longDescription>
  </command>
  <command name="Translate$">
    <keyword>Translate$</keyword>
    <fullCommand>Translate$ returns phoneme translation of a string</fullCommand>
    <parameters>returns phoneme translation of a string</parameters>
    <shortDescription />
    <longDescription>Translate$() returns the phonetic equivalent of the string for use with the
PhoneticSpeak command.</longDescription>
  </command>
  <command name="PhoneticSpeak">
    <keyword>PhoneticSpeak</keyword>
    <fullCommand>PhoneticSpeak phonetic string</fullCommand>
    <parameters>phonetic string</parameters>
    <shortDescription />
    <longDescription>PhoneticSpeak is similar to the Speak command but should only be passed strings
containing legal phonemes such as that produced by the Translate$() function.</longDescription>
  </command>
  <command name="VoiceLoc">
    <keyword>VoiceLoc</keyword>
    <fullCommand>VoiceLoc returns location of newvoice struct</fullCommand>
    <parameters>returns location of newvoice struct</parameters>
    <shortDescription />
    <longDescription>VoiceLoc returns a pointer to the internal variables in the speech synthesiser that
enable the user to access new parameters added to the V37 Narrator Device.

Formants as referred to in the descriptions are the major vocal tracts and are
separated into the parts of speech that produce the bass, medium and trebly sounds.</longDescription>
  </command>
  <command name="GetaSprite">
    <keyword>GetaSprite</keyword>
    <fullCommand>GetaSprite Sprite#,Shape#</fullCommand>
    <parameters>Sprite#,Shape#</parameters>
    <shortDescription />
    <longDescription>To be able to display a sprite, you must first create a sprite object. This will
contain the image information for the sprite. GetaSprite will transfer the graphic
data contained in a shape object into a sprite object. This allows you to perform
any of the Blitz shape manipulation commands (eg Scale or Rotate) on a shape before
creating a sprite from the shape.

Once GetaSprite has been executed, you may not require the shape object anymore. In
this case, it is best to tree up the shape object (using Free Shape) to conserve as
much valuable chip memory as possible.</longDescription>
  </command>
  <command name="ShowSprite">
    <keyword>ShowSprite</keyword>
    <fullCommand>ShowSprite Sprite#,X,Y,Sprite Channel</fullCommand>
    <parameters>Sprite#,X,Y,Sprite Channel</parameters>
    <shortDescription />
    <longDescription>ShowSprite is the command used to actually display a sprite through a sprite
channel. X and Y specify the position the sprite is to be displayed at. These
parameters are ALWAYS given in lo-resolution pixels. Sprite Channel is a value 0
through 7 which decides which sprite channel the sprite should be display through.</longDescription>
  </command>
  <command name="InFront">
    <keyword>InFront</keyword>
    <fullCommand>InFront Sprite Channel</fullCommand>
    <parameters>Sprite Channel</parameters>
    <shortDescription />
    <longDescription>A feature of sprites is that they may be displayed either 'in front of' or 'behind'
the bitmap graphics they are appearing in. The InFront command allows you to
determine which sprites appear in front of bitmaps, and which sprites appear behind.

Sprite Channel must be an even number in the range 0 through 8. After executing an
InFront command, sprites displayed through sprite channels greater than or equal to
Sprite Channel will appear BEHIND any bitmap graphics. Sprites displayed through
channels less than Sprite Channel will appear IN FRONT OF any bitmap graphics. For
example, after executing an InFront 4, any sprites displayed through sprite channels
4,5,6 or 7 will appear behind any bitmap graphics, while any sprites displayed
through sprite channels 0,1,2 or 3 will appear in front of any bitmap graphics.

InFront should only be used in non-dualplayfield slices.</longDescription>
  </command>
  <command name="InFrontF">
    <keyword>InFrontF</keyword>
    <fullCommand>InFrontF Sprite Channel</fullCommand>
    <parameters>Sprite Channel</parameters>
    <shortDescription />
    <longDescription>InFrontF is used on dualplayfield slices to determine sprite/playfield priority with
respect to the foreground playfield. Using combinations of InFrontF and InFrontB
(used for the background playfield), it is possible to display sprites at up to 3
different depths -some in front of both playfields, some between the playfields, and
some behind both playfields.</longDescription>
  </command>
  <command name="InFrontB">
    <keyword>InFrontB</keyword>
    <fullCommand>InFrontB Sprite Channel</fullCommand>
    <parameters>Sprite Channel</parameters>
    <shortDescription />
    <longDescription>InFrontB is used on dualplayfield slices to determine sprite/playfield priority with
respect to the background playfield. Using combinations of InFrontB and InFrontF
(used for the foreground playfield), it is possible to display sprites at up to 3
different depths -some in front of both playfields, some between the playfields, and
some behind both playfields.</longDescription>
  </command>
  <command name="SaveSprites">
    <keyword>SaveSprites</keyword>
    <fullCommand>SaveSprites Sprite#,Sprite#,Filename$</fullCommand>
    <parameters>Sprite#,Sprite#,Filename$</parameters>
    <shortDescription />
    <longDescription>SaveSprites allows you to create a file containing a range of sprite objects. This
file may be later loaded using the LoadSprites command.

The range of sprites to be saved is specified by Sprite#,Sprite#, where the first
Sprite# refers to the lowest sprite to be saved and the second Sprite# the highest.</longDescription>
  </command>
  <command name="LoadSprites">
    <keyword>LoadSprites</keyword>
    <fullCommand>LoadSprites Sprite#[,Sprite#],Filename$</fullCommand>
    <parameters>Sprite#[,Sprite#],Filename$</parameters>
    <shortDescription />
    <longDescription>LoadSprites lets you load a 'range' of sprites from disk into a series of sprite
objects. The file specified by Filename$ should have been created using the
SaveSprites command. The first Sprite# parameter specifies the number of the first
sprite object to be loaded. Further sprites will be loaded into increasingly higher
sprite objects. If a second Sprite# parameter is supplied, then only sprites up to
and including the second Sprite# value will be loaded. If there are not enough
sprites in the file to fill this range, any excess sprites will remain untouched.</longDescription>
  </command>
  <command name="SpriteMode">
    <keyword>SpriteMode</keyword>
    <fullCommand>SpriteMode 0=16 1=32 2=64</fullCommand>
    <parameters>0=16 1=32 2=64</parameters>
    <shortDescription />
    <longDescription>For use with the capabilities of the new Display library SpriteMode is used to
define the width of sprites to be used in the program. The mode values 0, 1 and 2
correspong to the widths 16, 32 and 64.</longDescription>
  </command>
  <command name="Stencil">
    <keyword>Stencil</keyword>
    <fullCommand>Stencil Stencil#,BitMap#</fullCommand>
    <parameters>Stencil#,BitMap#</parameters>
    <shortDescription />
    <longDescription>The Stencil command will create a stencil object based on the contents of a
previously created bitmap. The stencil will contain information based on all
graphics contained in the bitmap, and may be used with the SBlit and ShowStencil
commands.</longDescription>
  </command>
  <command name="SBlit">
    <keyword>SBlit</keyword>
    <fullCommand>SBlit Stencil#,Shape#,X,Y[,Excessonoff]</fullCommand>
    <parameters>Stencil#,Shape#,X,Y[,Excessonoff]</parameters>
    <shortDescription />
    <longDescription>SBlit works identically to the Blit command, and also updates the specified
Stencil#. This is an easy way to render 'foreground' graphics to a bitmap.</longDescription>
  </command>
  <command name="SBlitMode">
    <keyword>SBlitMode</keyword>
    <fullCommand>SBlitMode BLTCON0</fullCommand>
    <parameters>BLTCON0</parameters>
    <shortDescription />
    <longDescription>SBlitmode is used to determine how the SBlit command operates. Please refer to the
BlitMode command tor more information on blitting modes.</longDescription>
  </command>
  <command name="Left$">
    <keyword>Left$</keyword>
    <fullCommand>Left$(String$,Length)</fullCommand>
    <parameters>(String$,Length)</parameters>
    <shortDescription />
    <longDescription>This function returns the Length leftmost characters of string String$.</longDescription>
  </command>
  <command name="Right$">
    <keyword>Right$</keyword>
    <fullCommand>Right$(String$,Length)</fullCommand>
    <parameters>(String$,Length)</parameters>
    <shortDescription />
    <longDescription>Right$() returns the rightmost Length characters from string String$.</longDescription>
  </command>
  <command name="Mid$">
    <keyword>Mid$</keyword>
    <fullCommand>Mid$(String$,Startchar[,Length])</fullCommand>
    <parameters>(String$,Startchar[,Length])</parameters>
    <shortDescription />
    <longDescription>This function returns Length characters of string String$ starting at character
Startchar. If the optional Length parameter is omitted, then all characters from
Startchar up to the end of String$ will be returned.</longDescription>
  </command>
  <command name="Hex$">
    <keyword>Hex$</keyword>
    <fullCommand>Hex$(Expression)</fullCommand>
    <parameters>(Expression)</parameters>
    <shortDescription />
    <longDescription>Hex$() returns an 8 character string equivalent to the hexadecimal representation of
Expression.</longDescription>
  </command>
  <command name="Bin$">
    <keyword>Bin$</keyword>
    <fullCommand>Bin$(Expression)</fullCommand>
    <parameters>(Expression)</parameters>
    <shortDescription />
    <longDescription>Hex$() returns a 32 character string equivalent to the binary representation of
Expression.</longDescription>
  </command>
  <command name="Chr$">
    <keyword>Chr$</keyword>
    <fullCommand>Chr$(Expression)</fullCommand>
    <parameters>(Expression)</parameters>
    <shortDescription />
    <longDescription>Chr$ returns a one character string equivalent to the ASCII character Expression.
ASCII is a standard way of coding the characters used by the computer display.</longDescription>
  </command>
  <command name="Asc">
    <keyword>Asc</keyword>
    <fullCommand>Asc(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription>Asc() returns the ASCII value of the first characters in the string String$.</longDescription>
  </command>
  <command name="String$">
    <keyword>String$</keyword>
    <fullCommand>String$(String$,Repeats)</fullCommand>
    <parameters>(String$,Repeats)</parameters>
    <shortDescription />
    <longDescription>This function will return a string containing Repeats sequential occurrences of the
string String$.</longDescription>
  </command>
  <command name="Instr">
    <keyword>Instr</keyword>
    <fullCommand>Instr(String$,Findstring$[,Startpos])</fullCommand>
    <parameters>(String$,Findstring$[,Startpos])</parameters>
    <shortDescription />
    <longDescription>Instr attempts to locate FindString$ within String$. If a match is found, the
character position of the first matching character will be returned. If no match is
found, 0 will be returned.

The optional Startpos parameter allows you to specify a starting character position
for the search.

CaseSense may be used to determine whether the search is case sensitive or not.</longDescription>
  </command>
  <command name="Replace$">
    <keyword>Replace$</keyword>
    <fullCommand>Replace$(String$,Findstring$,Replacestring$)</fullCommand>
    <parameters>(String$,Findstring$,Replacestring$)</parameters>
    <shortDescription />
    <longDescription>Replace$() will search the string String$ for any occurrences of the string
Findstring$ and replace it with the string Replacestring$.

CaseSense may be used to determine whether the search is case sensitive or not.</longDescription>
  </command>
  <command name="Mki$">
    <keyword>Mki$</keyword>
    <fullCommand>Mki$(Integer)</fullCommand>
    <parameters>(Integer)</parameters>
    <shortDescription />
    <longDescription>This will create a two byte character string, given the two byte numeric value
Numeric. Mki$ is often used before writing integer values to sequential files to
save on disk space. When the file is later read in, Cvi may be used to convert the
string back to an integer.</longDescription>
  </command>
  <command name="Mkl$">
    <keyword>Mkl$</keyword>
    <fullCommand>Mkl$(Long)</fullCommand>
    <parameters>(Long)</parameters>
    <shortDescription />
    <longDescription>This will create a four byte character string, given the four byte numeric value
Long. Mkl$ is often used when writing long values to sequential files to save on
disk space. When the file is later read in, Cvl may be used to convert the string
back to a long.</longDescription>
  </command>
  <command name="Cvi">
    <keyword>Cvi</keyword>
    <fullCommand>Cvi(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription>Cvi returns an integer value equivalent to the left 2 characters of String$. This is
the logical opposite of Mki$.</longDescription>
  </command>
  <command name="Cvl">
    <keyword>Cvl</keyword>
    <fullCommand>Cvl(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription>Cvl returns a long value equivalent to the left 4 characters of String$. This is the
logical opposite of Mkl$.</longDescription>
  </command>
  <command name="Len">
    <keyword>Len</keyword>
    <fullCommand>Len(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription>Len returns the length of the string String$.</longDescription>
  </command>
  <command name="UnLeft$">
    <keyword>UnLeft$</keyword>
    <fullCommand>UnLeft$(String$,Length)</fullCommand>
    <parameters>(String$,Length)</parameters>
    <shortDescription />
    <longDescription>UnLeft$() removes the rightmost Length characters from the string String$.</longDescription>
  </command>
  <command name="UnRight$">
    <keyword>UnRight$</keyword>
    <fullCommand>UnRight$(String$,Length)</fullCommand>
    <parameters>(String$,Length)</parameters>
    <shortDescription />
    <longDescription>UnRight$() removes the leftmost Length characters from the string String$.</longDescription>
  </command>
  <command name="StripLead$">
    <keyword>StripLead$</keyword>
    <fullCommand>StripLead$(String$,Ascii)</fullCommand>
    <parameters>(String$,Ascii)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StripTrail$">
    <keyword>StripTrail$</keyword>
    <fullCommand>StripTrail$(String$,Ascii)</fullCommand>
    <parameters>(String$,Ascii)</parameters>
    <shortDescription />
    <longDescription>StripTrail$ removes all trailing occurrences of the ASCII character specified by
Expression from the string String$.</longDescription>
  </command>
  <command name="LSet$">
    <keyword>LSet$</keyword>
    <fullCommand>LSet$(String$,Characters)</fullCommand>
    <parameters>(String$,Characters)</parameters>
    <shortDescription />
    <longDescription>This function returns a string of Characters characters long. The string String$
will be placed at the beginning of this string. If String$ is shorter than
Characters the right hand side is padded with spaces. If it is longer, it will be
truncated.</longDescription>
  </command>
  <command name="RSet$">
    <keyword>RSet$</keyword>
    <fullCommand>RSet$(String$,Characters)</fullCommand>
    <parameters>(String$,Characters)</parameters>
    <shortDescription />
    <longDescription>This function returns a string of Characters characters long. The string String$
will be placed at end of this string. If String$ is shorter than Characters the lett
hand side is padded with spaces. If it is longer, it will be truncated.</longDescription>
  </command>
  <command name="Centre$">
    <keyword>Centre$</keyword>
    <fullCommand>Centre$(String$,Characters)</fullCommand>
    <parameters>(String$,Characters)</parameters>
    <shortDescription />
    <longDescription>This function returns a string of Characters characters long. The string String$
will be centered in the resulting string. If String$ is shorter than Characters the
left and right sides will be padded with spaces. If it is longer, it will be
truncated on either side.</longDescription>
  </command>
  <command name="LCase$">
    <keyword>LCase$</keyword>
    <fullCommand>LCase$(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription>This function returns the string String$ converted into lowercase.</longDescription>
  </command>
  <command name="UCase$">
    <keyword>UCase$</keyword>
    <fullCommand>UCase$(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription>This function returns the string String$ converted to uppercase.</longDescription>
  </command>
  <command name="CaseSense">
    <keyword>CaseSense</keyword>
    <fullCommand>CaseSense On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription>CaseSense allows you to control the searching mode used by the Instr and Replace$
functions.

CaseSense On: indicates that an exact match must be found.

CaseSense Off: indicates that alphabetic characters may be matched even if they are
not in the same case.

CaseSense On is the default search mode.</longDescription>
  </command>
  <command name="Mkq$">
    <keyword>Mkq$</keyword>
    <fullCommand>Mkq$(Quick)</fullCommand>
    <parameters>(Quick)</parameters>
    <shortDescription />
    <longDescription>This will create a four byte character string, given the four byte numeric value
Quick. Mkq$ is often used when writing quick values to sequential files to save on
disk space. When the file is later read in, Cvq may be used to convert the string
back to a quick.</longDescription>
  </command>
  <command name="Cvq">
    <keyword>Cvq</keyword>
    <fullCommand>Cvq(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription>Cvq returns a quick value equivalent to the left 4 characters of String$. This is
the logical opposite of Mkq$.</longDescription>
  </command>
  <command name="LoadModule">
    <keyword>LoadModule</keyword>
    <fullCommand>LoadModule Module#,Filename$</fullCommand>
    <parameters>Module#,Filename$</parameters>
    <shortDescription />
    <longDescription>LoadModule loads in from disk a soundtracker/noisetracker music module. This module
may be later played back using PlayModule.</longDescription>
  </command>
  <command name="PlayModule">
    <keyword>PlayModule</keyword>
    <fullCommand>PlayModule Module#</fullCommand>
    <parameters>Module#</parameters>
    <shortDescription />
    <longDescription>PlayModule will cause a previously loaded soundtracker/noisetracker song module to
be played back.</longDescription>
  </command>
  <command name="StopModule">
    <keyword>StopModule</keyword>
    <fullCommand>StopModule</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>StopModule will cause any soundtracker/noisetracker modules which may be currently
playing to stop.</longDescription>
  </command>
  <command name="CreateMsgPort">
    <keyword>CreateMsgPort</keyword>
    <fullCommand>CreateMsgPort</fullCommand>
    <parameters />
    <shortDescription>*UserPort.port=CreateMsgPort(PortName$).</shortDescription>
    <longDescription>CreateMsgPort is a general Function and not specific to ARexx.

CreateMsgPort opens an intuition PUBLIC message port of the name supplied as the
only argument. If all is well the address of the port created will be returned to
you as a LONGWORD so the variable that you assign it to should be of type long.

If you do not supply a name then a private MsgPort will be opened for you.

Port.l=CreateMsgPort("PortName")

It is important that you check you actually succeeded in opening a port in your
program. The following code or something similar will suffice.

Port.l=CreateMsgPort("Name")
IF Port=0 THEN Error_Routine{}

The name you give your port will be the name that Arexx looks for as the HOST
address, (and is case sensitive) so take this into consideration when you open your
port.

NOTE IT MUST BE A UNIQUE NAME AND SHOULD NOT INCLUDE SPACES. 

DeleteMsgPort() is used to remove the port later but this is not entirely necessary
as Blitz will clean up for you on exit if need be.</longDescription>
  </command>
  <command name="DeleteMsgPort">
    <keyword>DeleteMsgPort</keyword>
    <fullCommand>DeleteMsgPort</fullCommand>
    <parameters />
    <shortDescription>*UserPort.</shortDescription>
    <longDescription>DeleteMsgPort deletes a MessagePort previously allocated with CreateMsgPort(). The
only argument taken by DeleteMsgPort is the address returned by CreateMsgPort(). If
the Port was a public port then it will be removed from the public port list.


Port.l=CreateMsgPort("Name")
IF Port=0 Then End
DeleteMsgPort Port

Error checking is not critical as if this fails we have SERIOUS PROBLEMS.

YOU MUST WAIT FOR ALL MESSAGES FROM AREXX TO BE RECEIVED BEFORE YOU DELETE THE
MSGPORT. 

YOU NEGLECT TO DELETE A MSGPORT BLITZ2 WILL DO IT FOR YOU AUTOMATICALLY ON
PROGRAM EXIT. .</longDescription>
  </command>
  <command name="Wait">
    <keyword>Wait</keyword>
    <fullCommand>Wait</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>Wait halts all program execution until an event occurs that the program is
interested in. Any intuition event such as clicking on a gadget in a window will
start program execution again.

A message arriving at a MsgPort will also start program execution again. So you may
use Wait to wait for input from any source including messages from ARexx to your
program.

Wait should always be paired with EVENT if you need to consider intuition events in
your event handler loop.</longDescription>
  </command>
  <command name="TaskName$">
    <keyword>TaskName$</keyword>
    <fullCommand>TaskName$ task</fullCommand>
    <parameters>task</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Val">
    <keyword>Val</keyword>
    <fullCommand>Val(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription>This functions converts the string String$ into a numeric value and returns this
value. When converting the string, the conversion will stop the moment either a non
numeric value or a second decimal point is reached.</longDescription>
  </command>
  <command name="Int">
    <keyword>Int</keyword>
    <fullCommand>Int(Expression)</fullCommand>
    <parameters>(Expression)</parameters>
    <shortDescription />
    <longDescription>This returns the Integer part (before the decimal point) of Expression.</longDescription>
  </command>
  <command name="Sgn">
    <keyword>Sgn</keyword>
    <fullCommand>Sgn(Expression)</fullCommand>
    <parameters>(Expression)</parameters>
    <shortDescription />
    <longDescription>Sgn returns the sign of Expression. If Expression is less than 0, then -1 is
returned. If Expression is equal to 0, then 0 is returned. If Expression is greater
than 0, then 1 is returned.</longDescription>
  </command>
  <command name="Frac">
    <keyword>Frac</keyword>
    <fullCommand>Frac(Expression)</fullCommand>
    <parameters>(Expression)</parameters>
    <shortDescription />
    <longDescription>Frac() returns the fractional part of Expression.</longDescription>
  </command>
  <command name="QFrac">
    <keyword>QFrac</keyword>
    <fullCommand>QFrac(Quick)</fullCommand>
    <parameters>(Quick)</parameters>
    <shortDescription />
    <longDescription>QFrac() returns the fractional part of a quick value. It works like Frac() but
accepts a quick value as it's argument. It is faster than Frac() but has the normal
quick value limits.</longDescription>
  </command>
  <command name="QWrap">
    <keyword>QWrap</keyword>
    <fullCommand>QWrap(Quick,Low,High)</fullCommand>
    <parameters>(Quick,Low,High)</parameters>
    <shortDescription />
    <longDescription>QWrap will wrap the result of the Quick expression if Quick is greater than or equal
to high, or less than low.

If Quick is less than Low, then Quick-Low+High is returned.
If Quick is greater than or equal to High, then Quick-High+Low is returned.</longDescription>
  </command>
  <command name="Rnd">
    <keyword>Rnd</keyword>
    <fullCommand>Rnd [(Range)]</fullCommand>
    <parameters>[(Range)]</parameters>
    <shortDescription />
    <longDescription>This function returns a random number. If Range is not specified then a random
decimal is returned between 0 and 1. If Range is specified, then a decimal value
between O and Range is returned.</longDescription>
  </command>
  <command name="QAbs">
    <keyword>QAbs</keyword>
    <fullCommand>QAbs(Quick)</fullCommand>
    <parameters>(Quick)</parameters>
    <shortDescription />
    <longDescription>QAbs works just like Abs except that the value it accepts is a Quick. This enhances
the speed at which the function executes quite dramatically. Of course you are
limited by the restrictions of the quick type of value.</longDescription>
  </command>
  <command name="Abs">
    <keyword>Abs</keyword>
    <fullCommand>Abs(Expression)</fullCommand>
    <parameters>(Expression)</parameters>
    <shortDescription />
    <longDescription>This function returns the positive equivalent of Expression.</longDescription>
  </command>
  <command name="QLimit">
    <keyword>QLimit</keyword>
    <fullCommand>QLimit(Quick,Low,High)</fullCommand>
    <parameters>(Quick,Low,High)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NTSC">
    <keyword>NTSC</keyword>
    <fullCommand>NTSC</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>This function returns 0 if the display is currently in PAL mode, or -1 if currently
in NTSC mode. This may be used to write software which dynamically adjusts itself to
different versions of the Amiga computer.</longDescription>
  </command>
  <command name="DispHeight">
    <keyword>DispHeight</keyword>
    <fullCommand>DispHeight</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>DispHeight will return 256 if executed on a PAL Amiga, or 200 if executed on an NTSC
Amiga. This allows programs to open full sized screens, windows etc on any Amiga.</longDescription>
  </command>
  <command name="VPos">
    <keyword>VPos</keyword>
    <fullCommand>VPos</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>VPos returns the video's beam vertical position. Useful in both highspeed animation
where screen update may need to be synced to a certain video beam position (not just
the top of frame as with VWait) and for a fast random nember generator in non
frame-synced applications.</longDescription>
  </command>
  <command name="True">
    <keyword>True</keyword>
    <fullCommand>True</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>True is a system constant with a value of -1.</longDescription>
  </command>
  <command name="False">
    <keyword>False</keyword>
    <fullCommand>False</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>False is a system constant with a value of 0.</longDescription>
  </command>
  <command name="QAngle">
    <keyword>QAngle</keyword>
    <fullCommand>QAngle(Src X,Src Y,Dest X,Dest Y)</fullCommand>
    <parameters>(Src X,Src Y,Dest X,Dest Y)</parameters>
    <shortDescription />
    <longDescription>QAngle returns the angle between the two 2D coordinates passed. the Qangle returned
is a value from 0..1, 1 representing 360 degrees in standard polar geometry.</longDescription>
  </command>
  <command name="Window">
    <keyword>Window</keyword>
    <fullCommand>Window Window#,X,Y,Width,Height,Flags,Title$,Dpen,Bpen[,GadgetList#[,BitMap#]]</fullCommand>
    <parameters>Window#,X,Y,Width,Height,Flags,Title$,Dpen,Bpen[,GadgetList#[,BitMap#]]</parameters>
    <shortDescription />
    <longDescription>Window opens an Intuition window on the currently used screen. Window# is a unique
object number for the new window. X and Y refer to the offset from the top left of
the screen the window is to appear at. Width and Height are the size of the window
in pixels.

Flags are the special window flags that a window can have when opened. These flags
allow for the inclusion of a sizing gadget, dragbar and many other things. The flags
are listed as followed, with their corresponding values. To select more than one of
these flags, they must be logically Or'd together using the 'l' operator.

For example, to open a window with dragbar and sizing gadget which is active once
opened, you would specify a Flags parameter of $1 $21 $1000.

Title$ is a BASIC string, either a constant or a variable, that you want to be the
title of the window.

Dpen is the colour of the detail pen of the window. This colour is used for the
window title.

BPen is the block pen of the window. This pen is used for things like the border
around the edge of the window.

The optional GadgetList# is the number of a gadgetlist object you have may want
attached to the window.

After the window has opened, it will become the currently used window.

The Window library has been extended to handle super bitmap windows. SuperBitMap
windows allow the window to have it's own bitmap which can actually be larger than
the window. The two main benefits of this feature are the window's ability to
refresh itself and the ability to scroll around a large area "inside" the bitmap.

To attach a BitMap to a Window set the SuperBitMap flag in the flags field and
include the BitMap# to be attached.

Window    Flag Value Description 

WINDOWSIZING $0001   Attaches sizing gadget to bottom right corner of window and allows
                     it to be sized.
WINDOWDRAG   $0002   Allows window to be dragged with the mouse by it's title bar.
WINDOWDEPTH  $0004   Lets windows be pushed behind or pulled in front of other windows.
WINDOWCLOSE  $0008   Attaches a closegadget to the upper left corner of the window.
SIZEBRIGHT   $0010   With GIMMEZEROZERO and WINDOWSIZING set, this will leave the right
                     hand margin, the width of the sizing gadget, clear, and any drawing
                     to the window will not extend over this right margin.
SIZEBBOTTOM  $0020   Same as SIZEBRIGHT except it leaves a margin at the bottom of the
                     window, the width of the sizing gadget.
BACKDROP     $0100   This opens the window behind any other window that is already
                     opened. It cannot have the WINDOWDEPTH flag set also, as the
                     window is intended to stay behind all others.
GIMME00      $0400   This flag keeps the windows border separate from the rest of the
                     windows area. Any drawing on the window, extending to the borders,
                     will not overwrite the border.
                     NOTE: Although convevient, this does take up more memory than usual.
BORDERLESS   $0800   Opens a window without any border on it at all.
ACTIVATE     $1000   Activates the window once opened.</longDescription>
  </command>
  <command name="WaitEvent">
    <keyword>WaitEvent</keyword>
    <fullCommand>WaitEvent</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>WaitEvent will halt program excution until an Intuition event has been received.
This event must be one that satisfies the IDCMP flags of any open windows. If used
as a function, WaitEvent returns the IDCMP flag of the event (please refer to
DefaultIDCMP for a table of possible IDCMP flags). If used as a statement, you have
no way of telling what event occured.

You may find the window object number that caused the event using the EventWindow
function.

In the case of events concerning gadgets or menus, further functions are available
to detect which gadget or menu was played with.

In the case of mouse button events, the MButtons function may be used to discover
exactly which mouse button has been hit.

IMPORTANT NOTE: If you are assigning the result of WaitEvent to a variable, MAKE
SURE that the variable is a long type variable.

For example: MyEvent.l=WaitEvent.</longDescription>
  </command>
  <command name="Event">
    <keyword>Event</keyword>
    <fullCommand>Event</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>Event works similarly to WaitEvent in that it returns the IDCMP flag of any
outstanding windows events. However, Event will NOT cause program flow to halt.
Instead, if no event has occured, Event will return 0.</longDescription>
  </command>
  <command name="GadgetHit">
    <keyword>GadgetHit</keyword>
    <fullCommand>GadgetHit</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>GadgetHit returns the identification number of the gadget that caused the most
recent 'gadget pushed' or 'gadget released' event.

As gadgets in different windows may possibly posess the same identification numbers,
you may also need to use EventWindow to tell exactly which gadget was hit.</longDescription>
  </command>
  <command name="EventWindow">
    <keyword>EventWindow</keyword>
    <fullCommand>EventWindow</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>EventWindow may be used to determine in which window the most recent window event
occured. Window events are detected by use of either the WaitEvent or Event
commands.

EventWindow returns the window object number in which the most recent window event
occured.</longDescription>
  </command>
  <command name="DefaultIDCMP">
    <keyword>DefaultIDCMP</keyword>
    <fullCommand>DefaultIDCMP IDCMP_Flags</fullCommand>
    <parameters>IDCMP_Flags</parameters>
    <shortDescription />
    <longDescription>DefaultIDCMP allows you to set the IDCMP flags used when opening further windows.
You can change the flags as often as you like, causing all of your windows to have
their own set of IDCMP flags if you wish.

A window's IDCMP flags will affect the types of 'events' reportable by the window.
Events are reported to a program by means of either the WaitEvent or Event
functions.

To select more than one IDCMP Flag when using DefaultIDCMP, combine the separate
flags together using the OR operator ('|').

Any windows opened before any DefaultIDCMP command is executed will be opened using
an IDCMP flags setting of:

$21 $41 $81 $201 $401 $1001 $2001 $4001 $400001 $80000.

This should be sufficient for most programs.

If you do use DefaultIDCMP for some reason, it is important to remember to include
all flags necessary for the functioning of the program. For example, if you open a
window which is to have menus attached to it, you MUST set the $100 (menu selected)
IDCMP flag, or else you will have no way of telling when a menu has been selected.


IDCMP   FlagEvent 

$2      Reported when a window has it's size changed.
$4      Reported when a windows contents have been corrupted.
        This may mean a windows contents may need to be re-drawn.
$8      Reported when either mouse button has been hit.
$10     Reported when the mouse has been moved.
$20     Reported when a gadget within a window has been pushed 'down'.
$40     Reported when a gadget within a window has been 'released'.
$100    Reported when a menu operation within a window has occured.
$200    Reported when the 'close' gadget of a window has been selected.
$400    Reported when a keypress has been detected.
$8000   Reported when a disk is inserted into a disk drive.
$10000  Reported when a disk is removed from a disk drive.
$40000  Reported when a window has been 'activated'.
$80000  Reported when a window has been 'de-activated'.</longDescription>
  </command>
  <command name="MenuHit">
    <keyword>MenuHit</keyword>
    <fullCommand>MenuHit</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>MenuHit returns the identification number of the menu that caused the last menu
event. As with gadgets, you can have different menus for different windows with the
same identification number. Therefore you may also need to use EventWindow to find
which window caused the event.

If no menus have yet been selected, Menuhit will return -1.</longDescription>
  </command>
  <command name="ItemHit">
    <keyword>ItemHit</keyword>
    <fullCommand>ItemHit</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>ItemHit returns the identification number of the menu item that caused the last menu
event.</longDescription>
  </command>
  <command name="SubHit">
    <keyword>SubHit</keyword>
    <fullCommand>SubHit</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>SubHit returns the identification number of the the menu subitem that caused the
last menu event. If no subitem was selected, SubHit will return -1.</longDescription>
  </command>
  <command name="WindowFont">
    <keyword>WindowFont</keyword>
    <fullCommand>WindowFont IntuiFont# [,SoftStyle]</fullCommand>
    <parameters>IntuiFont# [,SoftStyle]</parameters>
    <shortDescription />
    <longDescription>WindowFont sets the font for the currently used window. Any further printing to this
window will be in the specified font. IntuiFont# specifies a previously initialized
intuifont object created using LoadFont.</longDescription>
  </command>
  <command name="WPlot">
    <keyword>WPlot</keyword>
    <fullCommand>WPlot X,Y,Colour</fullCommand>
    <parameters>X,Y,Colour</parameters>
    <shortDescription />
    <longDescription>WPlot plots a pixel in the currently used window at the coordinates X,Y in the
colour specified by Colour.</longDescription>
  </command>
  <command name="WBox">
    <keyword>WBox</keyword>
    <fullCommand>WBox X1,Y1,X2,Y2,Colour</fullCommand>
    <parameters>X1,Y1,X2,Y2,Colour</parameters>
    <shortDescription />
    <longDescription>WBox draws a solid rectangle in the currently used window.

The upper left hand coordinates of the box are specified with the Xl and Yl values,
and the bottom right hand corner of the box is specified by the values X2 and Y2.</longDescription>
  </command>
  <command name="WCircle">
    <keyword>WCircle</keyword>
    <fullCommand>WCircle X,Y,Radius,Colour</fullCommand>
    <parameters>X,Y,Radius,Colour</parameters>
    <shortDescription />
    <longDescription>WCircle allows you to draw a circle in the currently used window. You specify the
centre of the circle with the coordinates X,Y. The Radius value specifies the radius
of the circle you want to draw. The last value, Colour specifies what colour the
circle will be drawn in.</longDescription>
  </command>
  <command name="WEllipse">
    <keyword>WEllipse</keyword>
    <fullCommand>WEllipse X,Y,X Radius,Y Radius,Colour</fullCommand>
    <parameters>X,Y,X Radius,Y Radius,Colour</parameters>
    <shortDescription />
    <longDescription>WEllipse draws an ellipse in the currently used window. You specify the centre of
the ellipse with the coordinates X,Y. X Radius specifies the horizontal radius of
the ellipse, Y Radius the vertical radius.

Colour refers to the colour in which to draw the ellipse.</longDescription>
  </command>
  <command name="WCls">
    <keyword>WCls</keyword>
    <fullCommand>WCls [Colour]</fullCommand>
    <parameters>[Colour]</parameters>
    <shortDescription />
    <longDescription>WCls will clear the currently used window to colour 0, or a colour is specified,
then it will be cleared to this colour. If the current window was not opened with
the GIMMEZEROZERO flag set, then this statement will clear any border or title bar
that the window has. The InnerCls statement should be used to avoid these side
effects..</longDescription>
  </command>
  <command name="WLocate">
    <keyword>WLocate</keyword>
    <fullCommand>WLocate Cursor x,Cursor y</fullCommand>
    <parameters>Cursor x,Cursor y</parameters>
    <shortDescription />
    <longDescription>WLocate is used to set the text cursor position within the currently used window. X
and Y are both specified in pixels as offsets from the top left of the window. Each
window has it's own text cursor position, therefore changing the text cursor
position of one window will not affect any other window's text cursor position.</longDescription>
  </command>
  <command name="WindowInput">
    <keyword>WindowInput</keyword>
    <fullCommand>WindowInput Window#</fullCommand>
    <parameters>Window#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WindowOutput">
    <keyword>WindowOutput</keyword>
    <fullCommand>WindowOutput Window#</fullCommand>
    <parameters>Window#</parameters>
    <shortDescription />
    <longDescription>WindowOutput will cause any future executions of either the Print or NPrint
statements to send their output as text to the specified window object.

WindowOutput is automatically executed when either a window is opened, or Use Window
is executed.

After a window is closed (using Free Window), remember to send output somewhere else
useful (for example, using another WindowOutput command) before executing another
Print or NPrint statement.</longDescription>
  </command>
  <command name="Qualifier">
    <keyword>Qualifier</keyword>
    <fullCommand>Qualifier</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>Qualifier will return the qualifier of the last key that caused a 'key press' event
to occur. A qualifier is a key which alters the meaning of other keys; for example
the 'shift' keys. Here is a table of qualifier values and their equivalent keys:

Key             Left    Right 

UnQualified     $8000   $8000
Shift           $8001   $8002
Caps Lock Down  $8004   $8004
Control         $8008   $8008
Alternate       $8010   $8020
Amiga           $8040   $8080

A combination of values may occur, if more that one qualifier key is being held
down. The way to filter out the qualifiers that you want is by using the logical AND
operator.</longDescription>
  </command>
  <command name="RawKey">
    <keyword>RawKey</keyword>
    <fullCommand>RawKey</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>RawKey returns the raw key code of a key that caused the most recent 'key press'
evens.</longDescription>
  </command>
  <command name="Cursor">
    <keyword>Cursor</keyword>
    <fullCommand>Cursor Thickness : &lt;0 - block, &gt;=0</fullCommand>
    <parameters>Thickness : &lt;0 - block, &gt;=0</parameters>
    <shortDescription>underline thickness.</shortDescription>
    <longDescription>Cursor will set the style of cursor that appears when editing strings or numbers
with the Edit$ or Edit functions. If Thickness is less than 0, then a block cursor
will be used. If the Thickness is greater then 0, then an underline Thickness pixels
high will be used.</longDescription>
  </command>
  <command name="Editat">
    <keyword>Editat</keyword>
    <fullCommand>Editat</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>After executing an Edit$ or Edit function, Editat may be used to determine the
horizontal character position of the cursor at the time the function was exited.

Through the use of Editat, EditExit, EditFrom and Edit$, simple full screen editors
may be put together.</longDescription>
  </command>
  <command name="EditFrom">
    <keyword>EditFrom</keyword>
    <fullCommand>EditFrom [Characterpos]</fullCommand>
    <parameters>[Characterpos]</parameters>
    <shortDescription />
    <longDescription>EditFrom allows you to control how the Edit$ and Edit functions operate when used
within windows.

If a Characterpos parameter is specified, then the next time an edit function is
executed, editing will commence at the specified character position (0 being the
first character position).

Also, editing may be terminated not just by the use of the 'return' key, but also by
any non printable character (for example, 'up arrow' or 'Esc') or a window event.
When used in conjunction with Editat and EditExit, this allows you to put together
simple full screen editors.

If Characterpos is omitted, Edit$ and Edit return to normal - editing always
beginning at character postition 0, and 'return' being the only way to exit.</longDescription>
  </command>
  <command name="EditExit">
    <keyword>EditExit</keyword>
    <fullCommand>EditExit</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>EditExit returns the ASCII value of the character that was used to exit a window
based Edit$ or Edit function. You can only exit the edit functions with keypresses
other than 'return' if EditFrom has been executed prior to the edit call.</longDescription>
  </command>
  <command name="WScroll">
    <keyword>WScroll</keyword>
    <fullCommand>WScroll X1,Y1,X2,Y2,Delta X,Delta Y[,colour]</fullCommand>
    <parameters>X1,Y1,X2,Y2,Delta X,Delta Y[,colour]</parameters>
    <shortDescription />
    <longDescription>WScroll will cause a rectangular area of the currently used window to be moved or
'scrolled'. X1 and Y1 specify the top left location of the rectangle, X2 and Y2 the
bottom right. The Delta parameters determine how far to move the area. Positive
values move the area right/down, while negative values move the area left/up.</longDescription>
  </command>
  <command name="WMouseX">
    <keyword>WMouseX</keyword>
    <fullCommand>WMouseX</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>WMouseX returns the horizontal x coordinate of the mouse relative to the left edge
of the current window. If the current window was opened without the GIMMEZEROZERO
flag set, then the left edge is taken as the left edge of the border around the
window, otherwise, if GIMMEZEROZERO was set, then the left edge is the taken from
inside the window border.</longDescription>
  </command>
  <command name="WMouseY">
    <keyword>WMouseY</keyword>
    <fullCommand>WMouseY</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>WMouseY returns the vertical y coordinate of the mouse relative to the top of the
current window. If the current window was opened without the GIMMEZEROZERO flag set,
then the top is taken as the top of the border around the window, otherwise, if
GIMMEZEROZERO was set, then the top is taken trom inside the window border.</longDescription>
  </command>
  <command name="WColour">
    <keyword>WColour</keyword>
    <fullCommand>WColour Foreground Colour[,Background Colour]</fullCommand>
    <parameters>Foreground Colour[,Background Colour]</parameters>
    <shortDescription />
    <longDescription>WColour sets the foreground and background colour of printed text for the currently
used window. Any further text printed on this window will be in these colours.</longDescription>
  </command>
  <command name="WJam">
    <keyword>WJam</keyword>
    <fullCommand>WJam Jammode</fullCommand>
    <parameters>Jammode</parameters>
    <shortDescription />
    <longDescription>WJam sets the text drawing mode of the currently used window. These drawing modes
allow you to do inverted, complemented and other types of graphics. The drawing
modes can be OR'ed together to create a combination of them.

Jam1=0 

This draws only the foreground colour and leaves the background transparent. Eg For
the letter 0, any empty space (inside and outside the letter) will be transparent.

Jam2=1 

This draws both the foreground and background to the window. Eg With the letter 0
again, the 0 will be drawn, but any clear area (inside and outside) will be drawn in
the current background colour.

Complement=2 

This will exlusive or (XOR) the bits of the graphics.

Inversvid=4 

This allows the display of inverse video characters. If used in conjunction with
Jam2, it behaves like Jam2, but the foreground and background colours are exchanged.</longDescription>
  </command>
  <command name="Wline">
    <keyword>Wline</keyword>
    <fullCommand>Wline X1,Y1,X2,Y3[,Xn,Yn...],Colour</fullCommand>
    <parameters>X1,Y1,X2,Y3[,Xn,Yn...],Colour</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Activate">
    <keyword>Activate</keyword>
    <fullCommand>Activate Window#</fullCommand>
    <parameters>Window#</parameters>
    <shortDescription />
    <longDescription>Activate will activate the window specified by Window#.</longDescription>
  </command>
  <command name="WindowX">
    <keyword>WindowX</keyword>
    <fullCommand>WindowX</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>WindowX returns the horizontal pixel location of the top left corner of the
currently used window, relative to the screen the window appears in.</longDescription>
  </command>
  <command name="WindowY">
    <keyword>WindowY</keyword>
    <fullCommand>WindowY</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>WindowY returns the vertical pixel location of the top left corner of the currently
used window, relative to the screen the window appears in.</longDescription>
  </command>
  <command name="MButtons">
    <keyword>MButtons</keyword>
    <fullCommand>MButtons</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>MButtons returns the codes for the mouse buttons that caused the most recent 'mouse
buttons' event.

If menus have been turned off using Menus Off, then the right mouse button will also
register an event and can be read with MButtons.</longDescription>
  </command>
  <command name="Menus">
    <keyword>Menus</keyword>
    <fullCommand>Menus On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription>The Menus command may be used to turn ALL menus either on or off. Turning menus off
may be useful if you wish to read the right mouse button.</longDescription>
  </command>
  <command name="WCursX">
    <keyword>WCursX</keyword>
    <fullCommand>WCursX</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>WCursX returns the horizontal location of the text cursor of the currently used
window. The text cursor position may be set using WLocate.</longDescription>
  </command>
  <command name="WCursY">
    <keyword>WCursY</keyword>
    <fullCommand>WCursY</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>WCursY returns the vertical location of the text cursor of the currently used
window. The text cursor position may be set using WLocate.</longDescription>
  </command>
  <command name="WPointer">
    <keyword>WPointer</keyword>
    <fullCommand>WPointer Shape#</fullCommand>
    <parameters>Shape#</parameters>
    <shortDescription />
    <longDescription>WPointer allows you to determine the mouse pointer imagery used in the currently
used window. Shape# specifies an initialized shape object the pointer is to take
it's appearance from, and must be of 2 bitplanes depth (4 colours).</longDescription>
  </command>
  <command name="MenusOn">
    <keyword>MenusOn</keyword>
    <fullCommand>MenusOn</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="MenusOff">
    <keyword>MenusOff</keyword>
    <fullCommand>MenusOff</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="WMove">
    <keyword>WMove</keyword>
    <fullCommand>WMove X,Y</fullCommand>
    <parameters>X,Y</parameters>
    <shortDescription />
    <longDescription>WMove will move the current window to screen position X,Y.</longDescription>
  </command>
  <command name="WSize">
    <keyword>WSize</keyword>
    <fullCommand>WSize Width,Height</fullCommand>
    <parameters>Width,Height</parameters>
    <shortDescription />
    <longDescription>WSize will alter the width and height of the current window to the values specified
by Width and Height.</longDescription>
  </command>
  <command name="WindowWidth">
    <keyword>WindowWidth</keyword>
    <fullCommand>WindowWidth</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>WindowWidth returns the pixel width of the currently used window.</longDescription>
  </command>
  <command name="WindowHeight">
    <keyword>WindowHeight</keyword>
    <fullCommand>WindowHeight</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>WindowHeight returns the pixel height of the currently used window.</longDescription>
  </command>
  <command name="InnerWidth">
    <keyword>InnerWidth</keyword>
    <fullCommand>InnerWidth</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>InnerWidth returns the pixel width of the area inside the border of the currently
used window.</longDescription>
  </command>
  <command name="InnerHeight">
    <keyword>InnerHeight</keyword>
    <fullCommand>InnerHeight</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>InnerHeight returns the pixel height of the area inside the border of the currently
used window.</longDescription>
  </command>
  <command name="InnerCls">
    <keyword>InnerCls</keyword>
    <fullCommand>InnerCls [Colour]</fullCommand>
    <parameters>[Colour]</parameters>
    <shortDescription />
    <longDescription>InnerCls will clear only the inner portion of the currently used window. It will not
clear the titlebar or borders as WCls would do if your window was not opened with
the GIMMEZEROZERO flag set. If a colour is specified, then that colour will be used
to clear the window.</longDescription>
  </command>
  <command name="WTopOff">
    <keyword>WTopOff</keyword>
    <fullCommand>WTopOff</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>WTopOff returns the number of pixels between the top of the current window border
and the inside of the window.</longDescription>
  </command>
  <command name="WLeftOff">
    <keyword>WLeftOff</keyword>
    <fullCommand>WLeftOff</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>WLeftOff returns the number of pixels between the left edge of the current window
border and the inside of the window.</longDescription>
  </command>
  <command name="SizeLimits">
    <keyword>SizeLimits</keyword>
    <fullCommand>SizeLimits Min Width,Min Height,Max Width,Max Height</fullCommand>
    <parameters>Min Width,Min Height,Max Width,Max Height</parameters>
    <shortDescription />
    <longDescription>SizeLimits sets the limits that any new windows can be sized to with the sizing
gadget. After calling this statement, any new windows will have these limits imposed
on them.</longDescription>
  </command>
  <command name="EMouseX">
    <keyword>EMouseX</keyword>
    <fullCommand>EMouseX</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>EMouseX will return the horizontal position of the mouse pointer at the time the
most recent window event occured. Window events are detected using the WaitEvent or
Event commands.</longDescription>
  </command>
  <command name="EMouseY">
    <keyword>EMouseY</keyword>
    <fullCommand>EMouseY</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>EMouseY will return the vertical position of the mouse pointer at the time the most
recent window event occured. Window events are detected using the WaitEvent or Event
commands.</longDescription>
  </command>
  <command name="AddIDCMP">
    <keyword>AddIDCMP</keyword>
    <fullCommand>AddIDCMP IDCMP_Flags</fullCommand>
    <parameters>IDCMP_Flags</parameters>
    <shortDescription />
    <longDescription>AddIDCMP allows you to 'add in' IDCMP flags to the IDCMP flags selected by
DefaultIDCMP. Please refer to DefaultIDCMP for a thorough discussion of IDCMP flags.</longDescription>
  </command>
  <command name="SubIDCMP">
    <keyword>SubIDCMP</keyword>
    <fullCommand>SubIDCMP IDCMP_Flags</fullCommand>
    <parameters>IDCMP_Flags</parameters>
    <shortDescription />
    <longDescription>SubIDCMP allows you to 'subtract out' IDCMP flags from the IDCMP flags selected by
DefaultIDCMP. Please refer to DefaultIDCMP for a thorough discussion of IDCMP flags.</longDescription>
  </command>
  <command name="FlushEvents">
    <keyword>FlushEvents</keyword>
    <fullCommand>FlushEvents [IDCMP_Flag]</fullCommand>
    <parameters>[IDCMP_Flag]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CatchDosErrs">
    <keyword>CatchDosErrs</keyword>
    <fullCommand>CatchDosErrs</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>Whenever you are executing AmigaDos I/O (for example, reading or writing a file),
there is always the possibility of something going wrong (for example, disk not
inserted... read/write error etc.).

Normally, when such problems occur, AmigaDos displays a suitable requester on the
WorkBench window. However, by executing CatchDosErrs you can force such requesters
to open on a Blitz window.

The window you wish dos error requesters to open on should be the currently used
window at the time CatchDosErrs is executed.</longDescription>
  </command>
  <command name="RastPort">
    <keyword>RastPort</keyword>
    <fullCommand>RastPort(Window#)</fullCommand>
    <parameters>(Window#)</parameters>
    <shortDescription />
    <longDescription>RastPort returns the specified Window's RastPort address. Many commands in the
graphics.library and the like require a RastPort as a parameter.</longDescription>
  </command>
  <command name="SetEventFilter">
    <keyword>SetEventFilter</keyword>
    <fullCommand>SetEventFilter preprocess,postprocess</fullCommand>
    <parameters>preprocess,postprocess</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WTitle">
    <keyword>WTitle</keyword>
    <fullCommand>WTitle windowtitle$[,screentitle$]</fullCommand>
    <parameters>windowtitle$[,screentitle$]</parameters>
    <shortDescription />
    <longDescription>WTitle is used to alter both the current window's title bar and it's screens title
bar. Useful for displaying important stats such as program status etc.</longDescription>
  </command>
  <command name="CloseWindow">
    <keyword>CloseWindow</keyword>
    <fullCommand>CloseWindow Window#</fullCommand>
    <parameters>Window#</parameters>
    <shortDescription />
    <longDescription>CloseWindow has been added for convenience. Same as Free Window but a little more
intuitive (added for those that have complained about such matters).</longDescription>
  </command>
  <command name="WPrintScroll">
    <keyword>WPrintScroll</keyword>
    <fullCommand>WPrintScroll</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>WPrintScroll will scroll the current window upwards if the text cursor is below the
bottom of the window and adjust the cursor accordingly. Presently WPrintScroll only
works with windows opened with the gimme00 flag set (#gimmezerozero=$400).</longDescription>
  </command>
  <command name="WBlit">
    <keyword>WBlit</keyword>
    <fullCommand>WBlit Shape#,x,y</fullCommand>
    <parameters>Shape#,x,y</parameters>
    <shortDescription />
    <longDescription>WBlit can be used to blit any shape to the current window. Completely system
friendly this command will completely clip the shape to fit inside the visible part
of the window Use GimmeZeroZero windows for clean clipping when the window has
title/sizing gadgets.</longDescription>
  </command>
  <command name="BitMaptoWindow">
    <keyword>BitMaptoWindow</keyword>
    <fullCommand>BitMaptoWindow Bitmap#,Window#[,srcx,srcy,destx,desty,wid,height]</fullCommand>
    <parameters>Bitmap#,Window#[,srcx,srcy,destx,desty,wid,height]</parameters>
    <shortDescription />
    <longDescription>BitMaptoWindow will copy a bitmap to a window in an operating system friendly manner
(what do you expect). The main use of such a command is for programs which use the
raw bitmap commands such as the 2D and Blit libraries for rendering bitmaps quickly
but require a windowing environment for the user interface.</longDescription>
  </command>
  <command name="EventCode">
    <keyword>EventCode</keyword>
    <fullCommand>EventCode</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>EventCode returns the actual code of the last Event received by your program,.</longDescription>
  </command>
  <command name="EventQualifier">
    <keyword>EventQualifier</keyword>
    <fullCommand>EventQualifier</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>EventQualifier returns the contents of the Qualifier field. Of use with the new
GadTools library and some other low level event handling requirements.</longDescription>
  </command>
  <command name="PositionSuperBitMap">
    <keyword>PositionSuperBitMap</keyword>
    <fullCommand>PositionSuperBitMap x,y</fullCommand>
    <parameters>x,y</parameters>
    <shortDescription />
    <longDescription>PositionSuperBitMap is used to display a certain area of the bitmap in a super
bitmap window.</longDescription>
  </command>
  <command name="GetSuperBitMap">
    <keyword>GetSuperBitMap</keyword>
    <fullCommand>GetSuperBitMap</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>After rendering changes to a superbitmap window the bitmap attached can also be
updated with the GetSuperBitMap. After rendering changes to a bitmap the superbitmap
window can be refreshed with the PutSuperBitMap command. Both commands work with the
currently used window.</longDescription>
  </command>
  <command name="PutSuperBitMap">
    <keyword>PutSuperBitMap</keyword>
    <fullCommand>PutSuperBitMap</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>See GetSuperBitmap description.</longDescription>
  </command>
  <command name="WindowTags">
    <keyword>WindowTags</keyword>
    <fullCommand>WindowTags Window#,Flags,Title$ [,&amp;TagList] or [[,Tag,Data]...]</fullCommand>
    <parameters>Window#,Flags,Title$ [,&amp;TagList] or [[,Tag,Data]...]</parameters>
    <shortDescription />
    <longDescription>Similar to ScreenTags, WindowTags allows the advanced user to open a Blitz window
with a list of OS Tags as described in the documentation for the operating system
prior to 2.0.</longDescription>
  </command>
  <command name="AddWaitEvent">
    <keyword>AddWaitEvent</keyword>
    <fullCommand>AddWaitEvent bitnumber,returncode.l</fullCommand>
    <parameters>bitnumber,returncode.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DelWaitEvent">
    <keyword>DelWaitEvent</keyword>
    <fullCommand>DelWaitEvent bitnumber</fullCommand>
    <parameters>bitnumber</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EventiAddress">
    <keyword>EventiAddress</keyword>
    <fullCommand>EventiAddress</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="WaitSigBits">
    <keyword>WaitSigBits</keyword>
    <fullCommand>WaitSigBits</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="LoadTrackerModule">
    <keyword>LoadTrackerModule</keyword>
    <fullCommand>LoadTrackerModule(TrackerModule#,Name)</fullCommand>
    <parameters>(TrackerModule#,Name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StartTracker">
    <keyword>StartTracker</keyword>
    <fullCommand>StartTracker(TrackerModule#)</fullCommand>
    <parameters>(TrackerModule#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StopTracker">
    <keyword>StopTracker</keyword>
    <fullCommand>StopTracker(Stops current playing module)</fullCommand>
    <parameters>(Stops current playing module)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DecodeModule">
    <keyword>DecodeModule</keyword>
    <fullCommand>DecodeModule TrackerModule#,ModuleAddress</fullCommand>
    <parameters>TrackerModule#,ModuleAddress</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetTrackerSize">
    <keyword>GetTrackerSize</keyword>
    <fullCommand>GetTrackerSize(TrackerModule#)</fullCommand>
    <parameters>(TrackerModule#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetTrackerLocation">
    <keyword>GetTrackerLocation</keyword>
    <fullCommand>GetTrackerLocation(TrackerModule#)</fullCommand>
    <parameters>(TrackerModule#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeTrackerModule">
    <keyword>FreeTrackerModule</keyword>
    <fullCommand>FreeTrackerModule TrackerModule#</fullCommand>
    <parameters>TrackerModule#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetTrackerEvent">
    <keyword>GetTrackerEvent</keyword>
    <fullCommand>GetTrackerEvent</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CheckTrackerEvent">
    <keyword>CheckTrackerEvent</keyword>
    <fullCommand>CheckTrackerEvent</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="WaitTrackerEvent">
    <keyword>WaitTrackerEvent</keyword>
    <fullCommand>WaitTrackerEvent</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CheckTrackerID">
    <keyword>CheckTrackerID</keyword>
    <fullCommand>CheckTrackerID(TrackerModule#)</fullCommand>
    <parameters>(TrackerModule#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ModuleToChip">
    <keyword>ModuleToChip</keyword>
    <fullCommand>ModuleToChip(TrackerModule#)</fullCommand>
    <parameters>(TrackerModule#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetModuleName$">
    <keyword>GetModuleName$</keyword>
    <fullCommand>GetModuleName$(TrackerModule#)</fullCommand>
    <parameters>(TrackerModule#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ModulePositionJump">
    <keyword>ModulePositionJump</keyword>
    <fullCommand>ModulePositionJump(Position#)</fullCommand>
    <parameters>(Position#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetModulePosition">
    <keyword>GetModulePosition</keyword>
    <fullCommand>GetModulePosition</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="PauseModule">
    <keyword>PauseModule</keyword>
    <fullCommand>PauseModule</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChangeTrackerVBlank">
    <keyword>ChangeTrackerVBlank</keyword>
    <fullCommand>ChangeTrackerVBlank</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="PlayTracker">
    <keyword>PlayTracker</keyword>
    <fullCommand>PlayTracker</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="TrackerVolume">
    <keyword>TrackerVolume</keyword>
    <fullCommand>TrackerVolume Volume Range: 0-64</fullCommand>
    <parameters>Volume Range: 0-64</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChangeTrackerMask">
    <keyword>ChangeTrackerMask</keyword>
    <fullCommand>ChangeTrackerMask Channel_Mask</fullCommand>
    <parameters>Channel_Mask</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ModulePatterns">
    <keyword>ModulePatterns</keyword>
    <fullCommand>ModulePatterns(Module #)</fullCommand>
    <parameters>(Module #)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EasyRequest">
    <keyword>EasyRequest</keyword>
    <fullCommand>EasyRequest Result=EasyRequest([#Window,]title$,body$,gtext$)</fullCommand>
    <parameters>Result=EasyRequest([#Window,]title$,body$,gtext$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PrtText">
    <keyword>PrtText</keyword>
    <fullCommand>PrtText String</fullCommand>
    <parameters>String</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Hardcopy">
    <keyword>Hardcopy</keyword>
    <fullCommand>Hardcopy Screen#,X,Y,Width,Height,PtrWidth,PrtHeight,Flags</fullCommand>
    <parameters>Screen#,X,Y,Width,Height,PtrWidth,PrtHeight,Flags</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PrtCommand">
    <keyword>PrtCommand</keyword>
    <fullCommand>PrtCommand Command,Para1,Para2,Para3,Para4</fullCommand>
    <parameters>Command,Para1,Para2,Para3,Para4</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CheckPrt">
    <keyword>CheckPrt</keyword>
    <fullCommand>CheckPrt -1=Printer Off|-3=Printer Offline|-4=Printer On</fullCommand>
    <parameters>-1=Printer Off|-3=Printer Offline|-4=Printer On</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsLocale">
    <keyword>IsLocale</keyword>
    <fullCommand>IsLocale &lt;&gt;0 if locale exists</fullCommand>
    <parameters>&lt;&gt;0 if locale exists</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UseCatalog">
    <keyword>UseCatalog</keyword>
    <fullCommand>UseCatalog Catalogname</fullCommand>
    <parameters>Catalogname</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeCatalog">
    <keyword>FreeCatalog</keyword>
    <fullCommand>FreeCatalog</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetLocaleStr">
    <keyword>GetLocaleStr</keyword>
    <fullCommand>GetLocaleStr(#StringNumber,DefaultString$)</fullCommand>
    <parameters>(#StringNumber,DefaultString$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenConsole">
    <keyword>OpenConsole</keyword>
    <fullCommand>OpenConsole #Window,#Console</fullCommand>
    <parameters>#Window,#Console</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PrintCon">
    <keyword>PrintCon</keyword>
    <fullCommand>PrintCon Console#,Expression</fullCommand>
    <parameters>Console#,Expression</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NPrintCon">
    <keyword>NPrintCon</keyword>
    <fullCommand>NPrintCon Console#,Expression</fullCommand>
    <parameters>Console#,Expression</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseConsole">
    <keyword>CloseConsole</keyword>
    <fullCommand>CloseConsole Console#</fullCommand>
    <parameters>Console#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ZoneInit">
    <keyword>ZoneInit</keyword>
    <fullCommand>ZoneInit [zone_num#]|[#start_num,#end_num]</fullCommand>
    <parameters>[zone_num#]|[#start_num,#end_num]</parameters>
    <shortDescription>intialize zones.</shortDescription>
    <longDescription />
  </command>
  <command name="SetZone">
    <keyword>SetZone</keyword>
    <fullCommand>SetZone num,x1,y1[,x2,y2]|[,radius]</fullCommand>
    <parameters>num,x1,y1[,x2,y2]|[,radius]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Zone">
    <keyword>Zone</keyword>
    <fullCommand>Zone(x,y)</fullCommand>
    <parameters>(x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ZoneTest">
    <keyword>ZoneTest</keyword>
    <fullCommand>ZoneTest(start_num[,end_num],x,y)</fullCommand>
    <parameters>(start_num[,end_num],x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ZoneTable">
    <keyword>ZoneTable</keyword>
    <fullCommand>ZoneTable</fullCommand>
    <parameters />
    <shortDescription>returns address of the current zone table.</shortDescription>
    <longDescription />
  </command>
  <command name="JFire">
    <keyword>JFire</keyword>
    <fullCommand>JFire(port)</fullCommand>
    <parameters>(port)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="JVert">
    <keyword>JVert</keyword>
    <fullCommand>JVert(port)</fullCommand>
    <parameters>(port)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="JHoriz">
    <keyword>JHoriz</keyword>
    <fullCommand>JHoriz(port)</fullCommand>
    <parameters>(port)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllFire">
    <keyword>AllFire</keyword>
    <fullCommand>AllFire([joybits])</fullCommand>
    <parameters>([joybits])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ZoneTableSize">
    <keyword>ZoneTableSize</keyword>
    <fullCommand>ZoneTableSize</fullCommand>
    <parameters />
    <shortDescription>returns size of the current zone table.</shortDescription>
    <longDescription />
  </command>
  <command name="NewZoneTable">
    <keyword>NewZoneTable</keyword>
    <fullCommand>NewZoneTable table#,num_zones</fullCommand>
    <parameters>table#,num_zones</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UseZoneTable">
    <keyword>UseZoneTable</keyword>
    <fullCommand>UseZoneTable</fullCommand>
    <parameters />
    <shortDescription>- select a zone table for use.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeZoneTable">
    <keyword>FreeZoneTable</keyword>
    <fullCommand>FreeZoneTable table#</fullCommand>
    <parameters>table#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ZoneTableNumber">
    <keyword>ZoneTableNumber</keyword>
    <fullCommand>ZoneTableNumber</fullCommand>
    <parameters />
    <shortDescription>returns the number of the current zone table.</shortDescription>
    <longDescription />
  </command>
  <command name="ZoneMode">
    <keyword>ZoneMode</keyword>
    <fullCommand>ZoneMode</fullCommand>
    <parameters />
    <shortDescription>- returns -1 for 68020 mode or 0 for 68000 mode.</shortDescription>
    <longDescription />
  </command>
  <command name="SetZoneMode">
    <keyword>SetZoneMode</keyword>
    <fullCommand>SetZoneMode mode</fullCommand>
    <parameters>mode</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="JAdaptorStatus">
    <keyword>JAdaptorStatus</keyword>
    <fullCommand>JAdaptorStatus On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>status of four player adaptor reading.</shortDescription>
    <longDescription />
  </command>
  <command name="GetZoneX1">
    <keyword>GetZoneX1</keyword>
    <fullCommand>GetZoneX1(zone)</fullCommand>
    <parameters>(zone)</parameters>
    <shortDescription>returns the start x pos of a zone.</shortDescription>
    <longDescription />
  </command>
  <command name="GetZoneY1">
    <keyword>GetZoneY1</keyword>
    <fullCommand>GetZoneY1(zone)</fullCommand>
    <parameters>(zone)</parameters>
    <shortDescription>returns the start y pos of a zone.</shortDescription>
    <longDescription />
  </command>
  <command name="GetZoneX2">
    <keyword>GetZoneX2</keyword>
    <fullCommand>GetZoneX2(zone)</fullCommand>
    <parameters>(zone)</parameters>
    <shortDescription>returns the end x pos of a zone.</shortDescription>
    <longDescription />
  </command>
  <command name="GetZoneY2">
    <keyword>GetZoneY2</keyword>
    <fullCommand>GetZoneY2(zone)</fullCommand>
    <parameters>(zone)</parameters>
    <shortDescription>returns the end pos of a zone.</shortDescription>
    <longDescription />
  </command>
  <command name="ReadJoyPad">
    <keyword>ReadJoyPad</keyword>
    <fullCommand>ReadJoyPad port#      --B,R,Y,G,FF,RW,PL,0</fullCommand>
    <parameters>port#      --B,R,Y,G,FF,RW,PL,0</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenDisk">
    <keyword>OpenDisk</keyword>
    <fullCommand>OpenDisk unit#[,devicename$]</fullCommand>
    <parameters>unit#[,devicename$]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MotorOn">
    <keyword>MotorOn</keyword>
    <fullCommand>MotorOn unit#</fullCommand>
    <parameters>unit#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseDisk">
    <keyword>CloseDisk</keyword>
    <fullCommand>CloseDisk unit#</fullCommand>
    <parameters>unit#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadSector">
    <keyword>ReadSector</keyword>
    <fullCommand>ReadSector unit#,sector#,buffer[,numsectors]</fullCommand>
    <parameters>unit#,sector#,buffer[,numsectors]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MotorOff">
    <keyword>MotorOff</keyword>
    <fullCommand>MotorOff unit#</fullCommand>
    <parameters>unit#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WriteSector">
    <keyword>WriteSector</keyword>
    <fullCommand>WriteSector unit#,sector#,buffer[,numsectors]</fullCommand>
    <parameters>unit#,sector#,buffer[,numsectors]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FormatTrack">
    <keyword>FormatTrack</keyword>
    <fullCommand>FormatTrack unit#,track#,buffer[,numtracks]</fullCommand>
    <parameters>unit#,track#,buffer[,numtracks]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WriteBoot">
    <keyword>WriteBoot</keyword>
    <fullCommand>WriteBoot unit#[,bootdata]</fullCommand>
    <parameters>unit#[,bootdata]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DiskStatus">
    <keyword>DiskStatus</keyword>
    <fullCommand>DiskStatus unit#</fullCommand>
    <parameters>unit#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DiskIO">
    <keyword>DiskIO</keyword>
    <fullCommand>DiskIO unit#</fullCommand>
    <parameters>unit#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BootProg">
    <keyword>BootProg</keyword>
    <fullCommand>BootProg unit#,memoryaddress</fullCommand>
    <parameters>unit#,memoryaddress</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DiskMotor">
    <keyword>DiskMotor</keyword>
    <fullCommand>DiskMotor</fullCommand>
    <parameters />
    <shortDescription>; Returns -1 if motor is on.</shortDescription>
    <longDescription />
  </command>
  <command name="GetIconObject">
    <keyword>GetIconObject</keyword>
    <fullCommand>GetIconObject(filename$)</fullCommand>
    <parameters>(filename$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindToolValue">
    <keyword>FindToolValue</keyword>
    <fullCommand>FindToolValue(tooltype$)</fullCommand>
    <parameters>(tooltype$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetToolValue">
    <keyword>SetToolValue</keyword>
    <fullCommand>SetToolValue(tooltype$,value$[,status])</fullCommand>
    <parameters>(tooltype$,value$[,status])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PutIconObject">
    <keyword>PutIconObject</keyword>
    <fullCommand>PutIconObject(filename$[,icontype])</fullCommand>
    <parameters>(filename$[,icontype])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeIconObject">
    <keyword>FreeIconObject</keyword>
    <fullCommand>FreeIconObject</fullCommand>
    <parameters />
    <shortDescription>- free the disk object of a icon.</shortDescription>
    <longDescription />
  </command>
  <command name="MatchToolValue">
    <keyword>MatchToolValue</keyword>
    <fullCommand>MatchToolValue(tooltype$,value$)</fullCommand>
    <parameters>(tooltype$,value$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NewToolType">
    <keyword>NewToolType</keyword>
    <fullCommand>NewToolType(tooltype$,value$[,status])</fullCommand>
    <parameters>(tooltype$,value$[,status])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindToolNumber">
    <keyword>FindToolNumber</keyword>
    <fullCommand>FindToolNumber(tooltype#)</fullCommand>
    <parameters>(tooltype#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClearToolTypes">
    <keyword>ClearToolTypes</keyword>
    <fullCommand>ClearToolTypes</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetIconHit">
    <keyword>SetIconHit</keyword>
    <fullCommand>SetIconHit width,height</fullCommand>
    <parameters>width,height</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ShapeToIcon">
    <keyword>ShapeToIcon</keyword>
    <fullCommand>ShapeToIcon shape[,shape]</fullCommand>
    <parameters>shape[,shape]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetIconType">
    <keyword>SetIconType</keyword>
    <fullCommand>SetIconType object_type</fullCommand>
    <parameters>object_type</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IconRender">
    <keyword>IconRender</keyword>
    <fullCommand>IconRender render_flags</fullCommand>
    <parameters>render_flags</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IconDefTool">
    <keyword>IconDefTool</keyword>
    <fullCommand>IconDefTool tool$</fullCommand>
    <parameters>tool$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindToolType">
    <keyword>FindToolType</keyword>
    <fullCommand>FindToolType(tooltype$[,bracket_check])</fullCommand>
    <parameters>(tooltype$[,bracket_check])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IconToShape">
    <keyword>IconToShape</keyword>
    <fullCommand>IconToShape shape[,shape]</fullCommand>
    <parameters>shape[,shape]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StringSort">
    <keyword>StringSort</keyword>
    <fullCommand>StringSort list,sizeof.type[,offset]</fullCommand>
    <parameters>list,sizeof.type[,offset]</parameters>
    <shortDescription>sort from start of list.</shortDescription>
    <longDescription />
  </command>
  <command name="ListBase">
    <keyword>ListBase</keyword>
    <fullCommand>ListBase(list)</fullCommand>
    <parameters>(list)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StringSortItem">
    <keyword>StringSortItem</keyword>
    <fullCommand>StringSortItem list,sizeof.type[,offset]</fullCommand>
    <parameters>list,sizeof.type[,offset]</parameters>
    <shortDescription>sort from current list item.</shortDescription>
    <longDescription />
  </command>
  <command name="StringSortDir">
    <keyword>StringSortDir</keyword>
    <fullCommand>StringSortDir direction</fullCommand>
    <parameters>direction</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReqFileRequest">
    <keyword>ReqFileRequest</keyword>
    <fullCommand>ReqFileRequest([title$][,flags])</fullCommand>
    <parameters>([title$][,flags])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReqFileLoc">
    <keyword>ReqFileLoc</keyword>
    <fullCommand>ReqFileLoc</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReqOutput">
    <keyword>ReqOutput</keyword>
    <fullCommand>ReqOutput windowptr</fullCommand>
    <parameters>windowptr</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReqFlags">
    <keyword>ReqFlags</keyword>
    <fullCommand>ReqFlags flags</fullCommand>
    <parameters>flags</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReqColour">
    <keyword>ReqColour</keyword>
    <fullCommand>ReqColour(colour)</fullCommand>
    <parameters>(colour)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PackPBM">
    <keyword>PackPBM</keyword>
    <fullCommand>PackPBM sourceaddr,destaddr,length</fullCommand>
    <parameters>sourceaddr,destaddr,length</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnpackIFF">
    <keyword>UnpackIFF</keyword>
    <fullCommand>UnpackIFF(sourceaddr,bitmap#[,numlines,xy_offset])</fullCommand>
    <parameters>(sourceaddr,bitmap#[,numlines,xy_offset])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ILBMPalette">
    <keyword>ILBMPalette</keyword>
    <fullCommand>ILBMPalette(sourceaddr,palette#[,#offset)</fullCommand>
    <parameters>(sourceaddr,palette#[,#offset)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ILBMGrab">
    <keyword>ILBMGrab</keyword>
    <fullCommand>ILBMGrab sourceaddr,bitmap#,palette#</fullCommand>
    <parameters>sourceaddr,bitmap#,palette#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LoadIFF">
    <keyword>LoadIFF</keyword>
    <fullCommand>LoadIFF(filename$,bitmap[,palette])</fullCommand>
    <parameters>(filename$,bitmap[,palette])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChunkHeader">
    <keyword>ChunkHeader</keyword>
    <fullCommand>ChunkHeader(a$)</fullCommand>
    <parameters>(a$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnPackPBM">
    <keyword>UnPackPBM</keyword>
    <fullCommand>UnPackPBM sourceaddr,destaddr,length</fullCommand>
    <parameters>sourceaddr,destaddr,length</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IFFDepth">
    <keyword>IFFDepth</keyword>
    <fullCommand>IFFDepth address -</fullCommand>
    <parameters>address -</parameters>
    <shortDescription>address of your ILBM IFF file.</shortDescription>
    <longDescription />
  </command>
  <command name="IFFWidth">
    <keyword>IFFWidth</keyword>
    <fullCommand>IFFWidth address -</fullCommand>
    <parameters>address -</parameters>
    <shortDescription>address of your ILBM IFF file.</shortDescription>
    <longDescription />
  </command>
  <command name="IFFHeight">
    <keyword>IFFHeight</keyword>
    <fullCommand>IFFHeight address -</fullCommand>
    <parameters>address -</parameters>
    <shortDescription>address of your ILBM IFF file.</shortDescription>
    <longDescription />
  </command>
  <command name="IFFViewmode">
    <keyword>IFFViewmode</keyword>
    <fullCommand>IFFViewmode address -</fullCommand>
    <parameters>address -</parameters>
    <shortDescription>address of your ILBM IFF file.</shortDescription>
    <longDescription />
  </command>
  <command name="InitList">
    <keyword>InitList</keyword>
    <fullCommand>InitList list#,var</fullCommand>
    <parameters>list#,var</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddListItem">
    <keyword>AddListItem</keyword>
    <fullCommand>AddListItem list#</fullCommand>
    <parameters>list#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetListItem">
    <keyword>SetListItem</keyword>
    <fullCommand>SetListItem list#,var</fullCommand>
    <parameters>list#,var</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NextListItem">
    <keyword>NextListItem</keyword>
    <fullCommand>NextListItem list#</fullCommand>
    <parameters>list#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetListItem">
    <keyword>GetListItem</keyword>
    <fullCommand>GetListItem list#,var</fullCommand>
    <parameters>list#,var</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PrevListItem">
    <keyword>PrevListItem</keyword>
    <fullCommand>PrevListItem list#</fullCommand>
    <parameters>list#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FirstListItem">
    <keyword>FirstListItem</keyword>
    <fullCommand>FirstListItem list#</fullCommand>
    <parameters>list#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LastListItem">
    <keyword>LastListItem</keyword>
    <fullCommand>LastListItem list#</fullCommand>
    <parameters>list#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddFirstListItem">
    <keyword>AddFirstListItem</keyword>
    <fullCommand>AddFirstListItem list#</fullCommand>
    <parameters>list#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddLastListItem">
    <keyword>AddLastListItem</keyword>
    <fullCommand>AddLastListItem list#</fullCommand>
    <parameters>list#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DelListItem">
    <keyword>DelListItem</keyword>
    <fullCommand>DelListItem list#</fullCommand>
    <parameters>list#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddrListItem">
    <keyword>AddrListItem</keyword>
    <fullCommand>AddrListItem list#</fullCommand>
    <parameters>list#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PalRed">
    <keyword>PalRed</keyword>
    <fullCommand>PalRed(colour#)</fullCommand>
    <parameters>(colour#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PalGreen">
    <keyword>PalGreen</keyword>
    <fullCommand>PalGreen(colour#)</fullCommand>
    <parameters>(colour#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PalBlue">
    <keyword>PalBlue</keyword>
    <fullCommand>PalBlue(colour#)</fullCommand>
    <parameters>(colour#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PaletteInfo">
    <keyword>PaletteInfo</keyword>
    <fullCommand>PaletteInfo palette#</fullCommand>
    <parameters>palette#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AGAPalRed">
    <keyword>AGAPalRed</keyword>
    <fullCommand>AGAPalRed(colour#)</fullCommand>
    <parameters>(colour#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AGAPalGreen">
    <keyword>AGAPalGreen</keyword>
    <fullCommand>AGAPalGreen(colour#)</fullCommand>
    <parameters>(colour#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AGAPalBlue">
    <keyword>AGAPalBlue</keyword>
    <fullCommand>AGAPalBlue(colour#)</fullCommand>
    <parameters>(colour#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PalAdjust">
    <keyword>PalAdjust</keyword>
    <fullCommand>PalAdjust palette#,ratio.q[,start_col,end_col]</fullCommand>
    <parameters>palette#,ratio.q[,start_col,end_col]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FillPalette">
    <keyword>FillPalette</keyword>
    <fullCommand>FillPalette palette#,r,g,b[,start_col,end_col]</fullCommand>
    <parameters>palette#,r,g,b[,start_col,end_col]</parameters>
    <shortDescription>fill palette with r,g,b values.</shortDescription>
    <longDescription />
  </command>
  <command name="AGAFillPalette">
    <keyword>AGAFillPalette</keyword>
    <fullCommand>AGAFillPalette palette#,r,g,b[,start_col,end_col]</fullCommand>
    <parameters>palette#,r,g,b[,start_col,end_col]</parameters>
    <shortDescription>fill palette with AGA r,g,b values.</shortDescription>
    <longDescription />
  </command>
  <command name="CopyColour">
    <keyword>CopyColour</keyword>
    <fullCommand>CopyColour sourcepal#,destpal#,colsource#,coldest#</fullCommand>
    <parameters>sourcepal#,destpal#,colsource#,coldest#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CPUCls">
    <keyword>CPUCls</keyword>
    <fullCommand>CPUCls bitmap#</fullCommand>
    <parameters>bitmap#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SaveCMAP">
    <keyword>SaveCMAP</keyword>
    <fullCommand>SaveCMAP palette#,filename$</fullCommand>
    <parameters>palette#,filename$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MergeBitplanes">
    <keyword>MergeBitplanes</keyword>
    <fullCommand>MergeBitplanes srcbitmap,srcbitmap,destbitmap,numplanes</fullCommand>
    <parameters>srcbitmap,srcbitmap,destbitmap,numplanes</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClearBitmap">
    <keyword>ClearBitmap</keyword>
    <fullCommand>ClearBitmap bitmap#,delay[,height,offset]</fullCommand>
    <parameters>bitmap#,delay[,height,offset]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FadeInBitmap">
    <keyword>FadeInBitmap</keyword>
    <fullCommand>FadeInBitmap bitmapsource#,bitmapdest#,delay[,height,offset1,offset2]</fullCommand>
    <parameters>bitmapsource#,bitmapdest#,delay[,height,offset1,offset2]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ZoomX4">
    <keyword>ZoomX4</keyword>
    <fullCommand>ZoomX4 source#,dest#,sourceadd,destadd,width,height[,xy_select]</fullCommand>
    <parameters>source#,dest#,sourceadd,destadd,width,height[,xy_select]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Derez">
    <keyword>Derez</keyword>
    <fullCommand>Derez source#,dest#,sourceadd,destadd,derez_value,height</fullCommand>
    <parameters>source#,dest#,sourceadd,destadd,derez_value,height</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ZoomXY">
    <keyword>ZoomXY</keyword>
    <fullCommand>ZoomXY xzoom,yzoom,height</fullCommand>
    <parameters>xzoom,yzoom,height</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitZoomXY">
    <keyword>InitZoomXY</keyword>
    <fullCommand>InitZoomXY source#,dest#,sourceadd,destadd</fullCommand>
    <parameters>source#,dest#,sourceadd,destadd</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ZoomX2">
    <keyword>ZoomX2</keyword>
    <fullCommand>ZoomX2 source#,dest#,sourceadd,destadd,width,height</fullCommand>
    <parameters>source#,dest#,sourceadd,destadd,width,height</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetZoomTables">
    <keyword>GetZoomTables</keyword>
    <fullCommand>GetZoomTables</fullCommand>
    <parameters />
    <shortDescription>return pointer to array of tables.</shortDescription>
    <longDescription />
  </command>
  <command name="ZoomX8">
    <keyword>ZoomX8</keyword>
    <fullCommand>ZoomX8 source#,dest#,sourceadd,destadd,width,height</fullCommand>
    <parameters>source#,dest#,sourceadd,destadd,width,height</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ADDValue">
    <keyword>ADDValue</keyword>
    <fullCommand>ADDValue(bitmap#,x,y)</fullCommand>
    <parameters>(bitmap#,x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReduceX2">
    <keyword>ReduceX2</keyword>
    <fullCommand>ReduceX2 source#,dest#,sourceadd,destadd,width,height</fullCommand>
    <parameters>source#,dest#,sourceadd,destadd,width,height</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ZoomyZoom">
    <keyword>ZoomyZoom</keyword>
    <fullCommand>ZoomyZoom bitmap#</fullCommand>
    <parameters>bitmap#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSPrint">
    <keyword>FNSPrint</keyword>
    <fullCommand>FNSPrint fontnum,x,y,a$/string_address[,prefs,colour]</fullCommand>
    <parameters>fontnum,x,y,a$/string_address[,prefs,colour]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InstallFNS">
    <keyword>InstallFNS</keyword>
    <fullCommand>InstallFNS(fontnum,address)</fullCommand>
    <parameters>(fontnum,address)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSOutput">
    <keyword>FNSOutput</keyword>
    <fullCommand>FNSOutput bitmap[,clip_update (On|Off)]</fullCommand>
    <parameters>bitmap[,clip_update (On|Off)]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSInk">
    <keyword>FNSInk</keyword>
    <fullCommand>FNSInk colour</fullCommand>
    <parameters>colour</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSPrefs">
    <keyword>FNSPrefs</keyword>
    <fullCommand>FNSPrefs prefs[,colour]</fullCommand>
    <parameters>prefs[,colour]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSHeight">
    <keyword>FNSHeight</keyword>
    <fullCommand>FNSHeight(fontnum)</fullCommand>
    <parameters>(fontnum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSClip">
    <keyword>FNSClip</keyword>
    <fullCommand>FNSClip xmin,ymin,xmax,ymax</fullCommand>
    <parameters>xmin,ymin,xmax,ymax</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSClipOutput">
    <keyword>FNSClipOutput</keyword>
    <fullCommand>FNSClipOutput</fullCommand>
    <parameters />
    <shortDescription>set clipping zone to output bitmap size.</shortDescription>
    <longDescription />
  </command>
  <command name="RemoveFNS">
    <keyword>RemoveFNS</keyword>
    <fullCommand>RemoveFNS fontnum</fullCommand>
    <parameters>fontnum</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSUnderline">
    <keyword>FNSUnderline</keyword>
    <fullCommand>FNSUnderline(fontnum)</fullCommand>
    <parameters>(fontnum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSLength">
    <keyword>FNSLength</keyword>
    <fullCommand>FNSLength(fontnum,a$[,prefs])</fullCommand>
    <parameters>(fontnum,a$[,prefs])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSVersion">
    <keyword>FNSVersion</keyword>
    <fullCommand>FNSVersion</fullCommand>
    <parameters />
    <shortDescription>returns quick, lastest version=1.1.</shortDescription>
    <longDescription />
  </command>
  <command name="FNSOrigin">
    <keyword>FNSOrigin</keyword>
    <fullCommand>FNSOrigin [x,y]</fullCommand>
    <parameters>[x,y]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSWidth">
    <keyword>FNSWidth</keyword>
    <fullCommand>FNSWidth(fontnum)</fullCommand>
    <parameters>(fontnum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSLoad">
    <keyword>FNSLoad</keyword>
    <fullCommand>FNSLoad(fontname$,fontslot)</fullCommand>
    <parameters>(fontname$,fontslot)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSSlot">
    <keyword>FNSSlot</keyword>
    <fullCommand>FNSSlot</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSUnload">
    <keyword>FNSUnload</keyword>
    <fullCommand>FNSUnload fontslot</fullCommand>
    <parameters>fontslot</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FNSSetTab">
    <keyword>FNSSetTab</keyword>
    <fullCommand>FNSSetTab tab_size</fullCommand>
    <parameters>tab_size</parameters>
    <shortDescription>set tab size in pixels.</shortDescription>
    <longDescription />
  </command>
  <command name="FNSShadowPrint">
    <keyword>FNSShadowPrint</keyword>
    <fullCommand>FNSShadowPrint fontnum,x,y,a$/string_address,[prefs,colour[,shadow]]</fullCommand>
    <parameters>fontnum,x,y,a$/string_address,[prefs,colour[,shadow]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Encrypt">
    <keyword>Encrypt</keyword>
    <fullCommand>Encrypt memadr,length[,wheel1,wheel2,wheel3]</fullCommand>
    <parameters>memadr,length[,wheel1,wheel2,wheel3]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Decrypt">
    <keyword>Decrypt</keyword>
    <fullCommand>Decrypt memadr,length,wheel1,wheel2,wheel3[,mode]</fullCommand>
    <parameters>memadr,length,wheel1,wheel2,wheel3[,mode]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetWheel">
    <keyword>GetWheel</keyword>
    <fullCommand>GetWheel wheel#</fullCommand>
    <parameters>wheel#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddVarTrace">
    <keyword>AddVarTrace</keyword>
    <fullCommand>AddVarTrace variable,string$,output</fullCommand>
    <parameters>variable,string$,output</parameters>
    <shortDescription>add a variable trace.</shortDescription>
    <longDescription />
  </command>
  <command name="DelVarTrace">
    <keyword>DelVarTrace</keyword>
    <fullCommand>DelVarTrace variable$</fullCommand>
    <parameters>variable$</parameters>
    <shortDescription>remove a trace on a named variable.</shortDescription>
    <longDescription />
  </command>
  <command name="VarTraceWindow">
    <keyword>VarTraceWindow</keyword>
    <fullCommand>VarTraceWindow</fullCommand>
    <parameters />
    <shortDescription>open the variable trace window on the debugger screen.</shortDescription>
    <longDescription />
  </command>
  <command name="DisAsmWindow">
    <keyword>DisAsmWindow</keyword>
    <fullCommand>DisAsmWindow [address]</fullCommand>
    <parameters>[address]</parameters>
    <shortDescription>open the disassembly window on the debugger screen.</shortDescription>
    <longDescription />
  </command>
  <command name="CopperTrace">
    <keyword>CopperTrace</keyword>
    <fullCommand>CopperTrace address,[,offset]</fullCommand>
    <parameters>address,[,offset]</parameters>
    <shortDescription>offset&lt;&gt;0 for CopList objects.</shortDescription>
    <longDescription />
  </command>
  <command name="ProcControl">
    <keyword>ProcControl</keyword>
    <fullCommand>ProcControl [On/Off]</fullCommand>
    <parameters>[On/Off]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MemoryWindow">
    <keyword>MemoryWindow</keyword>
    <fullCommand>MemoryWindow num#,address</fullCommand>
    <parameters>num#,address</parameters>
    <shortDescription>open a memory window on the debugger screen.</shortDescription>
    <longDescription />
  </command>
  <command name="DoColSplit">
    <keyword>DoColSplit</keyword>
    <fullCommand>DoColSplit cols_adr,numlines,colour_register</fullCommand>
    <parameters>cols_adr,numlines,colour_register</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RedoColSplit">
    <keyword>RedoColSplit</keyword>
    <fullCommand>RedoColSplit cols_adr,numlines,ccoffset</fullCommand>
    <parameters>cols_adr,numlines,ccoffset</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopperReset">
    <keyword>CopperReset</keyword>
    <fullCommand>CopperReset coplist#,startline[,ccoffset]</fullCommand>
    <parameters>coplist#,startline[,ccoffset]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopperEnd">
    <keyword>CopperEnd</keyword>
    <fullCommand>CopperEnd</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopperInfoBlock">
    <keyword>CopperInfoBlock</keyword>
    <fullCommand>CopperInfoBlock</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopperCommand">
    <keyword>CopperCommand</keyword>
    <fullCommand>CopperCommand copins1,copins2</fullCommand>
    <parameters>copins1,copins2</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopperMove">
    <keyword>CopperMove</keyword>
    <fullCommand>CopperMove register,value</fullCommand>
    <parameters>register,value</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopperWait">
    <keyword>CopperWait</keyword>
    <fullCommand>CopperWait x,y</fullCommand>
    <parameters>x,y</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopperSkip">
    <keyword>CopperSkip</keyword>
    <fullCommand>CopperSkip x,y</fullCommand>
    <parameters>x,y</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetCCOffset">
    <keyword>GetCCOffset</keyword>
    <fullCommand>GetCCOffset</fullCommand>
    <parameters />
    <shortDescription>get current custom copper offset.</shortDescription>
    <longDescription />
  </command>
  <command name="CopperAGACol">
    <keyword>CopperAGACol</keyword>
    <fullCommand>CopperAGACol col#,r,g,b</fullCommand>
    <parameters>col#,r,g,b</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopperResetAdr">
    <keyword>CopperResetAdr</keyword>
    <fullCommand>CopperResetAdr coplist#,startline</fullCommand>
    <parameters>coplist#,startline</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ColSplitBplcon3">
    <keyword>ColSplitBplcon3</keyword>
    <fullCommand>ColSplitBplcon3 bplcon3</fullCommand>
    <parameters>bplcon3</parameters>
    <shortDescription>low byte of bplcon 3.</shortDescription>
    <longDescription />
  </command>
  <command name="OpenCD">
    <keyword>OpenCD</keyword>
    <fullCommand>OpenCD [devicename,unit]</fullCommand>
    <parameters>[devicename,unit]</parameters>
    <shortDescription>open a CD compatible device.</shortDescription>
    <longDescription />
  </command>
  <command name="CloseCD">
    <keyword>CloseCD</keyword>
    <fullCommand>CloseCD</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDDoor">
    <keyword>CDDoor</keyword>
    <fullCommand>CDDoor on/off</fullCommand>
    <parameters>on/off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDPlayTrack">
    <keyword>CDPlayTrack</keyword>
    <fullCommand>CDPlayTrack track#,numtracks</fullCommand>
    <parameters>track#,numtracks</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDReadTOC">
    <keyword>CDReadTOC</keyword>
    <fullCommand>CDReadTOC</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDStatus">
    <keyword>CDStatus</keyword>
    <fullCommand>CDStatus</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDStop">
    <keyword>CDStop</keyword>
    <fullCommand>CDStop</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDVolume">
    <keyword>CDVolume</keyword>
    <fullCommand>CDVolume volume,lengthoffade</fullCommand>
    <parameters>volume,lengthoffade</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDNumTracks">
    <keyword>CDNumTracks</keyword>
    <fullCommand>CDNumTracks</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDFirstTrack">
    <keyword>CDFirstTrack</keyword>
    <fullCommand>CDFirstTrack</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDLastTrack">
    <keyword>CDLastTrack</keyword>
    <fullCommand>CDLastTrack</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDTrackLength">
    <keyword>CDTrackLength</keyword>
    <fullCommand>CDTrackLength track#</fullCommand>
    <parameters>track#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDUpdateInfo">
    <keyword>CDUpdateInfo</keyword>
    <fullCommand>CDUpdateInfo</fullCommand>
    <parameters />
    <shortDescription>update track playing/time information.</shortDescription>
    <longDescription />
  </command>
  <command name="CDFlush">
    <keyword>CDFlush</keyword>
    <fullCommand>CDFlush</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDPause">
    <keyword>CDPause</keyword>
    <fullCommand>CDPause on/off</fullCommand>
    <parameters>on/off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDRewind">
    <keyword>CDRewind</keyword>
    <fullCommand>CDRewind</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDFastForward">
    <keyword>CDFastForward</keyword>
    <fullCommand>CDFastForward</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDNormalSpeed">
    <keyword>CDNormalSpeed</keyword>
    <fullCommand>CDNormalSpeed</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDSpeed">
    <keyword>CDSpeed</keyword>
    <fullCommand>CDSpeed speed</fullCommand>
    <parameters>speed</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDTrackMins">
    <keyword>CDTrackMins</keyword>
    <fullCommand>CDTrackMins [offset]</fullCommand>
    <parameters>[offset]</parameters>
    <shortDescription>mins for current track.</shortDescription>
    <longDescription />
  </command>
  <command name="CDTrackSecs">
    <keyword>CDTrackSecs</keyword>
    <fullCommand>CDTrackSecs [offset]</fullCommand>
    <parameters>[offset]</parameters>
    <shortDescription>secs for current track.</shortDescription>
    <longDescription />
  </command>
  <command name="CDTrackPlaying">
    <keyword>CDTrackPlaying</keyword>
    <fullCommand>CDTrackPlaying</fullCommand>
    <parameters />
    <shortDescription>current track being played.</shortDescription>
    <longDescription />
  </command>
  <command name="MakeCommodity">
    <keyword>MakeCommodity</keyword>
    <fullCommand>MakeCommodity(name$,title$,description$</fullCommand>
    <parameters>(name$,title$,description$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetHotKey">
    <keyword>SetHotKey</keyword>
    <fullCommand>SetHotKey(hotkeynum,hotkey$)</fullCommand>
    <parameters>(hotkeynum,hotkey$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="HotKeyHit">
    <keyword>HotKeyHit</keyword>
    <fullCommand>HotKeyHit</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="WaitCommodity">
    <keyword>WaitCommodity</keyword>
    <fullCommand>WaitCommodity</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CommodityEvent">
    <keyword>CommodityEvent</keyword>
    <fullCommand>CommodityEvent</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExchangeMessage">
    <keyword>ExchangeMessage</keyword>
    <fullCommand>ExchangeMessage</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExchangeDisable">
    <keyword>ExchangeDisable</keyword>
    <fullCommand>ExchangeDisable</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExchangeEnable">
    <keyword>ExchangeEnable</keyword>
    <fullCommand>ExchangeEnable</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExchangeAppear">
    <keyword>ExchangeAppear</keyword>
    <fullCommand>ExchangeAppear</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExchangeDisAppear">
    <keyword>ExchangeDisAppear</keyword>
    <fullCommand>ExchangeDisAppear</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExchangeKill">
    <keyword>ExchangeKill</keyword>
    <fullCommand>ExchangeKill</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExchangeListChange">
    <keyword>ExchangeListChange</keyword>
    <fullCommand>ExchangeListChange</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExchangeUnique">
    <keyword>ExchangeUnique</keyword>
    <fullCommand>ExchangeUnique</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxDisable">
    <keyword>CxDisable</keyword>
    <fullCommand>CxDisable</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxEnable">
    <keyword>CxEnable</keyword>
    <fullCommand>CxEnable</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxAppear">
    <keyword>CxAppear</keyword>
    <fullCommand>CxAppear</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxDisAppear">
    <keyword>CxDisAppear</keyword>
    <fullCommand>CxDisAppear</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxKill">
    <keyword>CxKill</keyword>
    <fullCommand>CxKill</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxListChange">
    <keyword>CxListChange</keyword>
    <fullCommand>CxListChange</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxUnique">
    <keyword>CxUnique</keyword>
    <fullCommand>CxUnique</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetCxStatus">
    <keyword>SetCxStatus</keyword>
    <fullCommand>SetCxStatus on|off</fullCommand>
    <parameters>on|off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CommodityMsgPort">
    <keyword>CommodityMsgPort</keyword>
    <fullCommand>CommodityMsgPort</fullCommand>
    <parameters />
    <shortDescription>-- returns the message port address.</shortDescription>
    <longDescription />
  </command>
  <command name="AddAppWindow">
    <keyword>AddAppWindow</keyword>
    <fullCommand>AddAppWindow(windownumber)</fullCommand>
    <parameters>(windownumber)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DelAppWindow">
    <keyword>DelAppWindow</keyword>
    <fullCommand>DelAppWindow(windownumber)</fullCommand>
    <parameters>(windownumber)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddAppMenu">
    <keyword>AddAppMenu</keyword>
    <fullCommand>AddAppMenu(id,text$)</fullCommand>
    <parameters>(id,text$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DelAppMenu">
    <keyword>DelAppMenu</keyword>
    <fullCommand>DelAppMenu(id)</fullCommand>
    <parameters>(id)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddAppIcon">
    <keyword>AddAppIcon</keyword>
    <fullCommand>AddAppIcon(id,text$,filename$[,x,y])</fullCommand>
    <parameters>(id,text$,filename$[,x,y])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DelAppIcon">
    <keyword>DelAppIcon</keyword>
    <fullCommand>DelAppIcon(id)</fullCommand>
    <parameters>(id)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AppEvent">
    <keyword>AppEvent</keyword>
    <fullCommand>AppEvent</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="AppEventType">
    <keyword>AppEventType</keyword>
    <fullCommand>AppEventType</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="AppEventID">
    <keyword>AppEventID</keyword>
    <fullCommand>AppEventID</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NextAppFile">
    <keyword>NextAppFile</keyword>
    <fullCommand>NextAppFile</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="AppFile">
    <keyword>AppFile</keyword>
    <fullCommand>AppFile(num)</fullCommand>
    <parameters>(num)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AppNumFiles">
    <keyword>AppNumFiles</keyword>
    <fullCommand>AppNumFiles</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="AppLock">
    <keyword>AppLock</keyword>
    <fullCommand>AppLock</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="AppMessage">
    <keyword>AppMessage</keyword>
    <fullCommand>AppMessage</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="AppMsgPort">
    <keyword>AppMsgPort</keyword>
    <fullCommand>AppMsgPort</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="AppEventIDCMP">
    <keyword>AppEventIDCMP</keyword>
    <fullCommand>AppEventIDCMP</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RIAnimInit">
    <keyword>RIAnimInit</keyword>
    <fullCommand>RIAnimInit(address,bitmap#,palette# [,xy_offset]|[,x,y])</fullCommand>
    <parameters>(address,bitmap#,palette# [,xy_offset]|[,x,y])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RINextAnimFrame">
    <keyword>RINextAnimFrame</keyword>
    <fullCommand>RINextAnimFrame(bitmap#)</fullCommand>
    <parameters>(bitmap#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AnimLoop">
    <keyword>AnimLoop</keyword>
    <fullCommand>AnimLoop On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RIAnimFrameCount">
    <keyword>RIAnimFrameCount</keyword>
    <fullCommand>RIAnimFrameCount</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RIAnimDepth">
    <keyword>RIAnimDepth</keyword>
    <fullCommand>RIAnimDepth address -</fullCommand>
    <parameters>address -</parameters>
    <shortDescription>address of your animation file.</shortDescription>
    <longDescription />
  </command>
  <command name="RIAnimWidth">
    <keyword>RIAnimWidth</keyword>
    <fullCommand>RIAnimWidth address -</fullCommand>
    <parameters>address -</parameters>
    <shortDescription>address of your animation file.</shortDescription>
    <longDescription />
  </command>
  <command name="RIAnimHeight">
    <keyword>RIAnimHeight</keyword>
    <fullCommand>RIAnimHeight address -</fullCommand>
    <parameters>address -</parameters>
    <shortDescription>address of your animation file.</shortDescription>
    <longDescription />
  </command>
  <command name="CachesOn">
    <keyword>CachesOn</keyword>
    <fullCommand>CachesOn bitmask</fullCommand>
    <parameters>bitmask</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Reboot">
    <keyword>Reboot</keyword>
    <fullCommand>Reboot</fullCommand>
    <parameters />
    <shortDescription>-- performs a cold reboot.</shortDescription>
    <longDescription />
  </command>
  <command name="Lisa">
    <keyword>Lisa</keyword>
    <fullCommand>Lisa</fullCommand>
    <parameters />
    <shortDescription>-- returns Lisa chip version.</shortDescription>
    <longDescription />
  </command>
  <command name="MakeDir">
    <keyword>MakeDir</keyword>
    <fullCommand>MakeDir [success=] MakeDir(Dirname$)</fullCommand>
    <parameters>[success=] MakeDir(Dirname$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Rename">
    <keyword>Rename</keyword>
    <fullCommand>Rename(oldfilename$,newfilename$)</fullCommand>
    <parameters>(oldfilename$,newfilename$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MemFree">
    <keyword>MemFree</keyword>
    <fullCommand>MemFree</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTTagValue">
    <keyword>GTTagValue</keyword>
    <fullCommand>GTTagValue([tagvalue])</fullCommand>
    <parameters>([tagvalue])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Timer">
    <keyword>Timer</keyword>
    <fullCommand>Timer</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="Min">
    <keyword>Min</keyword>
    <fullCommand>Min(a,b)</fullCommand>
    <parameters>(a,b)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopyByte">
    <keyword>CopyByte</keyword>
    <fullCommand>CopyByte sourceaddr,destaddr,bytes</fullCommand>
    <parameters>sourceaddr,destaddr,bytes</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopyWord">
    <keyword>CopyWord</keyword>
    <fullCommand>CopyWord sourceaddr,destaddr,words</fullCommand>
    <parameters>sourceaddr,destaddr,words</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopyLong">
    <keyword>CopyLong</keyword>
    <fullCommand>CopyLong sourceaddr,destaddr,longs</fullCommand>
    <parameters>sourceaddr,destaddr,longs</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Max">
    <keyword>Max</keyword>
    <fullCommand>Max(a,b)</fullCommand>
    <parameters>(a,b)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FileSize">
    <keyword>FileSize</keyword>
    <fullCommand>FileSize(filename$)</fullCommand>
    <parameters>(filename$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BLoad">
    <keyword>BLoad</keyword>
    <fullCommand>BLoad(filename$,[address,[,length,[offset,[memtype]]]])</fullCommand>
    <parameters>(filename$,[address,[,length,[offset,[memtype]]]])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSave">
    <keyword>BSave</keyword>
    <fullCommand>BSave(filename$,address/bank[,length])</fullCommand>
    <parameters>(filename$,address/bank[,length])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Start">
    <keyword>Start</keyword>
    <fullCommand>Start(bank)</fullCommand>
    <parameters>(bank)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Length">
    <keyword>Length</keyword>
    <fullCommand>Length(bank)</fullCommand>
    <parameters>(bank)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Erase">
    <keyword>Erase</keyword>
    <fullCommand>Erase bank</fullCommand>
    <parameters>bank</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EraseAll">
    <keyword>EraseAll</keyword>
    <fullCommand>EraseAll</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="Reserve">
    <keyword>Reserve</keyword>
    <fullCommand>Reserve(length)|(bank,length[,requirements])</fullCommand>
    <parameters>(length)|(bank,length[,requirements])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NextBank">
    <keyword>NextBank</keyword>
    <fullCommand>NextBank [startbank]</fullCommand>
    <parameters>[startbank]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CachesOff">
    <keyword>CachesOff</keyword>
    <fullCommand>CachesOff bitmask</fullCommand>
    <parameters>bitmask</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FillMem">
    <keyword>FillMem</keyword>
    <fullCommand>FillMem address,length[,value]</fullCommand>
    <parameters>address,length[,value]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="KeyCode">
    <keyword>KeyCode</keyword>
    <fullCommand>KeyCode</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="BlitterDone">
    <keyword>BlitterDone</keyword>
    <fullCommand>BlitterDone</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="WaitBlitter">
    <keyword>WaitBlitter</keyword>
    <fullCommand>WaitBlitter</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindVolume">
    <keyword>FindVolume</keyword>
    <fullCommand>FindVolume(volumename)</fullCommand>
    <parameters>(volumename)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SwapBank">
    <keyword>SwapBank</keyword>
    <fullCommand>SwapBank(sourcebank,destbank)</fullCommand>
    <parameters>(sourcebank,destbank)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeviceName$">
    <keyword>DeviceName$</keyword>
    <fullCommand>DeviceName$ volumename$</fullCommand>
    <parameters>volumename$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChangeDir">
    <keyword>ChangeDir</keyword>
    <fullCommand>ChangeDir dir$</fullCommand>
    <parameters>dir$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BankLimit">
    <keyword>BankLimit</keyword>
    <fullCommand>BankLimit [numbanks]</fullCommand>
    <parameters>[numbanks]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SaveExec">
    <keyword>SaveExec</keyword>
    <fullCommand>SaveExec filename$,list()</fullCommand>
    <parameters>filename$,list()</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MTInit">
    <keyword>MTInit</keyword>
    <fullCommand>MTInit &amp;module_addr, &amp;instr_addr, startpos</fullCommand>
    <parameters>&amp;module_addr, &amp;instr_addr, startpos</parameters>
    <shortDescription>Inserts INCBIN module into player, set instr_addr to 0 for normal modules.</shortDescription>
    <longDescription />
  </command>
  <command name="MTInstall">
    <keyword>MTInstall</keyword>
    <fullCommand>MTInstall PAL=True/NTSC=False</fullCommand>
    <parameters>PAL=True/NTSC=False</parameters>
    <shortDescription>Installs the CIA MOD player in program.</shortDescription>
    <longDescription />
  </command>
  <command name="MTPlay">
    <keyword>MTPlay</keyword>
    <fullCommand>MTPlay On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>Start/stop module playback.</shortDescription>
    <longDescription />
  </command>
  <command name="MTRemove">
    <keyword>MTRemove</keyword>
    <fullCommand>MTRemove</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Remove the CIA MOD player from the system.</shortDescription>
    <longDescription />
  </command>
  <command name="MTEnd">
    <keyword>MTEnd</keyword>
    <fullCommand>MTEnd</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Stop playing current module.</shortDescription>
    <longDescription />
  </command>
  <command name="MTSoundFX">
    <keyword>MTSoundFX</keyword>
    <fullCommand>MTSoundFX &amp;sample_addr.l, length.w, period.w, volume.w</fullCommand>
    <parameters>&amp;sample_addr.l, length.w, period.w, volume.w</parameters>
    <shortDescription>Volume range: 0..64.</shortDescription>
    <longDescription />
  </command>
  <command name="MTMasterVolume">
    <keyword>MTMasterVolume</keyword>
    <fullCommand>MTMasterVolume volume</fullCommand>
    <parameters>volume</parameters>
    <shortDescription>Master volume for all music channels. Volume range: 0..64.</shortDescription>
    <longDescription />
  </command>
  <command name="MTMusicMask">
    <keyword>MTMusicMask</keyword>
    <fullCommand>MTMusicMask bitmask.b</fullCommand>
    <parameters>bitmask.b</parameters>
    <shortDescription>Set bits 0-3 to reserve channels for music only.</shortDescription>
    <longDescription />
  </command>
  <command name="MTMusicChannels">
    <keyword>MTMusicChannels</keyword>
    <fullCommand>MTMusicChannels 0..4</fullCommand>
    <parameters>0..4</parameters>
    <shortDescription>Number of channels dedicated to music.</shortDescription>
    <longDescription />
  </command>
  <command name="MTE8Trigger">
    <keyword>MTE8Trigger</keyword>
    <fullCommand>MTE8Trigger</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Value of the last E8 command in case you want to trigger game events from a module.</shortDescription>
    <longDescription />
  </command>
  <command name="RTEZRequest">
    <keyword>RTEZRequest</keyword>
    <fullCommand>RTEZRequest(Title$,BodyText$,GadgetText$ [,ReqPosition [,DefaultResponse,Flags]])</fullCommand>
    <parameters>(Title$,BodyText$,GadgetText$ [,ReqPosition [,DefaultResponse,Flags]])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZLoadFile">
    <keyword>RTEZLoadFile</keyword>
    <fullCommand>RTEZLoadFile(Title$,Filename$)</fullCommand>
    <parameters>(Title$,Filename$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZFontRequest">
    <keyword>RTEZFontRequest</keyword>
    <fullCommand>RTEZFontRequest(Title$)</fullCommand>
    <parameters>(Title$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZScreenModeRequest">
    <keyword>RTEZScreenModeRequest</keyword>
    <fullCommand>RTEZScreenModeRequest(Title$ [,DisplayFlags])</fullCommand>
    <parameters>(Title$ [,DisplayFlags])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZPaletteRequest">
    <keyword>RTEZPaletteRequest</keyword>
    <fullCommand>RTEZPaletteRequest(Title$,FirstColour)</fullCommand>
    <parameters>(Title$,FirstColour)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZGetLong">
    <keyword>RTEZGetLong</keyword>
    <fullCommand>RTEZGetLong(Title$,BodyText$ [,DefaultValue])</fullCommand>
    <parameters>(Title$,BodyText$ [,DefaultValue])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZGetLongRange">
    <keyword>RTEZGetLongRange</keyword>
    <fullCommand>RTEZGetLongRange(Title$,BodyText$,Min,Max [,DefaultValue])</fullCommand>
    <parameters>(Title$,BodyText$,Min,Max [,DefaultValue])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZGetString">
    <keyword>RTEZGetString</keyword>
    <fullCommand>RTEZGetString(Title$,BodyText$,MaxChars [,DefaultString])</fullCommand>
    <parameters>(Title$,BodyText$,MaxChars [,DefaultString])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZSaveFile">
    <keyword>RTEZSaveFile</keyword>
    <fullCommand>RTEZSaveFile(Title$,Filename$)</fullCommand>
    <parameters>(Title$,Filename$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZSetDefaultDirectory">
    <keyword>RTEZSetDefaultDirectory</keyword>
    <fullCommand>RTEZSetDefaultDirectory Requester#,Directory$</fullCommand>
    <parameters>Requester#,Directory$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZPathRequest">
    <keyword>RTEZPathRequest</keyword>
    <fullCommand>RTEZPathRequest(Title$)</fullCommand>
    <parameters>(Title$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTLockWindow">
    <keyword>RTLockWindow</keyword>
    <fullCommand>RTLockWindow(Window#)</fullCommand>
    <parameters>(Window#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTUnlockWindow">
    <keyword>RTUnlockWindow</keyword>
    <fullCommand>RTUnlockWindow Window#,Lock</fullCommand>
    <parameters>Window#,Lock</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZSetPattern">
    <keyword>RTEZSetPattern</keyword>
    <fullCommand>RTEZSetPattern Requester#,Pattern$</fullCommand>
    <parameters>Requester#,Pattern$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZFreePattern">
    <keyword>RTEZFreePattern</keyword>
    <fullCommand>RTEZFreePattern Requester#</fullCommand>
    <parameters>Requester#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZFlagsRequest">
    <keyword>RTEZFlagsRequest</keyword>
    <fullCommand>RTEZFlagsRequest(Title$,BodyText$,GadgetText$,IDCMPFlags [,ReqPosition])</fullCommand>
    <parameters>(Title$,BodyText$,GadgetText$,IDCMPFlags [,ReqPosition])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTRequest">
    <keyword>RTRequest</keyword>
    <fullCommand>RTRequest(BodyText$,GadgetText$,TagList)</fullCommand>
    <parameters>(BodyText$,GadgetText$,TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTFileRequest">
    <keyword>RTFileRequest</keyword>
    <fullCommand>RTFileRequest(Title$,FileName$,TagList)</fullCommand>
    <parameters>(Title$,FileName$,TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEZMultiLoadFile">
    <keyword>RTEZMultiLoadFile</keyword>
    <fullCommand>RTEZMultiLoadFile(Title$)</fullCommand>
    <parameters>(Title$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTNextPathEntry">
    <keyword>RTNextPathEntry</keyword>
    <fullCommand>RTNextPathEntry</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTASyncRequest">
    <keyword>RTASyncRequest</keyword>
    <fullCommand>RTASyncRequest(Title$,BodyText$,GadgetText$)</fullCommand>
    <parameters>(Title$,BodyText$,GadgetText$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTCheckASyncRequest">
    <keyword>RTCheckASyncRequest</keyword>
    <fullCommand>RTCheckASyncRequest</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEndASyncRequest">
    <keyword>RTEndASyncRequest</keyword>
    <fullCommand>RTEndASyncRequest</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTVersion">
    <keyword>RTVersion</keyword>
    <fullCommand>RTVersion</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTRevision">
    <keyword>RTRevision</keyword>
    <fullCommand>RTRevision</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsReqToolsActive">
    <keyword>IsReqToolsActive</keyword>
    <fullCommand>IsReqToolsActive</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTASyncPaletteRequest">
    <keyword>RTASyncPaletteRequest</keyword>
    <fullCommand>RTASyncPaletteRequest(Title$,FirstColour)</fullCommand>
    <parameters>(Title$,FirstColour)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTCheckASyncPaletteRequest">
    <keyword>RTCheckASyncPaletteRequest</keyword>
    <fullCommand>RTCheckASyncPaletteRequest</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RTEndASyncPaletteRequest">
    <keyword>RTEndASyncPaletteRequest</keyword>
    <fullCommand>RTEndASyncPaletteRequest</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="PICreateRequest">
    <keyword>PICreateRequest</keyword>
    <fullCommand>PICreateRequest(Title$,Min,Max [,NoGagdet])</fullCommand>
    <parameters>(Title$,Min,Max [,NoGagdet])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PIEndRequest">
    <keyword>PIEndRequest</keyword>
    <fullCommand>PIEndRequest</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="PIUpdateRequest">
    <keyword>PIUpdateRequest</keyword>
    <fullCommand>PIUpdateRequest(Value)</fullCommand>
    <parameters>(Value)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ColourRequest">
    <keyword>ColourRequest</keyword>
    <fullCommand>ColourRequest Colour#</fullCommand>
    <parameters>Colour#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TextRequest">
    <keyword>TextRequest</keyword>
    <fullCommand>TextRequest(Text,Title,Left Text[,[Middle Text,]Right Text])</fullCommand>
    <parameters>(Text,Title,Left Text[,[Middle Text,]Right Text])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FileReqSize">
    <keyword>FileReqSize</keyword>
    <fullCommand>FileReqSize Lines High,File Length,Device Length,</fullCommand>
    <parameters>Lines High,File Length,Device Length,</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReqFileRequest$">
    <keyword>ReqFileRequest$</keyword>
    <fullCommand>ReqFileRequest$(Title$,File$,Path$,Flags)</fullCommand>
    <parameters>(Title$,File$,Path$,Flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FileFilter">
    <keyword>FileFilter</keyword>
    <fullCommand>FileFilter Show$,Hide$</fullCommand>
    <parameters>Show$,Hide$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TextTimeout">
    <keyword>TextTimeout</keyword>
    <fullCommand>TextTimeout Timeout Seconds</fullCommand>
    <parameters>Timeout Seconds</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReqColours">
    <keyword>ReqColours</keyword>
    <fullCommand>ReqColours Text,Detail,Block[,File,Dir,Device[,GadText,GadBox,StringName,StringBox,Frame]]</fullCommand>
    <parameters>Text,Detail,Block[,File,Dir,Device[,GadText,GadBox,StringName,StringBox,Frame]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetString$">
    <keyword>GetString$</keyword>
    <fullCommand>GetString$(Title$,Default$,Visable size,Max length)</fullCommand>
    <parameters>(Title$,Default$,Visable size,Max length)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FileStructure">
    <keyword>FileStructure</keyword>
    <fullCommand>FileStructure Pointer to file requester structor</fullCommand>
    <parameters>Pointer to file requester structor</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NextFile$">
    <keyword>NextFile$</keyword>
    <fullCommand>NextFile$ Returns next file form MaxSelect$</fullCommand>
    <parameters>Returns next file form MaxSelect$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MaxSelect$">
    <keyword>MaxSelect$</keyword>
    <fullCommand>MaxSelect$ Path$=(Title$,File$,Path$,Flags,number of files)</fullCommand>
    <parameters>Path$=(Title$,File$,Path$,Flags,number of files)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReqFontSize">
    <keyword>ReqFontSize</keyword>
    <fullCommand>ReqFontSize Returns font size</fullCommand>
    <parameters>Returns font size</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Req_Base">
    <keyword>Req_Base</keyword>
    <fullCommand>Req_Base Returns pointer to req.library</fullCommand>
    <parameters>Returns pointer to req.library</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Dos_Base">
    <keyword>Dos_Base</keyword>
    <fullCommand>Dos_Base Returns pointer to dos.library</fullCommand>
    <parameters>Returns pointer to dos.library</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Int_Base">
    <keyword>Int_Base</keyword>
    <fullCommand>Int_Base Returns pointer to intuition.library</fullCommand>
    <parameters>Returns pointer to intuition.library</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Gfx_Base">
    <keyword>Gfx_Base</keyword>
    <fullCommand>Gfx_Base Returns pointer to graphics.library</fullCommand>
    <parameters>Returns pointer to graphics.library</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Rex_Base">
    <keyword>Rex_Base</keyword>
    <fullCommand>Rex_Base Returns pointer to RexxSys.library ?</fullCommand>
    <parameters>Returns pointer to RexxSys.library ?</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Con_Base">
    <keyword>Con_Base</keyword>
    <fullCommand>Con_Base Returns pointer to console.device</fullCommand>
    <parameters>Returns pointer to console.device</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Null">
    <keyword>Null</keyword>
    <fullCommand>Null(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription>Returns address of null-termed string.</shortDescription>
    <longDescription />
  </command>
  <command name="ChipFree">
    <keyword>ChipFree</keyword>
    <fullCommand>ChipFree</fullCommand>
    <parameters />
    <shortDescription>Returns largest block of free CHIP memory.</shortDescription>
    <longDescription />
  </command>
  <command name="FastFree">
    <keyword>FastFree</keyword>
    <fullCommand>FastFree</fullCommand>
    <parameters />
    <shortDescription>Returns largest block of free FAST memory.</shortDescription>
    <longDescription />
  </command>
  <command name="LargestFree">
    <keyword>LargestFree</keyword>
    <fullCommand>LargestFree</fullCommand>
    <parameters />
    <shortDescription>Returns largest block of memory available.</shortDescription>
    <longDescription />
  </command>
  <command name="IntuitionBase">
    <keyword>IntuitionBase</keyword>
    <fullCommand>IntuitionBase</fullCommand>
    <parameters />
    <shortDescription>;Returns Intuition Library base.</shortDescription>
    <longDescription />
  </command>
  <command name="DosBase">
    <keyword>DosBase</keyword>
    <fullCommand>DosBase</fullCommand>
    <parameters />
    <shortDescription>;Returns DOS Library base.</shortDescription>
    <longDescription />
  </command>
  <command name="GraphicsBase">
    <keyword>GraphicsBase</keyword>
    <fullCommand>GraphicsBase</fullCommand>
    <parameters />
    <shortDescription>;Returns Graphics Library base.</shortDescription>
    <longDescription />
  </command>
  <command name="FFPBase">
    <keyword>FFPBase</keyword>
    <fullCommand>FFPBase</fullCommand>
    <parameters />
    <shortDescription>;Returns FFP Math Library base.</shortDescription>
    <longDescription />
  </command>
  <command name="DiskFontBase">
    <keyword>DiskFontBase</keyword>
    <fullCommand>DiskFontBase</fullCommand>
    <parameters />
    <shortDescription>;Returns DiskFont Library base.</shortDescription>
    <longDescription />
  </command>
  <command name="CommoditiesBase">
    <keyword>CommoditiesBase</keyword>
    <fullCommand>CommoditiesBase</fullCommand>
    <parameters />
    <shortDescription>;Returns Commodities Library base.</shortDescription>
    <longDescription />
  </command>
  <command name="IconBase">
    <keyword>IconBase</keyword>
    <fullCommand>IconBase</fullCommand>
    <parameters />
    <shortDescription>;Returns Icon Library base.</shortDescription>
    <longDescription />
  </command>
  <command name="RexxSysBase">
    <keyword>RexxSysBase</keyword>
    <fullCommand>RexxSysBase</fullCommand>
    <parameters />
    <shortDescription>;Returns RexxSys Library base.</shortDescription>
    <longDescription />
  </command>
  <command name="Request">
    <keyword>Request</keyword>
    <fullCommand>Request(Title$,text$,button$)</fullCommand>
    <parameters>(Title$,text$,button$)</parameters>
    <shortDescription>OS 2.0 &amp; above System Requester.</shortDescription>
    <longDescription />
  </command>
  <command name="ActiveScreen">
    <keyword>ActiveScreen</keyword>
    <fullCommand>ActiveScreen</fullCommand>
    <parameters />
    <shortDescription>;Returns ADDRESS of current Intuition screen.</shortDescription>
    <longDescription />
  </command>
  <command name="ScreenWidth">
    <keyword>ScreenWidth</keyword>
    <fullCommand>ScreenWidth</fullCommand>
    <parameters />
    <shortDescription>;Returns width in pixels of active screen.</shortDescription>
    <longDescription />
  </command>
  <command name="ScreenHeight">
    <keyword>ScreenHeight</keyword>
    <fullCommand>ScreenHeight</fullCommand>
    <parameters />
    <shortDescription>;Returns height in pixels of active screen.</shortDescription>
    <longDescription />
  </command>
  <command name="ActiveWindow">
    <keyword>ActiveWindow</keyword>
    <fullCommand>ActiveWindow</fullCommand>
    <parameters />
    <shortDescription>;Returns ADDRESS of current Intuition window.</shortDescription>
    <longDescription />
  </command>
  <command name="WaitFor">
    <keyword>WaitFor</keyword>
    <fullCommand>WaitFor(IDCMP Code)</fullCommand>
    <parameters>(IDCMP Code)</parameters>
    <shortDescription>Delays until specified Intuition event occurs.</shortDescription>
    <longDescription />
  </command>
  <command name="ShowRequesters">
    <keyword>ShowRequesters</keyword>
    <fullCommand>ShowRequesters [0=Cancel] [1=On Workbench Screen] [2=In Current Window]</fullCommand>
    <parameters>[0=Cancel] [1=On Workbench Screen] [2=In Current Window]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Xor">
    <keyword>Xor</keyword>
    <fullCommand>Xor(expression,expression)</fullCommand>
    <parameters>(expression,expression)</parameters>
    <shortDescription>Returns Exclusive OR of two expressions.</shortDescription>
    <longDescription />
  </command>
  <command name="Largest.l">
    <keyword>Largest.l</keyword>
    <fullCommand>Largest.l(Long Integer1,Long Integer2)</fullCommand>
    <parameters>(Long Integer1,Long Integer2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Smallest.l">
    <keyword>Smallest.l</keyword>
    <fullCommand>Smallest.l(Long Integer1,Long Integer2)</fullCommand>
    <parameters>(Long Integer1,Long Integer2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Largest.q">
    <keyword>Largest.q</keyword>
    <fullCommand>Largest.q(Quick1,Quick2)</fullCommand>
    <parameters>(Quick1,Quick2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Smallest.q">
    <keyword>Smallest.q</keyword>
    <fullCommand>Smallest.q(Quick1,Quick2)</fullCommand>
    <parameters>(Quick1,Quick2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Largest">
    <keyword>Largest</keyword>
    <fullCommand>Largest(Integer1,Integer2)</fullCommand>
    <parameters>(Integer1,Integer2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Smallest">
    <keyword>Smallest</keyword>
    <fullCommand>Smallest(Integer1,Integer2)</fullCommand>
    <parameters>(Integer1,Integer2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Avg.l">
    <keyword>Avg.l</keyword>
    <fullCommand>Avg.l(Long Integer 1,Long Integer 2)</fullCommand>
    <parameters>(Long Integer 1,Long Integer 2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Avg.q">
    <keyword>Avg.q</keyword>
    <fullCommand>Avg.q(Quick1,Quick2)</fullCommand>
    <parameters>(Quick1,Quick2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Avg">
    <keyword>Avg</keyword>
    <fullCommand>Avg(Integer1,Integer2)</fullCommand>
    <parameters>(Integer1,Integer2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RRandomize">
    <keyword>RRandomize</keyword>
    <fullCommand>RRandomize Seed</fullCommand>
    <parameters>Seed</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RRnd">
    <keyword>RRnd</keyword>
    <fullCommand>RRnd(Low,High)</fullCommand>
    <parameters>(Low,High)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Hex#">
    <keyword>Hex#</keyword>
    <fullCommand>Hex#(HexString$)</fullCommand>
    <parameters>(HexString$)</parameters>
    <shortDescription>Converts hexadecimal (in string) value to decimal.</shortDescription>
    <longDescription />
  </command>
  <command name="Bin#">
    <keyword>Bin#</keyword>
    <fullCommand>Bin#(BinString$)</fullCommand>
    <parameters>(BinString$)</parameters>
    <shortDescription>Converts binary value (in string) to decimal.</shortDescription>
    <longDescription />
  </command>
  <command name="IncSound">
    <keyword>IncSound</keyword>
    <fullCommand>IncSound Success=IncSound(SOUND#,?LABEL or ADDRESS)</fullCommand>
    <parameters>Success=IncSound(SOUND#,?LABEL or ADDRESS)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IncBitmap">
    <keyword>IncBitmap</keyword>
    <fullCommand>IncBitmap Success=IncBitmap(BITMAP#,?LABEL or ADDRESS)</fullCommand>
    <parameters>Success=IncBitmap(BITMAP#,?LABEL or ADDRESS)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IncMod">
    <keyword>IncMod</keyword>
    <fullCommand>IncMod Success=IncMod(TRACKER-MODULE#,?LABEL or ADDRESS)</fullCommand>
    <parameters>Success=IncMod(TRACKER-MODULE#,?LABEL or ADDRESS)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IncMed">
    <keyword>IncMed</keyword>
    <fullCommand>IncMed Success=IncMed(MED-MODULE#,?LABEL or ADDRESS)</fullCommand>
    <parameters>Success=IncMed(MED-MODULE#,?LABEL or ADDRESS)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IncShape">
    <keyword>IncShape</keyword>
    <fullCommand>IncShape Success=IncShape(SHAPE#,?LABEL or ADDRESS [,Cookiecut?])</fullCommand>
    <parameters>Success=IncShape(SHAPE#,?LABEL or ADDRESS [,Cookiecut?])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IncNextShape">
    <keyword>IncNextShape</keyword>
    <fullCommand>IncNextShape Success=IncNextShape [(Cookiecut?)]</fullCommand>
    <parameters>Success=IncNextShape [(Cookiecut?)]</parameters>
    <shortDescription>*MUST* use with IncShape(...).</shortDescription>
    <longDescription />
  </command>
  <command name="IncDataABS">
    <keyword>IncDataABS</keyword>
    <fullCommand>IncDataABS Bytes=IncDataABS(?LABEL or ADDRESS,DESTINATION ADDRESS)</fullCommand>
    <parameters>Bytes=IncDataABS(?LABEL or ADDRESS,DESTINATION ADDRESS)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IncData">
    <keyword>IncData</keyword>
    <fullCommand>IncData Address=IncData(?LABEL or ADDRESS,MEMTYPE)</fullCommand>
    <parameters>Address=IncData(?LABEL or ADDRESS,MEMTYPE)</parameters>
    <shortDescription>0=fast 2=chip 65536=clearmem.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeIncData">
    <keyword>FreeIncData</keyword>
    <fullCommand>FreeIncData SIZE,ADDRESS</fullCommand>
    <parameters>SIZE,ADDRESS</parameters>
    <shortDescription>As returned from IncSize(...) and IncData(...).</shortDescription>
    <longDescription />
  </command>
  <command name="SaveIncData">
    <keyword>SaveIncData</keyword>
    <fullCommand>SaveIncData Success=SaveIncData(Filename$,?LABEL or ADDRESS)</fullCommand>
    <parameters>Success=SaveIncData(Filename$,?LABEL or ADDRESS)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IncText$">
    <keyword>IncText$</keyword>
    <fullCommand>IncText$ n$=IncText$(?LABEL or ADDRESS[,max length])</fullCommand>
    <parameters>n$=IncText$(?LABEL or ADDRESS[,max length])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IncSize">
    <keyword>IncSize</keyword>
    <fullCommand>IncSize bytes=IncSize(?LABEL OR ADDRESS)</fullCommand>
    <parameters>bytes=IncSize(?LABEL OR ADDRESS)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Freq">
    <keyword>Freq</keyword>
    <fullCommand>Freq Channelmask,period</fullCommand>
    <parameters>Channelmask,period</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Quiet">
    <keyword>Quiet</keyword>
    <fullCommand>Quiet ChannelMask</fullCommand>
    <parameters>ChannelMask</parameters>
    <shortDescription>Stops specified currently playing sounds.</shortDescription>
    <longDescription />
  </command>
  <command name="VWaitPos">
    <keyword>VWaitPos</keyword>
    <fullCommand>VWaitPos RasterLine</fullCommand>
    <parameters>RasterLine</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Ticks">
    <keyword>Ticks</keyword>
    <fullCommand>Ticks</fullCommand>
    <parameters />
    <shortDescription>;'ticks' since last ResetTimer (1/50 secs. PAL, 1/60 NTSC).</shortDescription>
    <longDescription />
  </command>
  <command name="ResetTimer">
    <keyword>ResetTimer</keyword>
    <fullCommand>ResetTimer</fullCommand>
    <parameters />
    <shortDescription>;Resets timer to zero 'Ticks.'.</shortDescription>
    <longDescription />
  </command>
  <command name="JoyC">
    <keyword>JoyC</keyword>
    <fullCommand>JoyC(Port)</fullCommand>
    <parameters>(Port)</parameters>
    <shortDescription>For 2-button controllers:  Detects buttons pressed.</shortDescription>
    <longDescription />
  </command>
  <command name="CheckAGA">
    <keyword>CheckAGA</keyword>
    <fullCommand>CheckAGA</fullCommand>
    <parameters />
    <shortDescription>;Returns 'TRUE' for AGA machines, otherwise returns 'FALSE'.</shortDescription>
    <longDescription />
  </command>
  <command name="PeekTo$">
    <keyword>PeekTo$</keyword>
    <fullCommand>PeekTo$(Address,byte)</fullCommand>
    <parameters>(Address,byte)</parameters>
    <shortDescription>Reads memory into string upto specified byte.</shortDescription>
    <longDescription />
  </command>
  <command name="ForcePAL">
    <keyword>ForcePAL</keyword>
    <fullCommand>ForcePAL</fullCommand>
    <parameters />
    <shortDescription>;Forces screen mode to PAL (50hz).</shortDescription>
    <longDescription />
  </command>
  <command name="ForceNTSC">
    <keyword>ForceNTSC</keyword>
    <fullCommand>ForceNTSC</fullCommand>
    <parameters />
    <shortDescription>;Forces screen mode to NTSC (60hz).</shortDescription>
    <longDescription />
  </command>
  <command name="Depth">
    <keyword>Depth</keyword>
    <fullCommand>Depth(Bitmap#)</fullCommand>
    <parameters>(Bitmap#)</parameters>
    <shortDescription>Returns DEPTH of specified bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="ClickMouse">
    <keyword>ClickMouse</keyword>
    <fullCommand>ClickMouse</fullCommand>
    <parameters />
    <shortDescription>;Waits for left mouse button to be CLICKED.</shortDescription>
    <longDescription />
  </command>
  <command name="Index">
    <keyword>Index</keyword>
    <fullCommand>Index List()</fullCommand>
    <parameters>List()</parameters>
    <shortDescription>Returns index from top of LIST.</shortDescription>
    <longDescription />
  </command>
  <command name="SPACE$">
    <keyword>SPACE$</keyword>
    <fullCommand>SPACE$(number of spaces)</fullCommand>
    <parameters>(number of spaces)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Checksum">
    <keyword>Checksum</keyword>
    <fullCommand>Checksum(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription>Returns a unique checksum for a given string.</shortDescription>
    <longDescription />
  </command>
  <command name="CharCount">
    <keyword>CharCount</keyword>
    <fullCommand>CharCount(String$,byte)</fullCommand>
    <parameters>(String$,byte)</parameters>
    <shortDescription>Returns no. occurances of 'byte' in 'string$'.</shortDescription>
    <longDescription />
  </command>
  <command name="SearchEnd">
    <keyword>SearchEnd</keyword>
    <fullCommand>SearchEnd(String$,byte,# from End)</fullCommand>
    <parameters>(String$,byte,# from End)</parameters>
    <shortDescription>Searches string backwards for Nth byte.</shortDescription>
    <longDescription />
  </command>
  <command name="SearchBegin">
    <keyword>SearchBegin</keyword>
    <fullCommand>SearchBegin(String$,byte,# from Begin)</fullCommand>
    <parameters>(String$,byte,# from Begin)</parameters>
    <shortDescription>Searches string for Nth byte.</shortDescription>
    <longDescription />
  </command>
  <command name="Cipher$">
    <keyword>Cipher$</keyword>
    <fullCommand>Cipher$(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription>Create/Unencrypt a Cipher$() string.</shortDescription>
    <longDescription />
  </command>
  <command name="Repeats">
    <keyword>Repeats</keyword>
    <fullCommand>Repeats(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription>Returns # repetitive characters at front of string.</shortDescription>
    <longDescription />
  </command>
  <command name="CHDir">
    <keyword>CHDir</keyword>
    <fullCommand>CHDir [success=] CHDir(Path$)</fullCommand>
    <parameters>[success=] CHDir(Path$)</parameters>
    <shortDescription>CHange current DIRectory.</shortDescription>
    <longDescription />
  </command>
  <command name="CurrentDir$">
    <keyword>CurrentDir$</keyword>
    <fullCommand>CurrentDir$</fullCommand>
    <parameters />
    <shortDescription>Current directory name.</shortDescription>
    <longDescription />
  </command>
  <command name="MoreEntries">
    <keyword>MoreEntries</keyword>
    <fullCommand>MoreEntries</fullCommand>
    <parameters />
    <shortDescription>True if more entries in Examined directory.</shortDescription>
    <longDescription />
  </command>
  <command name="EntryDir">
    <keyword>EntryDir</keyword>
    <fullCommand>EntryDir</fullCommand>
    <parameters />
    <shortDescription>True if last Examined object or entry is a directory.</shortDescription>
    <longDescription />
  </command>
  <command name="EntryName$">
    <keyword>EntryName$</keyword>
    <fullCommand>EntryName$</fullCommand>
    <parameters />
    <shortDescription>Filename of last Examined object or entry.</shortDescription>
    <longDescription />
  </command>
  <command name="EntryBits$">
    <keyword>EntryBits$</keyword>
    <fullCommand>EntryBits$</fullCommand>
    <parameters />
    <shortDescription>Possible bits: H, S, A, P, R, W, E, D.</shortDescription>
    <longDescription />
  </command>
  <command name="EntrySize">
    <keyword>EntrySize</keyword>
    <fullCommand>EntrySize</fullCommand>
    <parameters />
    <shortDescription>Bytesize of last Examined object or entry.</shortDescription>
    <longDescription />
  </command>
  <command name="EntryDate">
    <keyword>EntryDate</keyword>
    <fullCommand>EntryDate</fullCommand>
    <parameters />
    <shortDescription>Date$(EntryDate) returns date of last Examined object or entry.</shortDescription>
    <longDescription />
  </command>
  <command name="EntryHour">
    <keyword>EntryHour</keyword>
    <fullCommand>EntryHour</fullCommand>
    <parameters />
    <shortDescription>Hour of last Examined object or entry.</shortDescription>
    <longDescription />
  </command>
  <command name="EntryMins">
    <keyword>EntryMins</keyword>
    <fullCommand>EntryMins</fullCommand>
    <parameters />
    <shortDescription>Minutes of last Examined object or entry.</shortDescription>
    <longDescription />
  </command>
  <command name="EntrySecs">
    <keyword>EntrySecs</keyword>
    <fullCommand>EntrySecs</fullCommand>
    <parameters />
    <shortDescription>Seconds of last Examined object or entry.</shortDescription>
    <longDescription />
  </command>
  <command name="EntryComment$">
    <keyword>EntryComment$</keyword>
    <fullCommand>EntryComment$</fullCommand>
    <parameters />
    <shortDescription>Comment String of last Examined object or entry.</shortDescription>
    <longDescription />
  </command>
  <command name="CopyFile">
    <keyword>CopyFile</keyword>
    <fullCommand>CopyFile [success=] CopyFile(Source$,Dest$)</fullCommand>
    <parameters>[success=] CopyFile(Source$,Dest$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetCopyBuffer">
    <keyword>SetCopyBuffer</keyword>
    <fullCommand>SetCopyBuffer BufferSize</fullCommand>
    <parameters>BufferSize</parameters>
    <shortDescription>Default is 4096 bytes, min. 1024 bytes.</shortDescription>
    <longDescription />
  </command>
  <command name="NameFile">
    <keyword>NameFile</keyword>
    <fullCommand>NameFile [success=] Rename(Oldfilename$,Newfilename$)</fullCommand>
    <parameters>[success=] Rename(Oldfilename$,Newfilename$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AnalyzeDisk">
    <keyword>AnalyzeDisk</keyword>
    <fullCommand>AnalyzeDisk(DriveName$)</fullCommand>
    <parameters>(DriveName$)</parameters>
    <shortDescription>TRUE if device name is valid.</shortDescription>
    <longDescription />
  </command>
  <command name="DiskUnit">
    <keyword>DiskUnit</keyword>
    <fullCommand>DiskUnit</fullCommand>
    <parameters />
    <shortDescription>Unit# of last drive analyzed.</shortDescription>
    <longDescription />
  </command>
  <command name="DiskErrors">
    <keyword>DiskErrors</keyword>
    <fullCommand>DiskErrors</fullCommand>
    <parameters />
    <shortDescription>No. of soft errors on last drive analyzed.</shortDescription>
    <longDescription />
  </command>
  <command name="DiskCapacity">
    <keyword>DiskCapacity</keyword>
    <fullCommand>DiskCapacity</fullCommand>
    <parameters />
    <shortDescription>Capacity in bytes of last drive analyzed.</shortDescription>
    <longDescription />
  </command>
  <command name="DiskUsed">
    <keyword>DiskUsed</keyword>
    <fullCommand>DiskUsed</fullCommand>
    <parameters />
    <shortDescription>No. bytes used of last analyzed drive.</shortDescription>
    <longDescription />
  </command>
  <command name="DiskBlocks">
    <keyword>DiskBlocks</keyword>
    <fullCommand>DiskBlocks</fullCommand>
    <parameters />
    <shortDescription>Bytes per block of last drive analyzed.</shortDescription>
    <longDescription />
  </command>
  <command name="DiskFree">
    <keyword>DiskFree</keyword>
    <fullCommand>DiskFree</fullCommand>
    <parameters />
    <shortDescription>No. free bytes on last analyzed disk.</shortDescription>
    <longDescription />
  </command>
  <command name="MoveFile">
    <keyword>MoveFile</keyword>
    <fullCommand>MoveFile [success=] MoveFile(Source$,Dest$)</fullCommand>
    <parameters>[success=] MoveFile(Source$,Dest$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetAssigns">
    <keyword>GetAssigns</keyword>
    <fullCommand>GetAssigns(Type)</fullCommand>
    <parameters>(Type)</parameters>
    <shortDescription>Types are: 0=Devices, 1=Directories 2=Volumes.</shortDescription>
    <longDescription />
  </command>
  <command name="Assign$">
    <keyword>Assign$</keyword>
    <fullCommand>Assign$</fullCommand>
    <parameters />
    <shortDescription>Null-string indicates end of list.</shortDescription>
    <longDescription />
  </command>
  <command name="Examine">
    <keyword>Examine</keyword>
    <fullCommand>Examine [success=] Examine(Pathname$)</fullCommand>
    <parameters>[success=] Examine(Pathname$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetFileComment">
    <keyword>SetFileComment</keyword>
    <fullCommand>SetFileComment [success=] SetFileComment(Filename$,Comment$)</fullCommand>
    <parameters>[success=] SetFileComment(Filename$,Comment$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetBits">
    <keyword>SetBits</keyword>
    <fullCommand>SetBits [success=] SetBits(Bits$,Filename$)</fullCommand>
    <parameters>[success=] SetBits(Bits$,Filename$)</parameters>
    <shortDescription>&lt;HSPARWED&gt;.</shortDescription>
    <longDescription />
  </command>
  <command name="SetWildString">
    <keyword>SetWildString</keyword>
    <fullCommand>SetWildString [result=] SetWildString(Pattern$)</fullCommand>
    <parameters>[result=] SetWildString(Pattern$)</parameters>
    <shortDescription>0=Failed, 1=Found WildCards, 2=No WildCards.</shortDescription>
    <longDescription />
  </command>
  <command name="MatchWild">
    <keyword>MatchWild</keyword>
    <fullCommand>MatchWild(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription>TRUE=Match, FALSE=No Match.</shortDescription>
    <longDescription />
  </command>
  <command name="DosError$">
    <keyword>DosError$</keyword>
    <fullCommand>DosError$</fullCommand>
    <parameters />
    <shortDescription>Reason for last failed DOS action.</shortDescription>
    <longDescription />
  </command>
  <command name="DiskState">
    <keyword>DiskState</keyword>
    <fullCommand>DiskState</fullCommand>
    <parameters />
    <shortDescription>0=Write-Protected, 1=Validating, 2=Validated.</shortDescription>
    <longDescription />
  </command>
  <command name="DiskType$">
    <keyword>DiskType$</keyword>
    <fullCommand>DiskType$</fullCommand>
    <parameters />
    <shortDescription>4-char string ID.</shortDescription>
    <longDescription />
  </command>
  <command name="FilePart$">
    <keyword>FilePart$</keyword>
    <fullCommand>FilePart$(FullPath$)</fullCommand>
    <parameters>(FullPath$)</parameters>
    <shortDescription>"DH0:S/User-Startup" -&gt; "User-Startup".</shortDescription>
    <longDescription />
  </command>
  <command name="PathPart$">
    <keyword>PathPart$</keyword>
    <fullCommand>PathPart$(FullPath$)</fullCommand>
    <parameters>(FullPath$)</parameters>
    <shortDescription>"DH0:S/User-Startup" -&gt; "DH0:S".</shortDescription>
    <longDescription />
  </command>
  <command name="FullPath$">
    <keyword>FullPath$</keyword>
    <fullCommand>FullPath$(PathPart$,FilePart$)</fullCommand>
    <parameters>(PathPart$,FilePart$)</parameters>
    <shortDescription>"DH0:S" + "User-Startup" -&gt; "DH0:S/User-Startup".</shortDescription>
    <longDescription />
  </command>
  <command name="NoMoreEntries">
    <keyword>NoMoreEntries</keyword>
    <fullCommand>NoMoreEntries</fullCommand>
    <parameters />
    <shortDescription>Release lock on currently Examined object.</shortDescription>
    <longDescription />
  </command>
  <command name="GetLocal$">
    <keyword>GetLocal$</keyword>
    <fullCommand>GetLocal$(Name$)</fullCommand>
    <parameters>(Name$)</parameters>
    <shortDescription>Returns DOS local variable.</shortDescription>
    <longDescription />
  </command>
  <command name="GetEnv$">
    <keyword>GetEnv$</keyword>
    <fullCommand>GetEnv$(Name$)</fullCommand>
    <parameters>(Name$)</parameters>
    <shortDescription>Returns DOS environmental variable.</shortDescription>
    <longDescription />
  </command>
  <command name="SetLocal">
    <keyword>SetLocal</keyword>
    <fullCommand>SetLocal [success=] SetLocal(Name$,Value$)</fullCommand>
    <parameters>[success=] SetLocal(Name$,Value$)</parameters>
    <shortDescription>Sets DOS local variable.</shortDescription>
    <longDescription />
  </command>
  <command name="SetEnv">
    <keyword>SetEnv</keyword>
    <fullCommand>SetEnv [success=] SetEnv(Name$,Value$)</fullCommand>
    <parameters>[success=] SetEnv(Name$,Value$)</parameters>
    <shortDescription>Sets DOS environmental variable.</shortDescription>
    <longDescription />
  </command>
  <command name="UnSetLocal">
    <keyword>UnSetLocal</keyword>
    <fullCommand>UnSetLocal [success=] UnSetLocal(Name$)</fullCommand>
    <parameters>[success=] UnSetLocal(Name$)</parameters>
    <shortDescription>Removes DOS local variable.</shortDescription>
    <longDescription />
  </command>
  <command name="UnSetEnv">
    <keyword>UnSetEnv</keyword>
    <fullCommand>UnSetEnv [success=] UnSetEnv(Name$)</fullCommand>
    <parameters>[success=] UnSetEnv(Name$)</parameters>
    <shortDescription>Removes DOS environmental variable.</shortDescription>
    <longDescription />
  </command>
  <command name="Run">
    <keyword>Run</keyword>
    <fullCommand>Run [*Process=] Run(Filename$,Args$[,StackSize])</fullCommand>
    <parameters>[*Process=] Run(Filename$,Args$[,StackSize])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ComparePaths">
    <keyword>ComparePaths</keyword>
    <fullCommand>ComparePaths(Path1$,Path2$)</fullCommand>
    <parameters>(Path1$,Path2$)</parameters>
    <shortDescription>0=Unrelated, 1=Same Dir or File, 2=On Same Volume.</shortDescription>
    <longDescription />
  </command>
  <command name="Assign">
    <keyword>Assign</keyword>
    <fullCommand>Assign [success=] Assign(Name$,ToPath$)</fullCommand>
    <parameters>[success=] Assign(Name$,ToPath$)</parameters>
    <shortDescription>e.g. Assign "Blitz2:","DH1:Blitz2".</shortDescription>
    <longDescription />
  </command>
  <command name="Exec">
    <keyword>Exec</keyword>
    <fullCommand>Exec DosCommands$</fullCommand>
    <parameters>DosCommands$</parameters>
    <shortDescription>String is executed.</shortDescription>
    <longDescription />
  </command>
  <command name="WriteCD32Mem">
    <keyword>WriteCD32Mem</keyword>
    <fullCommand>WriteCD32Mem(AppName$,FileName$,Address,Length/10)</fullCommand>
    <parameters>(AppName$,FileName$,Address,Length/10)</parameters>
    <shortDescription />
    <longDescription>Writes to the non-volatile memory of the CD32 from a memory location.
The length is in multiples of 10 bytes.</longDescription>
  </command>
  <command name="ReadCD32Mem">
    <keyword>ReadCD32Mem</keyword>
    <fullCommand>ReadCD32Mem(AppName$,FileName$,Address,Length/10)</fullCommand>
    <parameters>(AppName$,FileName$,Address,Length/10)</parameters>
    <shortDescription />
    <longDescription>Reads the non-volatile memory of the CD32 to a memory location. The
length is in multiples of 10 bytes.</longDescription>
  </command>
  <command name="InitCD32">
    <keyword>InitCD32</keyword>
    <fullCommand>InitCD32</fullCommand>
    <parameters />
    <shortDescription>returns true if ok, false if fails.</shortDescription>
    <longDescription>If InitCD32 returns true then it is ok to use the following
commands, if false then no there is no cd32 or compatible
available so don't even try.</longDescription>
  </command>
  <command name="ExamineCD32">
    <keyword>ExamineCD32</keyword>
    <fullCommand>ExamineCD32</fullCommand>
    <parameters />
    <shortDescription>-1=programdisk 0=nodisk n=number of tracks.</shortDescription>
    <longDescription>ExamineCD32 is useful for programs that allow disk swapping,
it can be used to ensure the programdisk that the game was run
from is present, or if there is no disk or if a standard music
CD has been inserted. It is feasible that you allow users to
play music cd's while playing you game and then be able to ask
them to insert the game disk when more data is required.</longDescription>
  </command>
  <command name="PlayCD32">
    <keyword>PlayCD32</keyword>
    <fullCommand>PlayCD32 track#[,numtracks]</fullCommand>
    <parameters>track#[,numtracks]</parameters>
    <shortDescription />
    <longDescription>Makes the CD32 go boom tiddly pom depending on what type of
music track is specified... ie should/will/definately play
start the CD32 playing the track sprecified.</longDescription>
  </command>
  <command name="StopCD32">
    <keyword>StopCD32</keyword>
    <fullCommand>StopCD32</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription>No explanation necessary, well it is sort of self explanatory...</longDescription>
  </command>
  <command name="ControlCD32">
    <keyword>ControlCD32</keyword>
    <fullCommand>ControlCD32</fullCommand>
    <parameters />
    <shortDescription>0=play 1=pause 2=ffwd 3=rewind.</shortDescription>
    <longDescription>Yup, pretty straight forward here.</longDescription>
  </command>
  <command name="TocCD32">
    <keyword>TocCD32</keyword>
    <fullCommand>TocCD32</fullCommand>
    <parameters />
    <shortDescription>returns location of the toc read by Examine.</shortDescription>
    <longDescription>Hmmm, demo code required here. After using the ExamineCD32 command
you can find out the length of each track by examining the TOC data
(Table Of Contents) a sort of Audio CD directory command.</longDescription>
  </command>
  <command name="ConfigCD32">
    <keyword>ConfigCD32</keyword>
    <fullCommand>ConfigCD32 [&amp;TagList]</fullCommand>
    <parameters>[&amp;TagList]</parameters>
    <shortDescription>can return &amp;currentconfig.</shortDescription>
    <longDescription>Tags are available for 2x speed and 1xspeed and other things.
Interesting to note any CD can be turned into the chipmunk
edition by telling CD32 to switch to 2xspeed and then using
playtrack, or was that playtrack and then 2xspeed... Anyway
it does work.</longDescription>
  </command>
  <command name="ReadCD32">
    <keyword>ReadCD32</keyword>
    <fullCommand>ReadCD32(CD_Offset,Address,Length)</fullCommand>
    <parameters>(CD_Offset,Address,Length)</parameters>
    <shortDescription />
    <longDescription>Wo, only good for lowlevel people who want to protect their
software in more ways than one. Using commands like this will
definately make your game non hard drive installable.</longDescription>
  </command>
  <command name="GetIconInfo">
    <keyword>GetIconInfo</keyword>
    <fullCommand>GetIconInfo</fullCommand>
    <parameters />
    <shortDescription>success.w=GetIconInfo(Info#,filename$)  -1=ok, 0=fail.</shortDescription>
    <longDescription />
  </command>
  <command name="IconTool$">
    <keyword>IconTool$</keyword>
    <fullCommand>IconTool$</fullCommand>
    <parameters />
    <shortDescription>tool$=IconTool$(Info#,type$)  Empty string=NOT FOUND.</shortDescription>
    <longDescription />
  </command>
  <command name="IconType">
    <keyword>IconType</keyword>
    <fullCommand>IconType</fullCommand>
    <parameters />
    <shortDescription>type.w=IconType(Info#)  Returns the icon type. #WBDRAWER,#WBTOOL etc..</shortDescription>
    <longDescription />
  </command>
  <command name="IconDefTool$">
    <keyword>IconDefTool$</keyword>
    <fullCommand>IconDefTool$</fullCommand>
    <parameters />
    <shortDescription>deftool$=IconDefTool$(Info#)  Returns the icons default tool.</shortDescription>
    <longDescription />
  </command>
  <command name="IconStack">
    <keyword>IconStack</keyword>
    <fullCommand>IconStack</fullCommand>
    <parameters />
    <shortDescription>stackSize.l=IconType(Info#)  Returns the stack size set in the icon.</shortDescription>
    <longDescription />
  </command>
  <command name="IconSubTool$">
    <keyword>IconSubTool$</keyword>
    <fullCommand>IconSubTool$</fullCommand>
    <parameters />
    <shortDescription>boolean.w=IconSubTool$(type$,sub$) -1=Found  0=Not found.</shortDescription>
    <longDescription />
  </command>
  <command name="XBDiskPlay">
    <keyword>XBDiskPlay</keyword>
    <fullCommand>XBDiskPlay Filename$,Channelmask[,Vol1[,Vol2...]]</fullCommand>
    <parameters>Filename$,Channelmask[,Vol1[,Vol2...]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XBDiskBuffer">
    <keyword>XBDiskBuffer</keyword>
    <fullCommand>XBDiskBuffer Bufferlen</fullCommand>
    <parameters>Bufferlen</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XBLoadSound">
    <keyword>XBLoadSound</keyword>
    <fullCommand>XBLoadSound Sound#,Filename$</fullCommand>
    <parameters>Sound#,Filename$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XBSound">
    <keyword>XBSound</keyword>
    <fullCommand>XBSound Sound#,Channelmask[,Vol1[,Vol2...]]</fullCommand>
    <parameters>Sound#,Channelmask[,Vol1[,Vol2...]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XBVolume">
    <keyword>XBVolume</keyword>
    <fullCommand>XBVolume Channelmask,Vol1[,Vol2...]</fullCommand>
    <parameters>Channelmask,Vol1[,Vol2...]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XBFilter">
    <keyword>XBFilter</keyword>
    <fullCommand>XBFilter On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XBLoopSound">
    <keyword>XBLoopSound</keyword>
    <fullCommand>XBLoopSound Sound#,Channelmask[,Vol1[,Vol2...]]</fullCommand>
    <parameters>Sound#,Channelmask[,Vol1[,Vol2...]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XBInitSound">
    <keyword>XBInitSound</keyword>
    <fullCommand>XBInitSound Sound#,Length[,Period[,Repeat]]</fullCommand>
    <parameters>Sound#,Length[,Period[,Repeat]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XBSoundData">
    <keyword>XBSoundData</keyword>
    <fullCommand>XBSoundData Sound#,Offset,Data</fullCommand>
    <parameters>Sound#,Offset,Data</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XBPeekSound">
    <keyword>XBPeekSound</keyword>
    <fullCommand>XBPeekSound(Sound#,Offset)</fullCommand>
    <parameters>(Sound#,Offset)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XBDecodeSound">
    <keyword>XBDecodeSound</keyword>
    <fullCommand>XBDecodeSound Sound#,MemoryLocation</fullCommand>
    <parameters>Sound#,MemoryLocation</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XBSetPeriod">
    <keyword>XBSetPeriod</keyword>
    <fullCommand>XBSetPeriod Sound#,Period</fullCommand>
    <parameters>Sound#,Period</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CMPMEM">
    <keyword>CMPMEM</keyword>
    <fullCommand>CMPMEM(source,dest,length) 0=same,-1 source&lt;dest, +1 source&gt;dest</fullCommand>
    <parameters>(source,dest,length) 0=same,-1 source&lt;dest, +1 source&gt;dest</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrToFls">
    <keyword>StrToFls</keyword>
    <fullCommand>StrToFls string$,destvar,maxlength[,fillchar]</fullCommand>
    <parameters>string$,destvar,maxlength[,fillchar]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FlsToStr$">
    <keyword>FlsToStr$</keyword>
    <fullCommand>FlsToStr$(startaddr of FLS, maxlength)</fullCommand>
    <parameters>(startaddr of FLS, maxlength)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBInit">
    <keyword>DBInit</keyword>
    <fullCommand>DBInit(object#,init recs, exp recs,rec struct[,keylength[,offset]])</fullCommand>
    <parameters>(object#,init recs, exp recs,rec struct[,keylength[,offset]])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBlistaddr">
    <keyword>DBlistaddr</keyword>
    <fullCommand>DBlistaddr(database #) gives address of nodelist header</fullCommand>
    <parameters>(database #) gives address of nodelist header</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBfirst">
    <keyword>DBfirst</keyword>
    <fullCommand>DBfirst(database #) set pointer to the first database entry</fullCommand>
    <parameters>(database #) set pointer to the first database entry</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBlast">
    <keyword>DBlast</keyword>
    <fullCommand>DBlast(database #) set pointer to the last database entry</fullCommand>
    <parameters>(database #) set pointer to the last database entry</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBnext">
    <keyword>DBnext</keyword>
    <fullCommand>DBnext(database #) set pointer to the next database entry</fullCommand>
    <parameters>(database #) set pointer to the next database entry</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBprev">
    <keyword>DBprev</keyword>
    <fullCommand>DBprev(database #) set pointer to the previous database entry</fullCommand>
    <parameters>(database #) set pointer to the previous database entry</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBaddLast">
    <keyword>DBaddLast</keyword>
    <fullCommand>DBaddLast(database #,record var) add record to database</fullCommand>
    <parameters>(database #,record var) add record to database</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBaddFirst">
    <keyword>DBaddFirst</keyword>
    <fullCommand>DBaddFirst(database #,record var) add record to database</fullCommand>
    <parameters>(database #,record var) add record to database</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBadd">
    <keyword>DBadd</keyword>
    <fullCommand>DBadd(database #,record var) add record to database</fullCommand>
    <parameters>(database #,record var) add record to database</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBrecs">
    <keyword>DBrecs</keyword>
    <fullCommand>DBrecs(database #) gives number of records in database</fullCommand>
    <parameters>(database #) gives number of records in database</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBget">
    <keyword>DBget</keyword>
    <fullCommand>DBget(database #,record var) get current record from database</fullCommand>
    <parameters>(database #,record var) get current record from database</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBkill">
    <keyword>DBkill</keyword>
    <fullCommand>DBkill(database #) kill current database</fullCommand>
    <parameters>(database #) kill current database</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBdelete">
    <keyword>DBdelete</keyword>
    <fullCommand>DBdelete database # delete current entry in database</fullCommand>
    <parameters>database # delete current entry in database</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBsetpos">
    <keyword>DBsetpos</keyword>
    <fullCommand>DBsetpos database #,recs   &gt;sets current entry a number of records from start of database</fullCommand>
    <parameters>database #,recs   &gt;sets current entry a number of records from start of database</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBCasesense">
    <keyword>DBCasesense</keyword>
    <fullCommand>DBCasesense On|Off   Switch search case sensitivity on or off</fullCommand>
    <parameters>On|Off   Switch search case sensitivity on or off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBsetkey">
    <keyword>DBsetkey</keyword>
    <fullCommand>DBsetkey database #,On|Off  switch keying On / Off For database</fullCommand>
    <parameters>database #,On|Off  switch keying On / Off For database</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBmemtype">
    <keyword>DBmemtype</keyword>
    <fullCommand>DBmemtype memtype  define type of memory to store database</fullCommand>
    <parameters>memtype  define type of memory to store database</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBfind">
    <keyword>DBfind</keyword>
    <fullCommand>DBfind(database #,searchstring$[,length,offset[,startrec]])</fullCommand>
    <parameters>(database #,searchstring$[,length,offset[,startrec]])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBfindnext">
    <keyword>DBfindnext</keyword>
    <fullCommand>DBfindnext(database #)</fullCommand>
    <parameters>(database #)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBupdate">
    <keyword>DBupdate</keyword>
    <fullCommand>DBupdate database #,record variable</fullCommand>
    <parameters>database #,record variable</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBSave">
    <keyword>DBSave</keyword>
    <fullCommand>DBSave Database#,filename$</fullCommand>
    <parameters>Database#,filename$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBLoad">
    <keyword>DBLoad</keyword>
    <fullCommand>DBLoad Database#,filename$</fullCommand>
    <parameters>Database#,filename$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBisnext">
    <keyword>DBisnext</keyword>
    <fullCommand>DBisnext(Database#)</fullCommand>
    <parameters>(Database#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBisprev">
    <keyword>DBisprev</keyword>
    <fullCommand>DBisprev(Database#)</fullCommand>
    <parameters>(Database#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBcurrent">
    <keyword>DBcurrent</keyword>
    <fullCommand>DBcurrent(Database#)</fullCommand>
    <parameters>(Database#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBmodified">
    <keyword>DBmodified</keyword>
    <fullCommand>DBmodified(Database#)</fullCommand>
    <parameters>(Database#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBactive">
    <keyword>DBactive</keyword>
    <fullCommand>DBactive(Database#) Is a database active or not ?</fullCommand>
    <parameters>(Database#) Is a database active or not ?</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBpush">
    <keyword>DBpush</keyword>
    <fullCommand>DBpush(Database#) hold onto this record</fullCommand>
    <parameters>(Database#) hold onto this record</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DBpop">
    <keyword>DBpop</keyword>
    <fullCommand>DBpop(Database#) retrieve a pushed record</fullCommand>
    <parameters>(Database#) retrieve a pushed record</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitChunky">
    <keyword>InitChunky</keyword>
    <fullCommand>InitChunky Chunky#,width,height,flags (1=24bit 2=8bit)</fullCommand>
    <parameters>Chunky#,width,height,flags (1=24bit 2=8bit)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeChunky">
    <keyword>FreeChunky</keyword>
    <fullCommand>FreeChunky Chunky#</fullCommand>
    <parameters>Chunky#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LoadChunky">
    <keyword>LoadChunky</keyword>
    <fullCommand>LoadChunky Chunky#,IFFfilename$</fullCommand>
    <parameters>Chunky#,IFFfilename$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SaveChunky">
    <keyword>SaveChunky</keyword>
    <fullCommand>SaveChunky Chunky#,IFFfilename$</fullCommand>
    <parameters>Chunky#,IFFfilename$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadChunky">
    <keyword>ReadChunky</keyword>
    <fullCommand>ReadChunky Chunky#,rawfilename$</fullCommand>
    <parameters>Chunky#,rawfilename$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WriteChunky">
    <keyword>WriteChunky</keyword>
    <fullCommand>WriteChunky Chunky#,rawfilename$</fullCommand>
    <parameters>Chunky#,rawfilename$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ProcessChunky">
    <keyword>ProcessChunky</keyword>
    <fullCommand>ProcessChunky chunky#,contrast</fullCommand>
    <parameters>chunky#,contrast</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AdjustChunky">
    <keyword>AdjustChunky</keyword>
    <fullCommand>AdjustChunky chunky#,DeltaRed,DeltaGreen,DeltaBlue,</fullCommand>
    <parameters>chunky#,DeltaRed,DeltaGreen,DeltaBlue,</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ScaleChunkyX">
    <keyword>ScaleChunkyX</keyword>
    <fullCommand>ScaleChunkyX srcchunky#,destchunky#,newwidth</fullCommand>
    <parameters>srcchunky#,destchunky#,newwidth</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ScaleChunkyY">
    <keyword>ScaleChunkyY</keyword>
    <fullCommand>ScaleChunkyY srcchunky#,destchunky#,newheight</fullCommand>
    <parameters>srcchunky#,destchunky#,newheight</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopyChunky">
    <keyword>CopyChunky</keyword>
    <fullCommand>CopyChunky srcchunky#,destchunky#,[sx,sy,w,h,dx,dy]</fullCommand>
    <parameters>srcchunky#,destchunky#,[sx,sy,w,h,dx,dy]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GreyChunky">
    <keyword>GreyChunky</keyword>
    <fullCommand>GreyChunky chunky#</fullCommand>
    <parameters>chunky#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="KillGreyChunky">
    <keyword>KillGreyChunky</keyword>
    <fullCommand>KillGreyChunky chunky#</fullCommand>
    <parameters>chunky#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ColorChunky">
    <keyword>ColorChunky</keyword>
    <fullCommand>ColorChunky chunky#</fullCommand>
    <parameters>chunky#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChunkyLoc">
    <keyword>ChunkyLoc</keyword>
    <fullCommand>ChunkyLoc chunky#</fullCommand>
    <parameters>chunky#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChunkyConvert">
    <keyword>ChunkyConvert</keyword>
    <fullCommand>ChunkyConvert chunky#[,palette]|[,array.l(),numcols]</fullCommand>
    <parameters>chunky#[,palette]|[,array.l(),numcols]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChunkyToBitMap">
    <keyword>ChunkyToBitMap</keyword>
    <fullCommand>ChunkyToBitMap Chunky#,Bitmap#</fullCommand>
    <parameters>Chunky#,Bitmap#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CPlot">
    <keyword>CPlot</keyword>
    <fullCommand>CPlot Chunky#,x,y[,color.l],[red.b,green.b,blue.b]</fullCommand>
    <parameters>Chunky#,x,y[,color.l],[red.b,green.b,blue.b]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GPlot">
    <keyword>GPlot</keyword>
    <fullCommand>GPlot Chunky#,x,y,color.b</fullCommand>
    <parameters>Chunky#,x,y,color.b</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CPoint">
    <keyword>CPoint</keyword>
    <fullCommand>CPoint(Chunky#,x,y)</fullCommand>
    <parameters>(Chunky#,x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GPoint">
    <keyword>GPoint</keyword>
    <fullCommand>GPoint(Chunky#,x,y)</fullCommand>
    <parameters>(Chunky#,x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Col8">
    <keyword>Col8</keyword>
    <fullCommand>Col8(array.l(),numcols,rgb.l)</fullCommand>
    <parameters>(array.l(),numcols,rgb.l)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ModuleSampleName">
    <keyword>ModuleSampleName</keyword>
    <fullCommand>ModuleSampleName(Module#,Sample#[0-30])</fullCommand>
    <parameters>(Module#,Sample#[0-30])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPatternPosition">
    <keyword>GetPatternPosition</keyword>
    <fullCommand>GetPatternPosition</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetSongPatternPosition">
    <keyword>SetSongPatternPosition</keyword>
    <fullCommand>SetSongPatternPosition Pattern#,Position#</fullCommand>
    <parameters>Pattern#,Position#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetTrackerVolume">
    <keyword>GetTrackerVolume</keyword>
    <fullCommand>GetTrackerVolume(TrackerChannel#)</fullCommand>
    <parameters>(TrackerChannel#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetTrackerNote">
    <keyword>GetTrackerNote</keyword>
    <fullCommand>GetTrackerNote(TrackerChannel#)</fullCommand>
    <parameters>(TrackerChannel#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetTrackerTempo">
    <keyword>SetTrackerTempo</keyword>
    <fullCommand>SetTrackerTempo Tempo</fullCommand>
    <parameters>Tempo</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetTrackerInstrument">
    <keyword>GetTrackerInstrument</keyword>
    <fullCommand>GetTrackerInstrument(TrackerChannel#)</fullCommand>
    <parameters>(TrackerChannel#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetSongPosition">
    <keyword>GetSongPosition</keyword>
    <fullCommand>GetSongPosition</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetSongLength">
    <keyword>GetSongLength</keyword>
    <fullCommand>GetSongLength</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="StartTrackerPatPos">
    <keyword>StartTrackerPatPos</keyword>
    <fullCommand>StartTrackerPatPos(TrackerModule#,Pattern#,Position#)</fullCommand>
    <parameters>(TrackerModule#,Pattern#,Position#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetSampleLocation">
    <keyword>GetSampleLocation</keyword>
    <fullCommand>GetSampleLocation(Sample#)</fullCommand>
    <parameters>(Sample#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetSampleLength">
    <keyword>GetSampleLength</keyword>
    <fullCommand>GetSampleLength(Sample#)</fullCommand>
    <parameters>(Sample#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetSampleName">
    <keyword>GetSampleName</keyword>
    <fullCommand>GetSampleName(Sample#)</fullCommand>
    <parameters>(Sample#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BuildNoteTable">
    <keyword>BuildNoteTable</keyword>
    <fullCommand>BuildNoteTable</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetTrackerNoteNumber">
    <keyword>GetTrackerNoteNumber</keyword>
    <fullCommand>GetTrackerNoteNumber(TrackerChannel#)</fullCommand>
    <parameters>(TrackerChannel#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TrackerPlayLoop">
    <keyword>TrackerPlayLoop</keyword>
    <fullCommand>TrackerPlayLoop(Continuous play.)</fullCommand>
    <parameters>(Continuous play.)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TrackerPlayOnce">
    <keyword>TrackerPlayOnce</keyword>
    <fullCommand>TrackerPlayOnce(Play module once then stop.)</fullCommand>
    <parameters>(Play module once then stop.)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TrackerModuleEnd">
    <keyword>TrackerModuleEnd</keyword>
    <fullCommand>TrackerModuleEnd(TRUE if module has finished playing.)</fullCommand>
    <parameters>(TRUE if module has finished playing.)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TrackerDeInitialise">
    <keyword>TrackerDeInitialise</keyword>
    <fullCommand>TrackerDeInitialise(De-Allocates CIA timers)</fullCommand>
    <parameters>(De-Allocates CIA timers)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TrackerReInitialise">
    <keyword>TrackerReInitialise</keyword>
    <fullCommand>TrackerReInitialise(Re-Allocates CIA timers)</fullCommand>
    <parameters>(Re-Allocates CIA timers)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="STCLength">
    <keyword>STCLength</keyword>
    <fullCommand>STCLength address   -</fullCommand>
    <parameters>address   -</parameters>
    <shortDescription>returns unpacked size.</shortDescription>
    <longDescription />
  </command>
  <command name="STCStart">
    <keyword>STCStart</keyword>
    <fullCommand>STCStart address   -</fullCommand>
    <parameters>address   -</parameters>
    <shortDescription>returns address of unpacked data.</shortDescription>
    <longDescription />
  </command>
  <command name="STCSafeLen">
    <keyword>STCSafeLen</keyword>
    <fullCommand>STCSafeLen address   -</fullCommand>
    <parameters>address   -</parameters>
    <shortDescription>safe unpack buffer size.</shortDescription>
    <longDescription />
  </command>
  <command name="STCLoad">
    <keyword>STCLoad</keyword>
    <fullCommand>STCLoad filename$,address</fullCommand>
    <parameters>filename$,address</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="STCDecrunch">
    <keyword>STCDecrunch</keyword>
    <fullCommand>STCDecrunch source[,dest]</fullCommand>
    <parameters>source[,dest]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CludgeSound">
    <keyword>CludgeSound</keyword>
    <fullCommand>CludgeSound sound#,address</fullCommand>
    <parameters>sound#,address</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CludgeShapes">
    <keyword>CludgeShapes</keyword>
    <fullCommand>CludgeShapes shape#,numshapes,address</fullCommand>
    <parameters>shape#,numshapes,address</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SafeToBlit">
    <keyword>SafeToBlit</keyword>
    <fullCommand>SafeToBlit shape,x,y</fullCommand>
    <parameters>shape,x,y</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LELoadShapes">
    <keyword>LELoadShapes</keyword>
    <fullCommand>LELoadShapes shape#[,shape#],filename$[,palette#]</fullCommand>
    <parameters>shape#[,shape#],filename$[,palette#]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LESaveShapes">
    <keyword>LESaveShapes</keyword>
    <fullCommand>LESaveShapes shape#,shape#,filename$[,palette#]</fullCommand>
    <parameters>shape#,shape#,filename$[,palette#]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LECompressShapes">
    <keyword>LECompressShapes</keyword>
    <fullCommand>LECompressShapes True|False</fullCommand>
    <parameters>True|False</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LECludgeShapes">
    <keyword>LECludgeShapes</keyword>
    <fullCommand>LECludgeShapes shape#,shape#,address,palette#[,copymemflag]</fullCommand>
    <parameters>shape#,shape#,address,palette#[,copymemflag]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LEInitShape">
    <keyword>LEInitShape</keyword>
    <fullCommand>LEInitShape shape#,width,height,depth</fullCommand>
    <parameters>shape#,width,height,depth</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LEScanShapes">
    <keyword>LEScanShapes</keyword>
    <fullCommand>LEScanShapes startshape#,endshape#</fullCommand>
    <parameters>startshape#,endshape#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LEMaxShapeWidth">
    <keyword>LEMaxShapeWidth</keyword>
    <fullCommand>LEMaxShapeWidth</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="LEMaxShapeHeight">
    <keyword>LEMaxShapeHeight</keyword>
    <fullCommand>LEMaxShapeHeight</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="LEMaxShapeDepth">
    <keyword>LEMaxShapeDepth</keyword>
    <fullCommand>LEMaxShapeDepth</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsNonvolatile">
    <keyword>IsNonvolatile</keyword>
    <fullCommand>IsNonvolatile -</fullCommand>
    <parameters>-</parameters>
    <shortDescription>returns true if library is open.</shortDescription>
    <longDescription />
  </command>
  <command name="StoreNVData">
    <keyword>StoreNVData</keyword>
    <fullCommand>StoreNVData AppName,ItemName,data,byte_length</fullCommand>
    <parameters>AppName,ItemName,data,byte_length</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetCopyNV">
    <keyword>GetCopyNV</keyword>
    <fullCommand>GetCopyNV AppName,ItemName</fullCommand>
    <parameters>AppName,ItemName</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeNVData">
    <keyword>FreeNVData</keyword>
    <fullCommand>FreeNVData APTR</fullCommand>
    <parameters>APTR</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetNVList">
    <keyword>GetNVList</keyword>
    <fullCommand>GetNVList appname</fullCommand>
    <parameters>appname</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TimerReset">
    <keyword>TimerReset</keyword>
    <fullCommand>TimerReset</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="PortSigBit">
    <keyword>PortSigBit</keyword>
    <fullCommand>PortSigBit msgport</fullCommand>
    <parameters>msgport</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WorkbenchHere">
    <keyword>WorkbenchHere</keyword>
    <fullCommand>WorkbenchHere</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="EZRequest">
    <keyword>EZRequest</keyword>
    <fullCommand>EZRequest [title$,]body$[,gadget$] | title$,body$,gadget$[,var..]</fullCommand>
    <parameters>[title$,]body$[,gadget$] | title$,body$,gadget$[,var..]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Flip$">
    <keyword>Flip$</keyword>
    <fullCommand>Flip$(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitArgParse">
    <keyword>InitArgParse</keyword>
    <fullCommand>InitArgParse parameter$</fullCommand>
    <parameters>parameter$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NextArg$">
    <keyword>NextArg$</keyword>
    <fullCommand>NextArg$</fullCommand>
    <parameters />
    <shortDescription>get next parameter.</shortDescription>
    <longDescription />
  </command>
  <command name="EZOutput">
    <keyword>EZOutput</keyword>
    <fullCommand>EZOutput [win#]</fullCommand>
    <parameters>[win#]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EZRequestArgs">
    <keyword>EZRequestArgs</keyword>
    <fullCommand>EZRequestArgs args..</fullCommand>
    <parameters>args..</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EZSeparator">
    <keyword>EZSeparator</keyword>
    <fullCommand>EZSeparator char</fullCommand>
    <parameters>char</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClickWait">
    <keyword>ClickWait</keyword>
    <fullCommand>ClickWait</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ProgPath$">
    <keyword>ProgPath$</keyword>
    <fullCommand>ProgPath$</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ProgDir$">
    <keyword>ProgDir$</keyword>
    <fullCommand>ProgDir$</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="ProgName$">
    <keyword>ProgName$</keyword>
    <fullCommand>ProgName$</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="FromBlitz">
    <keyword>FromBlitz</keyword>
    <fullCommand>FromBlitz</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="LtoS">
    <keyword>LtoS</keyword>
    <fullCommand>LtoS(longword) -</fullCommand>
    <parameters>(longword) -</parameters>
    <shortDescription>convert LONG to STRING.</shortDescription>
    <longDescription />
  </command>
  <command name="ASCRaw">
    <keyword>ASCRaw</keyword>
    <fullCommand>ASCRaw(rawkey)</fullCommand>
    <parameters>(rawkey)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RawASC">
    <keyword>RawASC</keyword>
    <fullCommand>RawASC(char)</fullCommand>
    <parameters>(char)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenFontPrefs">
    <keyword>OpenFontPrefs</keyword>
    <fullCommand>OpenFontPrefs [filename$]</fullCommand>
    <parameters>[filename$]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseFontPrefs">
    <keyword>CloseFontPrefs</keyword>
    <fullCommand>CloseFontPrefs</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DefaultFontHeight">
    <keyword>DefaultFontHeight</keyword>
    <fullCommand>DefaultFontHeight fonttype  (0=Icon,1=System,2=Screen)</fullCommand>
    <parameters>fonttype  (0=Icon,1=System,2=Screen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DefaultFontName">
    <keyword>DefaultFontName</keyword>
    <fullCommand>DefaultFontName fonttype  (0=Icon,1=System,2=Screen)</fullCommand>
    <parameters>fonttype  (0=Icon,1=System,2=Screen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateMenuStrip">
    <keyword>CreateMenuStrip</keyword>
    <fullCommand>CreateMenuStrip GTMenuList#</fullCommand>
    <parameters>GTMenuList#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTSetMenu">
    <keyword>GTSetMenu</keyword>
    <fullCommand>GTSetMenu GTMenuList#</fullCommand>
    <parameters>GTMenuList#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTUnSetMenu">
    <keyword>GTUnSetMenu</keyword>
    <fullCommand>GTUnSetMenu</fullCommand>
    <parameters />
    <shortDescription>removes the gtmenulist from the current window.</shortDescription>
    <longDescription />
  </command>
  <command name="GTMenuTitle">
    <keyword>GTMenuTitle</keyword>
    <fullCommand>GTMenuTitle GTMenuList#,menu,title$</fullCommand>
    <parameters>GTMenuList#,menu,title$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTMenuItem">
    <keyword>GTMenuItem</keyword>
    <fullCommand>GTMenuItem GTMenuList#,flags,menu,item[,itemtext$[,shortcut$[,mutualexclude[,UserData]]</fullCommand>
    <parameters>GTMenuList#,flags,menu,item[,itemtext$[,shortcut$[,mutualexclude[,UserData]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTMenuState">
    <keyword>GTMenuState</keyword>
    <fullCommand>GTMenuState GTMenuList#[,Menu[,Item[,Subitem]]],On|Off</fullCommand>
    <parameters>GTMenuList#[,Menu[,Item[,Subitem]]],On|Off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTSubItem">
    <keyword>GTSubItem</keyword>
    <fullCommand>GTSubItem GTMenuList#,flags,menu,item,subitem[,itemtext$[,shortcut$[,mutualexclude[,UserData]]]]</fullCommand>
    <parameters>GTMenuList#,flags,menu,item,subitem[,itemtext$[,shortcut$[,mutualexclude[,UserData]]]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTMenuChecked">
    <keyword>GTMenuChecked</keyword>
    <fullCommand>GTMenuChecked(GTMenuList#,Menu,Item[,Subitem])</fullCommand>
    <parameters>(GTMenuList#,Menu,Item[,Subitem])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTSetMenuChecked">
    <keyword>GTSetMenuChecked</keyword>
    <fullCommand>GTSetMenuChecked GTMenuList#,Menu,Item[,Subitem],Off|On</fullCommand>
    <parameters>GTMenuList#,Menu,Item[,Subitem],Off|On</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTFreeMenu">
    <keyword>GTFreeMenu</keyword>
    <fullCommand>GTFreeMenu GTMenuList#,Menu[,Item[,Subitem]]</fullCommand>
    <parameters>GTMenuList#,Menu[,Item[,Subitem]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GTGetUserData">
    <keyword>GTGetUserData</keyword>
    <fullCommand>GTGetUserData(GTMenuList#,Menu,Item[,Subitem])</fullCommand>
    <parameters>(GTMenuList#,Menu,Item[,Subitem])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitSerialIO">
    <keyword>InitSerialIO</keyword>
    <fullCommand>InitSerialIO baud,numbytes,inbuf,outbuf</fullCommand>
    <parameters>baud,numbytes,inbuf,outbuf</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FinitSerialIO">
    <keyword>FinitSerialIO</keyword>
    <fullCommand>FinitSerialIO</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetSerialMode">
    <keyword>SetSerialMode</keyword>
    <fullCommand>SetSerialMode mode   -</fullCommand>
    <parameters>mode   -</parameters>
    <shortDescription>determine master/slave.</shortDescription>
    <longDescription />
  </command>
  <command name="EndSerialIO">
    <keyword>EndSerialIO</keyword>
    <fullCommand>EndSerialIO</fullCommand>
    <parameters />
    <shortDescription>disable serial read/write.</shortDescription>
    <longDescription />
  </command>
  <command name="PutSerial">
    <keyword>PutSerial</keyword>
    <fullCommand>PutSerial address,bytes | byte</fullCommand>
    <parameters>address,bytes | byte</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetSerial">
    <keyword>GetSerial</keyword>
    <fullCommand>GetSerial [address,bytes]</fullCommand>
    <parameters>[address,bytes]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FlushSerialIO">
    <keyword>FlushSerialIO</keyword>
    <fullCommand>FlushSerialIO</fullCommand>
    <parameters />
    <shortDescription>make sure serial port is empty.</shortDescription>
    <longDescription />
  </command>
  <command name="SyncSerial">
    <keyword>SyncSerial</keyword>
    <fullCommand>SyncSerial syncbyte</fullCommand>
    <parameters>syncbyte</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DoSerialIO">
    <keyword>DoSerialIO</keyword>
    <fullCommand>DoSerialIO [numbytes-1]</fullCommand>
    <parameters>[numbytes-1]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetIOBuffers">
    <keyword>SetIOBuffers</keyword>
    <fullCommand>SetIOBuffers inbuf,outbuf</fullCommand>
    <parameters>inbuf,outbuf</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetIOSpeed">
    <keyword>SetIOSpeed</keyword>
    <fullCommand>SetIOSpeed baudrate</fullCommand>
    <parameters>baudrate</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetIOSize">
    <keyword>SetIOSize</keyword>
    <fullCommand>SetIOSize bytes</fullCommand>
    <parameters>bytes</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CheckSerial">
    <keyword>CheckSerial</keyword>
    <fullCommand>CheckSerial</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="SyncPut">
    <keyword>SyncPut</keyword>
    <fullCommand>SyncPut address,bytes</fullCommand>
    <parameters>address,bytes</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SyncGet">
    <keyword>SyncGet</keyword>
    <fullCommand>SyncGet address,bytes</fullCommand>
    <parameters>address,bytes</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ConvToPostFix">
    <keyword>ConvToPostFix</keyword>
    <fullCommand>ConvToPostFix string,buffer</fullCommand>
    <parameters>string,buffer</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PFEvaluate">
    <keyword>PFEvaluate</keyword>
    <fullCommand>PFEvaluate(string)</fullCommand>
    <parameters>(string)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PFRegisters">
    <keyword>PFRegisters</keyword>
    <fullCommand>PFRegisters *registerblock</fullCommand>
    <parameters>*registerblock</parameters>
    <shortDescription>pointer to registers.</shortDescription>
    <longDescription />
  </command>
  <command name="PFErrorType">
    <keyword>PFErrorType</keyword>
    <fullCommand>PFErrorType</fullCommand>
    <parameters />
    <shortDescription>returns error number or 0 for none.</shortDescription>
    <longDescription />
  </command>
  <command name="PFErrorText">
    <keyword>PFErrorText</keyword>
    <fullCommand>PFErrorText</fullCommand>
    <parameters />
    <shortDescription>returns error text corresponding to error.</shortDescription>
    <longDescription />
  </command>
  <command name="PFIndirectAddr">
    <keyword>PFIndirectAddr</keyword>
    <fullCommand>PFIndirectAddr</fullCommand>
    <parameters />
    <shortDescription>returns last indirect lookup.</shortDescription>
    <longDescription />
  </command>
  <command name="AddNotify">
    <keyword>AddNotify</keyword>
    <fullCommand>AddNotify idno,filespec$</fullCommand>
    <parameters>idno,filespec$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemNotify">
    <keyword>RemNotify</keyword>
    <fullCommand>RemNotify notify#</fullCommand>
    <parameters>notify#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CheckNotify">
    <keyword>CheckNotify</keyword>
    <fullCommand>CheckNotify</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="WaitNotify">
    <keyword>WaitNotify</keyword>
    <fullCommand>WaitNotify</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDeviceList">
    <keyword>GetDeviceList</keyword>
    <fullCommand>GetDeviceList flags</fullCommand>
    <parameters>flags</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NextDevice">
    <keyword>NextDevice</keyword>
    <fullCommand>NextDevice</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeDeviceList">
    <keyword>FreeDeviceList</keyword>
    <fullCommand>FreeDeviceList</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NotifyPort">
    <keyword>NotifyPort</keyword>
    <fullCommand>NotifyPort</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetFileName">
    <keyword>GetFileName</keyword>
    <fullCommand>GetFileName filepath$</fullCommand>
    <parameters>filepath$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPathName">
    <keyword>GetPathName</keyword>
    <fullCommand>GetPathName filepath$</fullCommand>
    <parameters>filepath$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeviceEntryType">
    <keyword>DeviceEntryType</keyword>
    <fullCommand>DeviceEntryType</fullCommand>
    <parameters />
    <shortDescription>-- dev=0,dir=1,vol=2,late=3,nonbind=4.</shortDescription>
    <longDescription />
  </command>
  <command name="DataTypeOpen">
    <keyword>DataTypeOpen</keyword>
    <fullCommand>DataTypeOpen filename$</fullCommand>
    <parameters>filename$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeClose">
    <keyword>DataTypeClose</keyword>
    <fullCommand>DataTypeClose</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeName">
    <keyword>DataTypeName</keyword>
    <fullCommand>DataTypeName</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeBaseName">
    <keyword>DataTypeBaseName</keyword>
    <fullCommand>DataTypeBaseName</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeID">
    <keyword>DataTypeID</keyword>
    <fullCommand>DataTypeID</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeCreate">
    <keyword>DataTypeCreate</keyword>
    <fullCommand>DataTypeCreate [&amp;taglist]</fullCommand>
    <parameters>[&amp;taglist]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AttachDataType">
    <keyword>AttachDataType</keyword>
    <fullCommand>AttachDataType window,id[,x,y,width,height] | window,id,&amp;taglist</fullCommand>
    <parameters>window,id[,x,y,width,height] | window,id,&amp;taglist</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DetachDataType">
    <keyword>DetachDataType</keyword>
    <fullCommand>DetachDataType</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeSuper">
    <keyword>DataTypeSuper</keyword>
    <fullCommand>DataTypeSuper</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeBitmap">
    <keyword>DataTypeBitmap</keyword>
    <fullCommand>DataTypeBitmap</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypesPalette">
    <keyword>DataTypesPalette</keyword>
    <fullCommand>DataTypesPalette palette#</fullCommand>
    <parameters>palette#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeWidth">
    <keyword>DataTypeWidth</keyword>
    <fullCommand>DataTypeWidth</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeHeight">
    <keyword>DataTypeHeight</keyword>
    <fullCommand>DataTypeHeight</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeDepth">
    <keyword>DataTypeDepth</keyword>
    <fullCommand>DataTypeDepth</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeReady">
    <keyword>DataTypeReady</keyword>
    <fullCommand>DataTypeReady</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetDataTypeAttr">
    <keyword>SetDataTypeAttr</keyword>
    <fullCommand>SetDataTypeAttr &amp;taglist / attr,data[,attr,data..]</fullCommand>
    <parameters>&amp;taglist / attr,data[,attr,data..]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDataTypeAttr">
    <keyword>GetDataTypeAttr</keyword>
    <fullCommand>GetDataTypeAttr attribute</fullCommand>
    <parameters>attribute</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeModeID">
    <keyword>DataTypeModeID</keyword>
    <fullCommand>DataTypeModeID [taglist]]</fullCommand>
    <parameters>[taglist]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DataTypeGroup">
    <keyword>DataTypeGroup</keyword>
    <fullCommand>DataTypeGroup</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXCreatePort">
    <keyword>RXCreatePort</keyword>
    <fullCommand>RXCreatePort(name$)</fullCommand>
    <parameters>(name$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXDeletePort">
    <keyword>RXDeletePort</keyword>
    <fullCommand>RXDeletePort</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXReadPort">
    <keyword>RXReadPort</keyword>
    <fullCommand>RXReadPort</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXWaitPort">
    <keyword>RXWaitPort</keyword>
    <fullCommand>RXWaitPort</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXReplyMsg">
    <keyword>RXReplyMsg</keyword>
    <fullCommand>RXReplyMsg errcode[,result$]</fullCommand>
    <parameters>errcode[,result$]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXRunCommand">
    <keyword>RXRunCommand</keyword>
    <fullCommand>RXRunCommand [portname$,]command$</fullCommand>
    <parameters>[portname$,]command$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXSendersName">
    <keyword>RXSendersName</keyword>
    <fullCommand>RXSendersName</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXSendCommand">
    <keyword>RXSendCommand</keyword>
    <fullCommand>RXSendCommand [portname$,]command$</fullCommand>
    <parameters>[portname$,]command$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXNumArgs">
    <keyword>RXNumArgs</keyword>
    <fullCommand>RXNumArgs</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXGetArg">
    <keyword>RXGetArg</keyword>
    <fullCommand>RXGetArg argnum</fullCommand>
    <parameters>argnum</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXExecuteScript">
    <keyword>RXExecuteScript</keyword>
    <fullCommand>RXExecuteScript scriptname$</fullCommand>
    <parameters>scriptname$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXRunScript">
    <keyword>RXRunScript</keyword>
    <fullCommand>RXRunScript scriptname$</fullCommand>
    <parameters>scriptname$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXDefaultPort">
    <keyword>RXDefaultPort</keyword>
    <fullCommand>RXDefaultPort portname$</fullCommand>
    <parameters>portname$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXNextArg">
    <keyword>RXNextArg</keyword>
    <fullCommand>RXNextArg argnum</fullCommand>
    <parameters>argnum</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXReturnCode">
    <keyword>RXReturnCode</keyword>
    <fullCommand>RXReturnCode</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="RXTokenise">
    <keyword>RXTokenise</keyword>
    <fullCommand>RXTokenise on|off</fullCommand>
    <parameters>on|off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NInitApp">
    <keyword>NInitApp</keyword>
    <fullCommand>NInitApp(#NumMaxAppID)</fullCommand>
    <parameters>(#NumMaxAppID)</parameters>
    <shortDescription>Initialize App library for use -.</shortDescription>
    <longDescription />
  </command>
  <command name="NAddAppWindow">
    <keyword>NAddAppWindow</keyword>
    <fullCommand>NAddAppWindow(#AppID, WindowID)</fullCommand>
    <parameters>(#AppID, WindowID)</parameters>
    <shortDescription>Transform a window into AppWindow -.</shortDescription>
    <longDescription />
  </command>
  <command name="NRemoveAppWindow">
    <keyword>NRemoveAppWindow</keyword>
    <fullCommand>NRemoveAppWindow(#AppID)</fullCommand>
    <parameters>(#AppID)</parameters>
    <shortDescription>Remove the App feature -.</shortDescription>
    <longDescription />
  </command>
  <command name="NAddAppMenu">
    <keyword>NAddAppMenu</keyword>
    <fullCommand>NAddAppMenu(#AppID, &amp;Title$)</fullCommand>
    <parameters>(#AppID, &amp;Title$)</parameters>
    <shortDescription>Add a menu in the 'Tools' menu -.</shortDescription>
    <longDescription />
  </command>
  <command name="NRemoveAppMenu">
    <keyword>NRemoveAppMenu</keyword>
    <fullCommand>NRemoveAppMenu(#AppID)</fullCommand>
    <parameters>(#AppID)</parameters>
    <shortDescription>Remove the App menu -.</shortDescription>
    <longDescription />
  </command>
  <command name="NAppEvent">
    <keyword>NAppEvent</keyword>
    <fullCommand>NAppEvent</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return -1 if nothing or the #AppID -.</shortDescription>
    <longDescription />
  </command>
  <command name="NAppNumFiles">
    <keyword>NAppNumFiles</keyword>
    <fullCommand>NAppNumFiles</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return number of file dropped on the window -.</shortDescription>
    <longDescription />
  </command>
  <command name="NNextAppFile">
    <keyword>NNextAppFile</keyword>
    <fullCommand>NNextAppFile</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the next filename -.</shortDescription>
    <longDescription />
  </command>
  <command name="NASLFileRequest">
    <keyword>NASLFileRequest</keyword>
    <fullCommand>NASLFileRequest(TagList)</fullCommand>
    <parameters>(TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NASLFontRequest">
    <keyword>NASLFontRequest</keyword>
    <fullCommand>NASLFontRequest(TagList)</fullCommand>
    <parameters>(TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NASLScreenRequest">
    <keyword>NASLScreenRequest</keyword>
    <fullCommand>NASLScreenRequest(TagList)</fullCommand>
    <parameters>(TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NASLPosX">
    <keyword>NASLPosX</keyword>
    <fullCommand>NASLPosX</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the last opened ASL requester X pos -.</shortDescription>
    <longDescription />
  </command>
  <command name="NASLPosY">
    <keyword>NASLPosY</keyword>
    <fullCommand>NASLPosY</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the last opened ASL requester Y pos-.</shortDescription>
    <longDescription />
  </command>
  <command name="NASLWidth">
    <keyword>NASLWidth</keyword>
    <fullCommand>NASLWidth</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the last opened ASL requester width -.</shortDescription>
    <longDescription />
  </command>
  <command name="NASLHeight">
    <keyword>NASLHeight</keyword>
    <fullCommand>NASLHeight</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the last opened ASL requester height -.</shortDescription>
    <longDescription />
  </command>
  <command name="NInitASL">
    <keyword>NInitASL</keyword>
    <fullCommand>NInitASL</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Initialize ASL for use -.</shortDescription>
    <longDescription />
  </command>
  <command name="NUseBitMap">
    <keyword>NUseBitMap</keyword>
    <fullCommand>NUseBitMap(#BitMap)</fullCommand>
    <parameters>(#BitMap)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NBitMap">
    <keyword>NBitMap</keyword>
    <fullCommand>NBitMap(#BitMap, Width, Height, Depth)</fullCommand>
    <parameters>(#BitMap, Width, Height, Depth)</parameters>
    <shortDescription>Allocate a new bitmap -.</shortDescription>
    <longDescription />
  </command>
  <command name="NBitMapRastPort">
    <keyword>NBitMapRastPort</keyword>
    <fullCommand>NBitMapRastPort</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the used bitmap rastport -.</shortDescription>
    <longDescription />
  </command>
  <command name="NShowBitMap">
    <keyword>NShowBitMap</keyword>
    <fullCommand>NShowBitMap(#BitMap, ScreenID, x, y)</fullCommand>
    <parameters>(#BitMap, ScreenID, x, y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NFreeBitMap">
    <keyword>NFreeBitMap</keyword>
    <fullCommand>NFreeBitMap(#BitMap)</fullCommand>
    <parameters>(#BitMap)</parameters>
    <shortDescription>Free the specified bitmap -.</shortDescription>
    <longDescription />
  </command>
  <command name="NInitBitMap">
    <keyword>NInitBitMap</keyword>
    <fullCommand>NInitBitMap(#MaxNumBitMaps)</fullCommand>
    <parameters>(#MaxNumBitMaps)</parameters>
    <shortDescription>Init BitMap environnement -.</shortDescription>
    <longDescription />
  </command>
  <command name="NBitMapID">
    <keyword>NBitMapID</keyword>
    <fullCommand>NBitMapID</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the used bitmap pointer -.</shortDescription>
    <longDescription />
  </command>
  <command name="c2p040_320_200">
    <keyword>c2p040_320_200</keyword>
    <fullCommand>c2p040_320_200(ChunkyBufferAdress, BitmapAdress)</fullCommand>
    <parameters>(ChunkyBufferAdress, BitmapAdress)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="c2p040_320_256">
    <keyword>c2p040_320_256</keyword>
    <fullCommand>c2p040_320_256(ChunkyBufferAdress, BitmapAdress)</fullCommand>
    <parameters>(ChunkyBufferAdress, BitmapAdress)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NChunkyBuffer">
    <keyword>NChunkyBuffer</keyword>
    <fullCommand>NChunkyBuffer(#Buffer, Width, Height)</fullCommand>
    <parameters>(#Buffer, Width, Height)</parameters>
    <shortDescription>Allocate a chunky buffer.</shortDescription>
    <longDescription />
  </command>
  <command name="NChunkyBlit">
    <keyword>NChunkyBlit</keyword>
    <fullCommand>NChunkyBlit(ShapeWidth, ShapeHeight, ShapeAddress, X, Y)</fullCommand>
    <parameters>(ShapeWidth, ShapeHeight, ShapeAddress, X, Y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NChunkyBlock">
    <keyword>NChunkyBlock</keyword>
    <fullCommand>NChunkyBlock(ShapeWidth, ShapeHeight, ShapeAddress, X, Y)</fullCommand>
    <parameters>(ShapeWidth, ShapeHeight, ShapeAddress, X, Y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NChunkyCls">
    <keyword>NChunkyCls</keyword>
    <fullCommand>NChunkyCls(Colour)</fullCommand>
    <parameters>(Colour)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NChunkyPlot">
    <keyword>NChunkyPlot</keyword>
    <fullCommand>NChunkyPlot(X, Y, Colour)</fullCommand>
    <parameters>(X, Y, Colour)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUseChunkyBuffer">
    <keyword>NUseChunkyBuffer</keyword>
    <fullCommand>NUseChunkyBuffer(#Buffer)</fullCommand>
    <parameters>(#Buffer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NInitChunky">
    <keyword>NInitChunky</keyword>
    <fullCommand>NInitChunky(#NumObjectMax)</fullCommand>
    <parameters>(#NumObjectMax)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NFreeChunkyBuffer">
    <keyword>NFreeChunkyBuffer</keyword>
    <fullCommand>NFreeChunkyBuffer(#Buffer)</fullCommand>
    <parameters>(#Buffer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NChunkyID">
    <keyword>NChunkyID</keyword>
    <fullCommand>NChunkyID</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the chunkybuffer memory pointer.</shortDescription>
    <longDescription />
  </command>
  <command name="NSetClipText">
    <keyword>NSetClipText</keyword>
    <fullCommand>NSetClipText(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription>Change the clipboard text -.</shortDescription>
    <longDescription />
  </command>
  <command name="NGetClipText">
    <keyword>NGetClipText</keyword>
    <fullCommand>NGetClipText</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the current clipboard text -.</shortDescription>
    <longDescription />
  </command>
  <command name="NCreateCommodity">
    <keyword>NCreateCommodity</keyword>
    <fullCommand>NCreateCommodity(Objects.l, Name$, Title$, Description$, Priority.b, Flag.b)</fullCommand>
    <parameters>(Objects.l, Name$, Title$, Description$, Priority.b, Flag.b)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NActivateCommodity">
    <keyword>NActivateCommodity</keyword>
    <fullCommand>NActivateCommodity Status.l</fullCommand>
    <parameters>Status.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityActivateTranslater">
    <keyword>NCommodityActivateTranslater</keyword>
    <fullCommand>NCommodityActivateTranslater #Object.l, Status.l</fullCommand>
    <parameters>#Object.l, Status.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityActivateObject">
    <keyword>NCommodityActivateObject</keyword>
    <fullCommand>NCommodityActivateObject #Object.l, Status.l</fullCommand>
    <parameters>#Object.l, Status.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NWaitCommodityEvent">
    <keyword>NWaitCommodityEvent</keyword>
    <fullCommand>NWaitCommodityEvent</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityEvent">
    <keyword>NCommodityEvent</keyword>
    <fullCommand>NCommodityEvent</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityType">
    <keyword>NCommodityType</keyword>
    <fullCommand>NCommodityType</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityID">
    <keyword>NCommodityID</keyword>
    <fullCommand>NCommodityID</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityCtrlCSignal">
    <keyword>NCommodityCtrlCSignal</keyword>
    <fullCommand>NCommodityCtrlCSignal</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityObjectSignal">
    <keyword>NCommodityObjectSignal</keyword>
    <fullCommand>NCommodityObjectSignal</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityCreateObject">
    <keyword>NCommodityCreateObject</keyword>
    <fullCommand>NCommodityCreateObject(#Object.l, Filter$, *InputEvent)</fullCommand>
    <parameters>(#Object.l, Filter$, *InputEvent)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityDeleteObject">
    <keyword>NCommodityDeleteObject</keyword>
    <fullCommand>NCommodityDeleteObject #Object.l</fullCommand>
    <parameters>#Object.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityAddInputEvent">
    <keyword>NCommodityAddInputEvent</keyword>
    <fullCommand>NCommodityAddInputEvent *InputEvent</fullCommand>
    <parameters>*InputEvent</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityChangeTranslater">
    <keyword>NCommodityChangeTranslater</keyword>
    <fullCommand>NCommodityChangeTranslater #Object.l, *InputEvent</fullCommand>
    <parameters>#Object.l, *InputEvent</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityIXChangeFilter">
    <keyword>NCommodityIXChangeFilter</keyword>
    <fullCommand>NCommodityIXChangeFilter(#Object.l, *InputXpression)</fullCommand>
    <parameters>(#Object.l, *InputXpression)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCommodityChangeFilter">
    <keyword>NCommodityChangeFilter</keyword>
    <fullCommand>NCommodityChangeFilter(#Object.l, Filter$)</fullCommand>
    <parameters>(#Object.l, Filter$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NBoxFill">
    <keyword>NBoxFill</keyword>
    <fullCommand>NBoxFill(x1, y1, x2, y2)</fullCommand>
    <parameters>(x1, y1, x2, y2)</parameters>
    <shortDescription>Draw a filled box on the current OutPut -.</shortDescription>
    <longDescription />
  </command>
  <command name="NPlot">
    <keyword>NPlot</keyword>
    <fullCommand>NPlot(x, y)</fullCommand>
    <parameters>(x, y)</parameters>
    <shortDescription>Draw a plot on the current OutPut -.</shortDescription>
    <longDescription />
  </command>
  <command name="NLine">
    <keyword>NLine</keyword>
    <fullCommand>NLine(x1, y1, x2, y2)</fullCommand>
    <parameters>(x1, y1, x2, y2)</parameters>
    <shortDescription>Draw a line on the current OutPut -.</shortDescription>
    <longDescription />
  </command>
  <command name="NCircle">
    <keyword>NCircle</keyword>
    <fullCommand>NCircle(x, y, Radius)</fullCommand>
    <parameters>(x, y, Radius)</parameters>
    <shortDescription>Draw a circle on the current OutPut -.</shortDescription>
    <longDescription />
  </command>
  <command name="NEllipse">
    <keyword>NEllipse</keyword>
    <fullCommand>NEllipse(x, y, RadiusX, RadiusY)</fullCommand>
    <parameters>(x, y, RadiusX, RadiusY)</parameters>
    <shortDescription>Draw an ellipse on the current OutPut -.</shortDescription>
    <longDescription />
  </command>
  <command name="NFrontColour">
    <keyword>NFrontColour</keyword>
    <fullCommand>NFrontColour(Colour)</fullCommand>
    <parameters>(Colour)</parameters>
    <shortDescription>Change the front colour of the current OutPut -.</shortDescription>
    <longDescription />
  </command>
  <command name="NBackColour">
    <keyword>NBackColour</keyword>
    <fullCommand>NBackColour(Colour)</fullCommand>
    <parameters>(Colour)</parameters>
    <shortDescription>Change the back colour of the current OutPut -.</shortDescription>
    <longDescription />
  </command>
  <command name="NDrawingMode">
    <keyword>NDrawingMode</keyword>
    <fullCommand>NDrawingMode(DrawMode)</fullCommand>
    <parameters>(DrawMode)</parameters>
    <shortDescription>Change the draw mode of the current OutPut -.</shortDescription>
    <longDescription />
  </command>
  <command name="NDrawingOutput">
    <keyword>NDrawingOutput</keyword>
    <fullCommand>NDrawingOutput(RastPort)</fullCommand>
    <parameters>(RastPort)</parameters>
    <shortDescription>Change the current OutPut -.</shortDescription>
    <longDescription />
  </command>
  <command name="NCopybitMap">
    <keyword>NCopybitMap</keyword>
    <fullCommand>NCopybitMap(BitMapID, SourceX, SourceY, DestX, DestY, Width, Height)</fullCommand>
    <parameters>(BitMapID, SourceX, SourceY, DestX, DestY, Width, Height)</parameters>
    <shortDescription>Copy the specified bitmap to Output -.</shortDescription>
    <longDescription />
  </command>
  <command name="NCls">
    <keyword>NCls</keyword>
    <fullCommand>NCls(Colour)</fullCommand>
    <parameters>(Colour)</parameters>
    <shortDescription>Clear the current output with given colour -.</shortDescription>
    <longDescription />
  </command>
  <command name="NLocate">
    <keyword>NLocate</keyword>
    <fullCommand>NLocate(x, y)</fullCommand>
    <parameters>(x, y)</parameters>
    <shortDescription>Set the cursor position for text output -.</shortDescription>
    <longDescription />
  </command>
  <command name="NDPrint">
    <keyword>NDPrint</keyword>
    <fullCommand>NDPrint(Text$)</fullCommand>
    <parameters>(Text$)</parameters>
    <shortDescription>Print the specified text -.</shortDescription>
    <longDescription />
  </command>
  <command name="NTextStyle">
    <keyword>NTextStyle</keyword>
    <fullCommand>NTextStyle(Style)</fullCommand>
    <parameters>(Style)</parameters>
    <shortDescription>1=Underline, 2=Bold, 4=Italic -.</shortDescription>
    <longDescription />
  </command>
  <command name="NDrawingFont">
    <keyword>NDrawingFont</keyword>
    <fullCommand>NDrawingFont(FontID)</fullCommand>
    <parameters>(FontID)</parameters>
    <shortDescription>Change the current font -.</shortDescription>
    <longDescription />
  </command>
  <command name="NTextLength">
    <keyword>NTextLength</keyword>
    <fullCommand>NTextLength(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription>Return the length in pixel of the string -.</shortDescription>
    <longDescription />
  </command>
  <command name="NPoint">
    <keyword>NPoint</keyword>
    <fullCommand>NPoint(x, y)</fullCommand>
    <parameters>(x, y)</parameters>
    <shortDescription>Return the pixel colour at position (x,y) -.</shortDescription>
    <longDescription />
  </command>
  <command name="NDrawingRastPort">
    <keyword>NDrawingRastPort</keyword>
    <fullCommand>NDrawingRastPort</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the current Drawing RastPort -.</shortDescription>
    <longDescription />
  </command>
  <command name="NCursX">
    <keyword>NCursX</keyword>
    <fullCommand>NCursX</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the current cursor X position -.</shortDescription>
    <longDescription />
  </command>
  <command name="NCursY">
    <keyword>NCursY</keyword>
    <fullCommand>NCursY</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the current cursor Y position -.</shortDescription>
    <longDescription />
  </command>
  <command name="NLoadFont">
    <keyword>NLoadFont</keyword>
    <fullCommand>NLoadFont(#Font, FontName$, YSize)</fullCommand>
    <parameters>(#Font, FontName$, YSize)</parameters>
    <shortDescription>Return a FontID.</shortDescription>
    <longDescription />
  </command>
  <command name="NUseFont">
    <keyword>NUseFont</keyword>
    <fullCommand>NUseFont(#Font)</fullCommand>
    <parameters>(#Font)</parameters>
    <shortDescription>Change the used font.</shortDescription>
    <longDescription />
  </command>
  <command name="NCloseFont">
    <keyword>NCloseFont</keyword>
    <fullCommand>NCloseFont(#Font)</fullCommand>
    <parameters>(#Font)</parameters>
    <shortDescription>Close the specified font.</shortDescription>
    <longDescription />
  </command>
  <command name="NInitFont">
    <keyword>NInitFont</keyword>
    <fullCommand>NInitFont(#NumFontMax)</fullCommand>
    <parameters>(#NumFontMax)</parameters>
    <shortDescription>Initialize Font for use.</shortDescription>
    <longDescription />
  </command>
  <command name="NFontID">
    <keyword>NFontID</keyword>
    <fullCommand>NFontID</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the used intuifont pointer -.</shortDescription>
    <longDescription />
  </command>
  <command name="NButtonGadget">
    <keyword>NButtonGadget</keyword>
    <fullCommand>NButtonGadget(#Gadget, x, y, Width, Height, Text$, TagList)</fullCommand>
    <parameters>(#Gadget, x, y, Width, Height, Text$, TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCheckBoxGadget">
    <keyword>NCheckBoxGadget</keyword>
    <fullCommand>NCheckBoxGadget(#Gadget, x, y, Width, Height, Text$, TagList)</fullCommand>
    <parameters>(#Gadget, x, y, Width, Height, Text$, TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NIntegerGadget">
    <keyword>NIntegerGadget</keyword>
    <fullCommand>NIntegerGadget(#Gadget, x, y, Width, Height, Text$, TagList)</fullCommand>
    <parameters>(#Gadget, x, y, Width, Height, Text$, TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NListViewGadget">
    <keyword>NListViewGadget</keyword>
    <fullCommand>NListViewGadget(#Gadget, x, y, Width, Height, Text$, TagList)</fullCommand>
    <parameters>(#Gadget, x, y, Width, Height, Text$, TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NNumberGadget">
    <keyword>NNumberGadget</keyword>
    <fullCommand>NNumberGadget(#Gadget, x, y, Width, Height, Text$, TagList)</fullCommand>
    <parameters>(#Gadget, x, y, Width, Height, Text$, TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCycleGadget">
    <keyword>NCycleGadget</keyword>
    <fullCommand>NCycleGadget(#Gadget, x, y, Width, Height, Text$, TagList)</fullCommand>
    <parameters>(#Gadget, x, y, Width, Height, Text$, TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NPaletteGadget">
    <keyword>NPaletteGadget</keyword>
    <fullCommand>NPaletteGadget(#Gadget, x, y, Width, Height, Text$, TagList)</fullCommand>
    <parameters>(#Gadget, x, y, Width, Height, Text$, TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NScrollerGadget">
    <keyword>NScrollerGadget</keyword>
    <fullCommand>NScrollerGadget(#Gadget, x, y, Width, Height, Text$, TagList)</fullCommand>
    <parameters>(#Gadget, x, y, Width, Height, Text$, TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NSliderGadget">
    <keyword>NSliderGadget</keyword>
    <fullCommand>NSliderGadget(#Gadget, x, y, Width, Height, Text$, TagList)</fullCommand>
    <parameters>(#Gadget, x, y, Width, Height, Text$, TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NStringGadget">
    <keyword>NStringGadget</keyword>
    <fullCommand>NStringGadget(#Gadget, x, y, Width, Height, Text$, TagList)</fullCommand>
    <parameters>(#Gadget, x, y, Width, Height, Text$, TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NTextGadget">
    <keyword>NTextGadget</keyword>
    <fullCommand>NTextGadget(#Gadget, x, y, Width, Height, Text$, TagList)</fullCommand>
    <parameters>(#Gadget, x, y, Width, Height, Text$, TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NSetGadgetFont">
    <keyword>NSetGadgetFont</keyword>
    <fullCommand>NSetGadgetFont &amp;FontAttr structure !</fullCommand>
    <parameters>&amp;FontAttr structure !</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NSetGadgetFlags">
    <keyword>NSetGadgetFlags</keyword>
    <fullCommand>NSetGadgetFlags Flags</fullCommand>
    <parameters>Flags</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NGadgetAttrs">
    <keyword>NGadgetAttrs</keyword>
    <fullCommand>NGadgetAttrs #Gadget, #TAG_ITEM, #TAG_DATA</fullCommand>
    <parameters>#Gadget, #TAG_ITEM, #TAG_DATA</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NGetStringText">
    <keyword>NGetStringText</keyword>
    <fullCommand>NGetStringText(#Gadget)</fullCommand>
    <parameters>(#Gadget)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnused1">
    <keyword>NUnused1</keyword>
    <fullCommand>NUnused1</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUseGadgetList">
    <keyword>NUseGadgetList</keyword>
    <fullCommand>NUseGadgetList #GadgetList</fullCommand>
    <parameters>#GadgetList</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCreateGadgetList">
    <keyword>NCreateGadgetList</keyword>
    <fullCommand>NCreateGadgetList(#GadgetList, ScreenID)</fullCommand>
    <parameters>(#GadgetList, ScreenID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NAttachGadgetList">
    <keyword>NAttachGadgetList</keyword>
    <fullCommand>NAttachGadgetList #GadgetList, WindowID</fullCommand>
    <parameters>#GadgetList, WindowID</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnused6">
    <keyword>NUnused6</keyword>
    <fullCommand>NUnused6</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnused7">
    <keyword>NUnused7</keyword>
    <fullCommand>NUnused7</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnused8">
    <keyword>NUnused8</keyword>
    <fullCommand>NUnused8</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnused9">
    <keyword>NUnused9</keyword>
    <fullCommand>NUnused9</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnused10">
    <keyword>NUnused10</keyword>
    <fullCommand>NUnused10</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnused11">
    <keyword>NUnused11</keyword>
    <fullCommand>NUnused11</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnused12">
    <keyword>NUnused12</keyword>
    <fullCommand>NUnused12</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnused13">
    <keyword>NUnused13</keyword>
    <fullCommand>NUnused13</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnused4">
    <keyword>NUnused4</keyword>
    <fullCommand>NUnused4</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnused3">
    <keyword>NUnused3</keyword>
    <fullCommand>NUnused3</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NInitGadget">
    <keyword>NInitGadget</keyword>
    <fullCommand>NInitGadget(NumMaxGadgetLists)</fullCommand>
    <parameters>(NumMaxGadgetLists)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NOptionGadget">
    <keyword>NOptionGadget</keyword>
    <fullCommand>NOptionGadget(#Gadget, x, y, Width, Height, Text$, TagList)</fullCommand>
    <parameters>(#Gadget, x, y, Width, Height, Text$, TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnused2">
    <keyword>NUnused2</keyword>
    <fullCommand>NUnused2</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NDisableGadget">
    <keyword>NDisableGadget</keyword>
    <fullCommand>NDisableGadget #Gadget, State</fullCommand>
    <parameters>#Gadget, State</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NActivateGadget">
    <keyword>NActivateGadget</keyword>
    <fullCommand>NActivateGadget #Gadget</fullCommand>
    <parameters>#Gadget</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NRefreshGadget">
    <keyword>NRefreshGadget</keyword>
    <fullCommand>NRefreshGadget #Gadget</fullCommand>
    <parameters>#Gadget</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NNoGadgetBorder">
    <keyword>NNoGadgetBorder</keyword>
    <fullCommand>NNoGadgetBorder #Gadget</fullCommand>
    <parameters>#Gadget</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NFreeGadgetList">
    <keyword>NFreeGadgetList</keyword>
    <fullCommand>NFreeGadgetList #GadgetList</fullCommand>
    <parameters>#GadgetList</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NSetStringText">
    <keyword>NSetStringText</keyword>
    <fullCommand>NSetStringText #Gadget, Text$</fullCommand>
    <parameters>#Gadget, Text$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NRefreshGadgetList">
    <keyword>NRefreshGadgetList</keyword>
    <fullCommand>NRefreshGadgetList</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Refresh the current gadget list.</shortDescription>
    <longDescription />
  </command>
  <command name="NUnused14">
    <keyword>NUnused14</keyword>
    <fullCommand>NUnused14</fullCommand>
    <parameters />
    <shortDescription />
    <longDescription />
  </command>
  <command name="NInitLocale">
    <keyword>NInitLocale</keyword>
    <fullCommand>NInitLocale</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Initialize locale for use.</shortDescription>
    <longDescription />
  </command>
  <command name="NOpenCatalog">
    <keyword>NOpenCatalog</keyword>
    <fullCommand>NOpenCatalog(CatalogName$, TagList)</fullCommand>
    <parameters>(CatalogName$, TagList)</parameters>
    <shortDescription>Open a specified catalog file.</shortDescription>
    <longDescription />
  </command>
  <command name="NCloseCatalog">
    <keyword>NCloseCatalog</keyword>
    <fullCommand>NCloseCatalog</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Close the opened catalog.</shortDescription>
    <longDescription />
  </command>
  <command name="NGetCatalogString">
    <keyword>NGetCatalogString</keyword>
    <fullCommand>NGetCatalogString(String number)</fullCommand>
    <parameters>(String number)</parameters>
    <shortDescription>Get a text from an opened catalog.</shortDescription>
    <longDescription />
  </command>
  <command name="NPokeB">
    <keyword>NPokeB</keyword>
    <fullCommand>NPokeB Adress, Byte</fullCommand>
    <parameters>Adress, Byte</parameters>
    <shortDescription>Adress, Byte.</shortDescription>
    <longDescription />
  </command>
  <command name="NPokeW">
    <keyword>NPokeW</keyword>
    <fullCommand>NPokeW Adress, Word</fullCommand>
    <parameters>Adress, Word</parameters>
    <shortDescription>Adress, Word.</shortDescription>
    <longDescription />
  </command>
  <command name="NPokeL">
    <keyword>NPokeL</keyword>
    <fullCommand>NPokeL Adress, Long</fullCommand>
    <parameters>Adress, Long</parameters>
    <shortDescription>Adress, Long.</shortDescription>
    <longDescription />
  </command>
  <command name="NPeekB">
    <keyword>NPeekB</keyword>
    <fullCommand>NPeekB(Address)</fullCommand>
    <parameters>(Address)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NPeekW">
    <keyword>NPeekW</keyword>
    <fullCommand>NPeekW(Address)</fullCommand>
    <parameters>(Address)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NPeekL">
    <keyword>NPeekL</keyword>
    <fullCommand>NPeekL(Address)</fullCommand>
    <parameters>(Address)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NPeek$">
    <keyword>NPeek$</keyword>
    <fullCommand>NPeek$(Address)</fullCommand>
    <parameters>(Address)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NMenuTitle">
    <keyword>NMenuTitle</keyword>
    <fullCommand>NMenuTitle(&amp;Title$)</fullCommand>
    <parameters>(&amp;Title$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NMenuItem">
    <keyword>NMenuItem</keyword>
    <fullCommand>NMenuItem(#Item, &amp;Title$, &amp;CommandKey$)</fullCommand>
    <parameters>(#Item, &amp;Title$, &amp;CommandKey$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NMenuSubItem">
    <keyword>NMenuSubItem</keyword>
    <fullCommand>NMenuSubItem(#Item, &amp;Title$, &amp;CommandKey$)</fullCommand>
    <parameters>(#Item, &amp;Title$, &amp;CommandKey$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NMenuBar">
    <keyword>NMenuBar</keyword>
    <fullCommand>NMenuBar</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Create a menu separator bar.</shortDescription>
    <longDescription />
  </command>
  <command name="NMenuSubBar">
    <keyword>NMenuSubBar</keyword>
    <fullCommand>NMenuSubBar</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Create a submenu separator bar.</shortDescription>
    <longDescription />
  </command>
  <command name="NCreateMenu">
    <keyword>NCreateMenu</keyword>
    <fullCommand>NCreateMenu(#Menu, ScreenID)</fullCommand>
    <parameters>(#Menu, ScreenID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NAttachMenu">
    <keyword>NAttachMenu</keyword>
    <fullCommand>NAttachMenu(#Menu, WindowID)</fullCommand>
    <parameters>(#Menu, WindowID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NSetMenuColour">
    <keyword>NSetMenuColour</keyword>
    <fullCommand>NSetMenuColour(Colour)</fullCommand>
    <parameters>(Colour)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NInitMenu">
    <keyword>NInitMenu</keyword>
    <fullCommand>NInitMenu(NumMaxMenus, MaximumMenuItems)</fullCommand>
    <parameters>(NumMaxMenus, MaximumMenuItems)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NFreeMenu">
    <keyword>NFreeMenu</keyword>
    <fullCommand>NFreeMenu(#Menu)</fullCommand>
    <parameters>(#Menu)</parameters>
    <shortDescription>Free the specified menu -.</shortDescription>
    <longDescription />
  </command>
  <command name="NMenuCheckItem">
    <keyword>NMenuCheckItem</keyword>
    <fullCommand>NMenuCheckItem(#Item, &amp;Title$, &amp;CommandKey$, State)</fullCommand>
    <parameters>(#Item, &amp;Title$, &amp;CommandKey$, State)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NMenuCheckSubItem">
    <keyword>NMenuCheckSubItem</keyword>
    <fullCommand>NMenuCheckSubItem(#Item, &amp;Title$, &amp;CommandKey$, State)</fullCommand>
    <parameters>(#Item, &amp;Title$, &amp;CommandKey$, State)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NMenuToggleItem">
    <keyword>NMenuToggleItem</keyword>
    <fullCommand>NMenuToggleItem(#Item, &amp;Title$, &amp;CommandKey$, State)</fullCommand>
    <parameters>(#Item, &amp;Title$, &amp;CommandKey$, State)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NMenuToggleSubItem">
    <keyword>NMenuToggleSubItem</keyword>
    <fullCommand>NMenuToggleSubItem(#Item, &amp;Title$, &amp;CommandKey$, State)</fullCommand>
    <parameters>(#Item, &amp;Title$, &amp;CommandKey$, State)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NVWait">
    <keyword>NVWait</keyword>
    <fullCommand>NVWait</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Wait until next Vertical Blank.</shortDescription>
    <longDescription />
  </command>
  <command name="NMouseWait">
    <keyword>NMouseWait</keyword>
    <fullCommand>NMouseWait</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Wait until a mouse press.</shortDescription>
    <longDescription />
  </command>
  <command name="NFalse">
    <keyword>NFalse</keyword>
    <fullCommand>NFalse</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Set variable type to False -.</shortDescription>
    <longDescription />
  </command>
  <command name="NTrue">
    <keyword>NTrue</keyword>
    <fullCommand>NTrue</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Set variable type to True -.</shortDescription>
    <longDescription />
  </command>
  <command name="NOff">
    <keyword>NOff</keyword>
    <fullCommand>NOff</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Set variable type to Off -.</shortDescription>
    <longDescription />
  </command>
  <command name="NOn">
    <keyword>NOn</keyword>
    <fullCommand>NOn</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Set variable type to On -.</shortDescription>
    <longDescription />
  </command>
  <command name="NProgramPriority">
    <keyword>NProgramPriority</keyword>
    <fullCommand>NProgramPriority(New Priority)</fullCommand>
    <parameters>(New Priority)</parameters>
    <shortDescription>Set the program priority -.</shortDescription>
    <longDescription />
  </command>
  <command name="NExecBase">
    <keyword>NExecBase</keyword>
    <fullCommand>NExecBase</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the exec.library base pointer -.</shortDescription>
    <longDescription />
  </command>
  <command name="NDosBase">
    <keyword>NDosBase</keyword>
    <fullCommand>NDosBase</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the dos.library base pointer -.</shortDescription>
    <longDescription />
  </command>
  <command name="NIntuitionBase">
    <keyword>NIntuitionBase</keyword>
    <fullCommand>NIntuitionBase</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the intuition.library base pointer -.</shortDescription>
    <longDescription />
  </command>
  <command name="NGraphicsBase">
    <keyword>NGraphicsBase</keyword>
    <fullCommand>NGraphicsBase</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the graphics.library base pointer -.</shortDescription>
    <longDescription />
  </command>
  <command name="NUsePalette">
    <keyword>NUsePalette</keyword>
    <fullCommand>NUsePalette(#Palette)</fullCommand>
    <parameters>(#Palette)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NPalRgb">
    <keyword>NPalRgb</keyword>
    <fullCommand>NPalRgb(ColorIndex, R, G, B)</fullCommand>
    <parameters>(ColorIndex, R, G, B)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NDisplayPalette">
    <keyword>NDisplayPalette</keyword>
    <fullCommand>NDisplayPalette(#Palette, ScreenID)</fullCommand>
    <parameters>(#Palette, ScreenID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NRed">
    <keyword>NRed</keyword>
    <fullCommand>NRed(ColorIndex)</fullCommand>
    <parameters>(ColorIndex)</parameters>
    <shortDescription>Get the Red value -.</shortDescription>
    <longDescription />
  </command>
  <command name="NGreen">
    <keyword>NGreen</keyword>
    <fullCommand>NGreen(ColorIndex)</fullCommand>
    <parameters>(ColorIndex)</parameters>
    <shortDescription>Get the Green value -.</shortDescription>
    <longDescription />
  </command>
  <command name="NBlue">
    <keyword>NBlue</keyword>
    <fullCommand>NBlue(ColorIndex)</fullCommand>
    <parameters>(ColorIndex)</parameters>
    <shortDescription>Get the Blue value -.</shortDescription>
    <longDescription />
  </command>
  <command name="NGetScreenPalette">
    <keyword>NGetScreenPalette</keyword>
    <fullCommand>NGetScreenPalette(#Palette, ScreenID)</fullCommand>
    <parameters>(#Palette, ScreenID)</parameters>
    <shortDescription>Get the palette from screen -.</shortDescription>
    <longDescription />
  </command>
  <command name="NCreatePalette">
    <keyword>NCreatePalette</keyword>
    <fullCommand>NCreatePalette(#Palette, NbColors)</fullCommand>
    <parameters>(#Palette, NbColors)</parameters>
    <shortDescription>Create an empty palette -.</shortDescription>
    <longDescription />
  </command>
  <command name="NRgb">
    <keyword>NRgb</keyword>
    <fullCommand>NRgb(ScreenID, ColourIndex, R, G, B)</fullCommand>
    <parameters>(ScreenID, ColourIndex, R, G, B)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NFadeOut">
    <keyword>NFadeOut</keyword>
    <fullCommand>NFadeOut(#Palette, Step, NbLoop, ScreenID)</fullCommand>
    <parameters>(#Palette, Step, NbLoop, ScreenID)</parameters>
    <shortDescription>FadeOut the screen.</shortDescription>
    <longDescription />
  </command>
  <command name="NFreePalette">
    <keyword>NFreePalette</keyword>
    <fullCommand>NFreePalette(#Palette)</fullCommand>
    <parameters>(#Palette)</parameters>
    <shortDescription>Free the specified palette -.</shortDescription>
    <longDescription />
  </command>
  <command name="NInitPalette">
    <keyword>NInitPalette</keyword>
    <fullCommand>NInitPalette(#MaxNumPalette)</fullCommand>
    <parameters>(#MaxNumPalette)</parameters>
    <shortDescription>Init Palette environnement -.</shortDescription>
    <longDescription />
  </command>
  <command name="NGetPicturePalette">
    <keyword>NGetPicturePalette</keyword>
    <fullCommand>NGetPicturePalette(#Palette, PictureID)</fullCommand>
    <parameters>(#Palette, PictureID)</parameters>
    <shortDescription>Create a new palette take from picture -.</shortDescription>
    <longDescription />
  </command>
  <command name="NFade">
    <keyword>NFade</keyword>
    <fullCommand>NFade(#Palette1, #Palette2, Step, NbLoop, ScreenID)</fullCommand>
    <parameters>(#Palette1, #Palette2, Step, NbLoop, ScreenID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NNbColour">
    <keyword>NNbColour</keyword>
    <fullCommand>NNbColour</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the number of colour of the current palette -.</shortDescription>
    <longDescription />
  </command>
  <command name="NASyncFade">
    <keyword>NASyncFade</keyword>
    <fullCommand>NASyncFade(#Palette1, #Palette2, Step, NbLoop, ScreenID)</fullCommand>
    <parameters>(#Palette1, #Palette2, Step, NbLoop, ScreenID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NASyncFadeStatus">
    <keyword>NASyncFadeStatus</keyword>
    <fullCommand>NASyncFadeStatus</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return -1 if the fade is running, 0 else -.</shortDescription>
    <longDescription />
  </command>
  <command name="NInitPicture">
    <keyword>NInitPicture</keyword>
    <fullCommand>NInitPicture(#MaxPicture)</fullCommand>
    <parameters>(#MaxPicture)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NFreePicture">
    <keyword>NFreePicture</keyword>
    <fullCommand>NFreePicture(#Picture)</fullCommand>
    <parameters>(#Picture)</parameters>
    <shortDescription>Remove the specified picture from memory.</shortDescription>
    <longDescription />
  </command>
  <command name="NUsePicture">
    <keyword>NUsePicture</keyword>
    <fullCommand>NUsePicture(#Picture)</fullCommand>
    <parameters>(#Picture)</parameters>
    <shortDescription>Change the used picture.</shortDescription>
    <longDescription />
  </command>
  <command name="NLoadPicture">
    <keyword>NLoadPicture</keyword>
    <fullCommand>NLoadPicture(#Picture, Filename$)</fullCommand>
    <parameters>(#Picture, Filename$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NPictureWidth">
    <keyword>NPictureWidth</keyword>
    <fullCommand>NPictureWidth</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the used picture width.</shortDescription>
    <longDescription />
  </command>
  <command name="NPictureHeight">
    <keyword>NPictureHeight</keyword>
    <fullCommand>NPictureHeight</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the used picture height.</shortDescription>
    <longDescription />
  </command>
  <command name="NPictureDepth">
    <keyword>NPictureDepth</keyword>
    <fullCommand>NPictureDepth</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the used picture depth.</shortDescription>
    <longDescription />
  </command>
  <command name="NPictureToBitmap">
    <keyword>NPictureToBitmap</keyword>
    <fullCommand>NPictureToBitmap(#Picture, BitmapID)</fullCommand>
    <parameters>(#Picture, BitmapID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NPictureID">
    <keyword>NPictureID</keyword>
    <fullCommand>NPictureID</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the used picture pointer -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWbToScreen">
    <keyword>NWbToScreen</keyword>
    <fullCommand>NWbToScreen(#Screen)</fullCommand>
    <parameters>(#Screen)</parameters>
    <shortDescription>Try to find the Workbench Screen -.</shortDescription>
    <longDescription />
  </command>
  <command name="NFindScreen">
    <keyword>NFindScreen</keyword>
    <fullCommand>NFindScreen(#Screen, Name$)</fullCommand>
    <parameters>(#Screen, Name$)</parameters>
    <shortDescription>Seek the screen name or take the default public screen -.</shortDescription>
    <longDescription />
  </command>
  <command name="NScreen">
    <keyword>NScreen</keyword>
    <fullCommand>NScreen(#Screen, Width, Height, Depth, TagList)</fullCommand>
    <parameters>(#Screen, Width, Height, Depth, TagList)</parameters>
    <shortDescription>Open a new screen -.</shortDescription>
    <longDescription />
  </command>
  <command name="NSMouseY">
    <keyword>NSMouseY</keyword>
    <fullCommand>NSMouseY</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the MouseY Position on the screen.</shortDescription>
    <longDescription />
  </command>
  <command name="NSMouseX">
    <keyword>NSMouseX</keyword>
    <fullCommand>NSMouseX</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the Mouse X Position on the screen.</shortDescription>
    <longDescription />
  </command>
  <command name="NScreenWidth">
    <keyword>NScreenWidth</keyword>
    <fullCommand>NScreenWidth</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the Width of the screen.</shortDescription>
    <longDescription />
  </command>
  <command name="NScreenHeight">
    <keyword>NScreenHeight</keyword>
    <fullCommand>NScreenHeight</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the Height of the screen.</shortDescription>
    <longDescription />
  </command>
  <command name="NShowScreen">
    <keyword>NShowScreen</keyword>
    <fullCommand>NShowScreen</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Show the screen.</shortDescription>
    <longDescription />
  </command>
  <command name="NHideScreen">
    <keyword>NHideScreen</keyword>
    <fullCommand>NHideScreen</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Hide the screen -.</shortDescription>
    <longDescription />
  </command>
  <command name="NUseScreen">
    <keyword>NUseScreen</keyword>
    <fullCommand>NUseScreen(#Screen)</fullCommand>
    <parameters>(#Screen)</parameters>
    <shortDescription>Set the specified screen as used -.</shortDescription>
    <longDescription />
  </command>
  <command name="NCloseScreen">
    <keyword>NCloseScreen</keyword>
    <fullCommand>NCloseScreen(#Screen)</fullCommand>
    <parameters>(#Screen)</parameters>
    <shortDescription>Close the specified screen -.</shortDescription>
    <longDescription />
  </command>
  <command name="NInitScreen">
    <keyword>NInitScreen</keyword>
    <fullCommand>NInitScreen(#NumScreenMax)</fullCommand>
    <parameters>(#NumScreenMax)</parameters>
    <shortDescription>Init Screen Environenement -.</shortDescription>
    <longDescription />
  </command>
  <command name="NScreenID">
    <keyword>NScreenID</keyword>
    <fullCommand>NScreenID</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the intuition screen pointer -.</shortDescription>
    <longDescription />
  </command>
  <command name="NScreenRastPort">
    <keyword>NScreenRastPort</keyword>
    <fullCommand>NScreenRastPort</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the used screen rastport pointer -.</shortDescription>
    <longDescription />
  </command>
  <command name="NViewPort">
    <keyword>NViewPort</keyword>
    <fullCommand>NViewPort</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the used screen viewport address -.</shortDescription>
    <longDescription />
  </command>
  <command name="NObtainBestPen">
    <keyword>NObtainBestPen</keyword>
    <fullCommand>NObtainBestPen(r, g, b, precision)</fullCommand>
    <parameters>(r, g, b, precision)</parameters>
    <shortDescription>Return the most near colour of the screen -.</shortDescription>
    <longDescription />
  </command>
  <command name="NReleasePen">
    <keyword>NReleasePen</keyword>
    <fullCommand>NReleasePen(Colour Index)</fullCommand>
    <parameters>(Colour Index)</parameters>
    <shortDescription>release the pen -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWBorderTop">
    <keyword>NWBorderTop</keyword>
    <fullCommand>NWBorderTop</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the window bar height (with title) -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWBorderLeft">
    <keyword>NWBorderLeft</keyword>
    <fullCommand>NWBorderLeft</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the window border left length -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWBorderRight">
    <keyword>NWBorderRight</keyword>
    <fullCommand>NWBorderRight</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the window border right length -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWBorderBottom">
    <keyword>NWBorderBottom</keyword>
    <fullCommand>NWBorderBottom</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the window border bottom length -.</shortDescription>
    <longDescription />
  </command>
  <command name="NSBarHeight">
    <keyword>NSBarHeight</keyword>
    <fullCommand>NSBarHeight</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the screen bar height -.</shortDescription>
    <longDescription />
  </command>
  <command name="NSFontHeight">
    <keyword>NSFontHeight</keyword>
    <fullCommand>NSFontHeight</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the actual screen font height -.</shortDescription>
    <longDescription />
  </command>
  <command name="NFindFrontScreen">
    <keyword>NFindFrontScreen</keyword>
    <fullCommand>NFindFrontScreen(#Screen)</fullCommand>
    <parameters>(#Screen)</parameters>
    <shortDescription>Take the front most screen -.</shortDescription>
    <longDescription />
  </command>
  <command name="NScreenDepth">
    <keyword>NScreenDepth</keyword>
    <fullCommand>NScreenDepth</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the depth of the current screen -.</shortDescription>
    <longDescription />
  </command>
  <command name="NSortUp">
    <keyword>NSortUp</keyword>
    <fullCommand>NSortUp(Array(), Start, End)</fullCommand>
    <parameters>(Array(), Start, End)</parameters>
    <shortDescription>Sort the portion of the array.</shortDescription>
    <longDescription />
  </command>
  <command name="NSortDown">
    <keyword>NSortDown</keyword>
    <fullCommand>NSortDown(Array(), Start, End)</fullCommand>
    <parameters>(Array(), Start, End)</parameters>
    <shortDescription>Sort the portion of the array.</shortDescription>
    <longDescription />
  </command>
  <command name="NAsc">
    <keyword>NAsc</keyword>
    <fullCommand>NAsc(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription>Return the first ASCII value of the string$.</shortDescription>
    <longDescription />
  </command>
  <command name="NLen">
    <keyword>NLen</keyword>
    <fullCommand>NLen(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription>Return the length of the string$.</shortDescription>
    <longDescription />
  </command>
  <command name="NChr$">
    <keyword>NChr$</keyword>
    <fullCommand>NChr$(Ascii)</fullCommand>
    <parameters>(Ascii)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NTrim$">
    <keyword>NTrim$</keyword>
    <fullCommand>NTrim$(String$, Value)</fullCommand>
    <parameters>(String$, Value)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NRight$">
    <keyword>NRight$</keyword>
    <fullCommand>NRight$(String$, Length)</fullCommand>
    <parameters>(String$, Length)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NLeft$">
    <keyword>NLeft$</keyword>
    <fullCommand>NLeft$(String$, Length)</fullCommand>
    <parameters>(String$, Length)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUCase$">
    <keyword>NUCase$</keyword>
    <fullCommand>NUCase$(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NLCase$">
    <keyword>NLCase$</keyword>
    <fullCommand>NLCase$(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NMki$">
    <keyword>NMki$</keyword>
    <fullCommand>NMki$(Word)</fullCommand>
    <parameters>(Word)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NMkl$">
    <keyword>NMkl$</keyword>
    <fullCommand>NMkl$(Long)</fullCommand>
    <parameters>(Long)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCvi">
    <keyword>NCvi</keyword>
    <fullCommand>NCvi(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCvl">
    <keyword>NCvl</keyword>
    <fullCommand>NCvl(String$)</fullCommand>
    <parameters>(String$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NInitTagList">
    <keyword>NInitTagList</keyword>
    <fullCommand>NInitTagList(#NumMaxTags)</fullCommand>
    <parameters>(#NumMaxTags)</parameters>
    <shortDescription>Initialize the Tag lib for use -.</shortDescription>
    <longDescription />
  </command>
  <command name="NFreeTagList">
    <keyword>NFreeTagList</keyword>
    <fullCommand>NFreeTagList</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Free the memory took by the taglist -.</shortDescription>
    <longDescription />
  </command>
  <command name="NAddTag">
    <keyword>NAddTag</keyword>
    <fullCommand>NAddTag(#TAG_ITEM, #TAG_DATA)</fullCommand>
    <parameters>(#TAG_ITEM, #TAG_DATA)</parameters>
    <shortDescription>Add the tag to the current taglist -.</shortDescription>
    <longDescription />
  </command>
  <command name="NResetTagList">
    <keyword>NResetTagList</keyword>
    <fullCommand>NResetTagList #TAG_ITEM, #TAG_DATA)</fullCommand>
    <parameters>#TAG_ITEM, #TAG_DATA)</parameters>
    <shortDescription>Clear the taglist and add the value -.</shortDescription>
    <longDescription />
  </command>
  <command name="NTagListID">
    <keyword>NTagListID</keyword>
    <fullCommand>NTagListID</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the taglist location -.</shortDescription>
    <longDescription />
  </command>
  <command name="NChangeTag">
    <keyword>NChangeTag</keyword>
    <fullCommand>NChangeTag Position, #TAG_ITEM, #TAG_DATA)</fullCommand>
    <parameters>Position, #TAG_ITEM, #TAG_DATA)</parameters>
    <shortDescription>change the given the tag value -.</shortDescription>
    <longDescription />
  </command>
  <command name="NInitToolType">
    <keyword>NInitToolType</keyword>
    <fullCommand>NInitToolType(Objects.l, *WBStartup)</fullCommand>
    <parameters>(Objects.l, *WBStartup)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NReadToolType">
    <keyword>NReadToolType</keyword>
    <fullCommand>NReadToolType(#Object.w, IconName$)</fullCommand>
    <parameters>(#Object.w, IconName$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NWriteToolType">
    <keyword>NWriteToolType</keyword>
    <fullCommand>NWriteToolType(#Object.w, Array(), IconName$)</fullCommand>
    <parameters>(#Object.w, Array(), IconName$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NFreeToolType">
    <keyword>NFreeToolType</keyword>
    <fullCommand>NFreeToolType #Object.w</fullCommand>
    <parameters>#Object.w</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NGetNumberOfToolType">
    <keyword>NGetNumberOfToolType</keyword>
    <fullCommand>NGetNumberOfToolType(#Object.w)</fullCommand>
    <parameters>(#Object.w)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NGetNextToolTypeString">
    <keyword>NGetNextToolTypeString</keyword>
    <fullCommand>NGetNextToolTypeString(#Object.w)</fullCommand>
    <parameters>(#Object.w)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NFindToolType">
    <keyword>NFindToolType</keyword>
    <fullCommand>NFindToolType(#Object.w, ToolName$)</fullCommand>
    <parameters>(#Object.w, ToolName$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NMatchToolTypeValue">
    <keyword>NMatchToolTypeValue</keyword>
    <fullCommand>NMatchToolTypeValue(ToolType.l, Value$)</fullCommand>
    <parameters>(ToolType.l, Value$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCheckToolTypeString">
    <keyword>NCheckToolTypeString</keyword>
    <fullCommand>NCheckToolTypeString(ToolType$, ToolTypeString$)</fullCommand>
    <parameters>(ToolType$, ToolTypeString$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NWbStartup">
    <keyword>NWbStartup</keyword>
    <fullCommand>NWbStartup</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Allow the program to be start from WB.</shortDescription>
    <longDescription />
  </command>
  <command name="NWindow">
    <keyword>NWindow</keyword>
    <fullCommand>NWindow(#Window, x, y, Width, Height, TagList)</fullCommand>
    <parameters>(#Window, x, y, Width, Height, TagList)</parameters>
    <shortDescription>Open a new window -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWindowEvent">
    <keyword>NWindowEvent</keyword>
    <fullCommand>NWindowEvent</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the window events.</shortDescription>
    <longDescription />
  </command>
  <command name="NBusyPointer">
    <keyword>NBusyPointer</keyword>
    <fullCommand>NBusyPointer( On/Off )</fullCommand>
    <parameters>( On/Off )</parameters>
    <shortDescription>Change the mouse pointer to busy -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWaitWindowEvent">
    <keyword>NWaitWindowEvent</keyword>
    <fullCommand>NWaitWindowEvent</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Wait for a window event.</shortDescription>
    <longDescription />
  </command>
  <command name="NWindowWidth">
    <keyword>NWindowWidth</keyword>
    <fullCommand>NWindowWidth</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the window width -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWindowHeight">
    <keyword>NWindowHeight</keyword>
    <fullCommand>NWindowHeight</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the window height -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWindowX">
    <keyword>NWindowX</keyword>
    <fullCommand>NWindowX</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the X window position -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWindowY">
    <keyword>NWindowY</keyword>
    <fullCommand>NWindowY</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the Y window position -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWMouseX">
    <keyword>NWMouseX</keyword>
    <fullCommand>NWMouseX</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the Mouse X position -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWMouseY">
    <keyword>NWMouseY</keyword>
    <fullCommand>NWMouseY</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the Mouse Y position -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWindowRastPort">
    <keyword>NWindowRastPort</keyword>
    <fullCommand>NWindowRastPort</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the window rastport -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWInnerHeight">
    <keyword>NWInnerHeight</keyword>
    <fullCommand>NWInnerHeight</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the window inner height -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWInnerWidth">
    <keyword>NWInnerWidth</keyword>
    <fullCommand>NWInnerWidth</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the window inner width -.</shortDescription>
    <longDescription />
  </command>
  <command name="NDetachGadgetList">
    <keyword>NDetachGadgetList</keyword>
    <fullCommand>NDetachGadgetList</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Detach the current window's agdgetlist -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWindowEventID">
    <keyword>NWindowEventID</keyword>
    <fullCommand>NWindowEventID</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the window number which has got the last event.</shortDescription>
    <longDescription />
  </command>
  <command name="NWMove">
    <keyword>NWMove</keyword>
    <fullCommand>NWMove(X,Y)</fullCommand>
    <parameters>(X,Y)</parameters>
    <shortDescription>Move the window to X-Y -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWSize">
    <keyword>NWSize</keyword>
    <fullCommand>NWSize(Width,Heigth)</fullCommand>
    <parameters>(Width,Heigth)</parameters>
    <shortDescription>Size the window to new dimentions -.</shortDescription>
    <longDescription />
  </command>
  <command name="NUseWindow">
    <keyword>NUseWindow</keyword>
    <fullCommand>NUseWindow(#Window)</fullCommand>
    <parameters>(#Window)</parameters>
    <shortDescription>Set the specified window as default window -.</shortDescription>
    <longDescription />
  </command>
  <command name="NActivate">
    <keyword>NActivate</keyword>
    <fullCommand>NActivate</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Activate the used window -.</shortDescription>
    <longDescription />
  </command>
  <command name="NCloseWindow">
    <keyword>NCloseWindow</keyword>
    <fullCommand>NCloseWindow(#Window)</fullCommand>
    <parameters>(#Window)</parameters>
    <shortDescription>Close the specified window -.</shortDescription>
    <longDescription />
  </command>
  <command name="NInitWindow">
    <keyword>NInitWindow</keyword>
    <fullCommand>NInitWindow(#MaxNumWindow)</fullCommand>
    <parameters>(#MaxNumWindow)</parameters>
    <shortDescription>Init Window environnement -.</shortDescription>
    <longDescription />
  </command>
  <command name="NWindowID">
    <keyword>NWindowID</keyword>
    <fullCommand>NWindowID</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the used window pointer -.</shortDescription>
    <longDescription />
  </command>
  <command name="NDetachMenu">
    <keyword>NDetachMenu</keyword>
    <fullCommand>NDetachMenu</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Detach the current window menu -.</shortDescription>
    <longDescription />
  </command>
  <command name="NGadgetCode">
    <keyword>NGadgetCode</keyword>
    <fullCommand>NGadgetCode</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the last GadgetCode event...</shortDescription>
    <longDescription />
  </command>
  <command name="NEventID">
    <keyword>NEventID</keyword>
    <fullCommand>NEventID</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the last EventID value...</shortDescription>
    <longDescription />
  </command>
  <command name="NQualifier">
    <keyword>NQualifier</keyword>
    <fullCommand>NQualifier</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the last Qualifier event...</shortDescription>
    <longDescription />
  </command>
  <command name="NUnPackFile">
    <keyword>NUnPackFile</keyword>
    <fullCommand>NUnPackFile(&amp;SourceFile$, &amp;DestFile$, &amp;Password$)</fullCommand>
    <parameters>(&amp;SourceFile$, &amp;DestFile$, &amp;Password$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NPackFile">
    <keyword>NPackFile</keyword>
    <fullCommand>NPackFile(&amp;SourceFile$, &amp;DestFile$, &amp;PackerName$, &amp;Password$)</fullCommand>
    <parameters>(&amp;SourceFile$, &amp;DestFile$, &amp;PackerName$, &amp;Password$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NPackMemToFile">
    <keyword>NPackMemToFile</keyword>
    <fullCommand>NPackMemToFile(*MemAddr, MemLen, &amp;DestFilename$, &amp;Packer$, &amp;Pass$)</fullCommand>
    <parameters>(*MemAddr, MemLen, &amp;DestFilename$, &amp;Packer$, &amp;Pass$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NUnPackFileToMem">
    <keyword>NUnPackFileToMem</keyword>
    <fullCommand>NUnPackFileToMem(&amp;SourceName, MemType, &amp;Pass$)</fullCommand>
    <parameters>(&amp;SourceName, MemType, &amp;Pass$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NXpkFileLength">
    <keyword>NXpkFileLength</keyword>
    <fullCommand>NXpkFileLength</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the decompressed File Length.</shortDescription>
    <longDescription />
  </command>
  <command name="NXpkBufferLength">
    <keyword>NXpkBufferLength</keyword>
    <fullCommand>NXpkBufferLength</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the allocated buffer length.</shortDescription>
    <longDescription />
  </command>
  <command name="NPackerInfo">
    <keyword>NPackerInfo</keyword>
    <fullCommand>NPackerInfo(&amp;PackerName$, Efficiency)</fullCommand>
    <parameters>(&amp;PackerName$, Efficiency)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NPackerName">
    <keyword>NPackerName</keyword>
    <fullCommand>NPackerName</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the info packer name.</shortDescription>
    <longDescription />
  </command>
  <command name="NPackerLongName">
    <keyword>NPackerLongName</keyword>
    <fullCommand>NPackerLongName</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the info packer long name.</shortDescription>
    <longDescription />
  </command>
  <command name="NPackerDescription">
    <keyword>NPackerDescription</keyword>
    <fullCommand>NPackerDescription</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the info packer description.</shortDescription>
    <longDescription />
  </command>
  <command name="NScanPackersList">
    <keyword>NScanPackersList</keyword>
    <fullCommand>NScanPackersList</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Scan the packers list...</shortDescription>
    <longDescription />
  </command>
  <command name="NGetPackerNumber">
    <keyword>NGetPackerNumber</keyword>
    <fullCommand>NGetPackerNumber</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the number of Xpk packers.</shortDescription>
    <longDescription />
  </command>
  <command name="NGetNextPacker">
    <keyword>NGetNextPacker</keyword>
    <fullCommand>NGetNextPacker</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the next packer name.</shortDescription>
    <longDescription />
  </command>
  <command name="NInitXpk">
    <keyword>NInitXpk</keyword>
    <fullCommand>NInitXpk</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Initialize Xpk Environnement.</shortDescription>
    <longDescription />
  </command>
  <command name="NUnPackTagList">
    <keyword>NUnPackTagList</keyword>
    <fullCommand>NUnPackTagList(TagList)</fullCommand>
    <parameters>(TagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XProtocolHostMon_">
    <keyword>XProtocolHostMon_</keyword>
    <fullCommand>XProtocolHostMon_(io,serbuff,actual,maxsize)</fullCommand>
    <parameters>(io,serbuff,actual,maxsize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XProtocolUserMon_">
    <keyword>XProtocolUserMon_</keyword>
    <fullCommand>XProtocolUserMon_(io,serbuff,actual,maxsize)</fullCommand>
    <parameters>(io,serbuff,actual,maxsize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindTagItem_">
    <keyword>FindTagItem_</keyword>
    <fullCommand>FindTagItem_(tagVal,tagList)</fullCommand>
    <parameters>(tagVal,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RefreshTagItemClones_">
    <keyword>RefreshTagItemClones_</keyword>
    <fullCommand>RefreshTagItemClones_(clone,original)</fullCommand>
    <parameters>(clone,original)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TagInArray_">
    <keyword>TagInArray_</keyword>
    <fullCommand>TagInArray_(tagValue,tagArray)</fullCommand>
    <parameters>(tagValue,tagArray)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Amiga2Date_">
    <keyword>Amiga2Date_</keyword>
    <fullCommand>Amiga2Date_(seconds,result)</fullCommand>
    <parameters>(seconds,result)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SMult32_">
    <keyword>SMult32_</keyword>
    <fullCommand>SMult32_(arg1,arg2)</fullCommand>
    <parameters>(arg1,arg2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UMult32_">
    <keyword>UMult32_</keyword>
    <fullCommand>UMult32_(arg1,arg2)</fullCommand>
    <parameters>(arg1,arg2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SDivMod32_">
    <keyword>SDivMod32_</keyword>
    <fullCommand>SDivMod32_(dividend,divisor)</fullCommand>
    <parameters>(dividend,divisor)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UDivMod32_">
    <keyword>UDivMod32_</keyword>
    <fullCommand>UDivMod32_(dividend,divisor)</fullCommand>
    <parameters>(dividend,divisor)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Stricmp_">
    <keyword>Stricmp_</keyword>
    <fullCommand>Stricmp_(string1,string2)</fullCommand>
    <parameters>(string1,string2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ApplyTagChanges_">
    <keyword>ApplyTagChanges_</keyword>
    <fullCommand>ApplyTagChanges_(list,changeList)</fullCommand>
    <parameters>(list,changeList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SMult64_">
    <keyword>SMult64_</keyword>
    <fullCommand>SMult64_(arg1,arg2)</fullCommand>
    <parameters>(arg1,arg2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UMult64_">
    <keyword>UMult64_</keyword>
    <fullCommand>UMult64_(arg1,arg2)</fullCommand>
    <parameters>(arg1,arg2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddNamedObject_">
    <keyword>AddNamedObject_</keyword>
    <fullCommand>AddNamedObject_(namespace,object)</fullCommand>
    <parameters>(namespace,object)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocNamedObjectA_">
    <keyword>AllocNamedObjectA_</keyword>
    <fullCommand>AllocNamedObjectA_(name,tags)</fullCommand>
    <parameters>(name,tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemNamedObject_">
    <keyword>RemNamedObject_</keyword>
    <fullCommand>RemNamedObject_(object,message)</fullCommand>
    <parameters>(object,message)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetUniqueID_">
    <keyword>GetUniqueID_</keyword>
    <fullCommand>GetUniqueID_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateArgstring_">
    <keyword>CreateArgstring_</keyword>
    <fullCommand>CreateArgstring_(string,length)</fullCommand>
    <parameters>(string,length)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClearRexxMsg_">
    <keyword>ClearRexxMsg_</keyword>
    <fullCommand>ClearRexxMsg_(msgptr,count)</fullCommand>
    <parameters>(msgptr,count)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WritePotgo_">
    <keyword>WritePotgo_</keyword>
    <fullCommand>WritePotgo_(word,mask)</fullCommand>
    <parameters>(word,mask)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocMiscResource_">
    <keyword>AllocMiscResource_</keyword>
    <fullCommand>AllocMiscResource_(unitNum,name)</fullCommand>
    <parameters>(unitNum,name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPSincos_">
    <keyword>SPSincos_</keyword>
    <fullCommand>SPSincos_(cosResult,parm)</fullCommand>
    <parameters>(cosResult,parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPPow_">
    <keyword>SPPow_</keyword>
    <fullCommand>SPPow_(power,arg)</fullCommand>
    <parameters>(power,arg)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPSincos_">
    <keyword>IEEESPSincos_</keyword>
    <fullCommand>IEEESPSincos_(cosptr,parm)</fullCommand>
    <parameters>(cosptr,parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPPow_">
    <keyword>IEEESPPow_</keyword>
    <fullCommand>IEEESPPow_(exp,arg)</fullCommand>
    <parameters>(exp,arg)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPCmp_">
    <keyword>IEEESPCmp_</keyword>
    <fullCommand>IEEESPCmp_(leftParm,rightParm)</fullCommand>
    <parameters>(leftParm,rightParm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPAdd_">
    <keyword>IEEESPAdd_</keyword>
    <fullCommand>IEEESPAdd_(leftParm,rightParm)</fullCommand>
    <parameters>(leftParm,rightParm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPSub_">
    <keyword>IEEESPSub_</keyword>
    <fullCommand>IEEESPSub_(leftParm,rightParm)</fullCommand>
    <parameters>(leftParm,rightParm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPMul_">
    <keyword>IEEESPMul_</keyword>
    <fullCommand>IEEESPMul_(leftParm,rightParm)</fullCommand>
    <parameters>(leftParm,rightParm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPDiv_">
    <keyword>IEEESPDiv_</keyword>
    <fullCommand>IEEESPDiv_(dividend,divisor)</fullCommand>
    <parameters>(dividend,divisor)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPAtan_">
    <keyword>IEEEDPAtan_</keyword>
    <fullCommand>IEEEDPAtan_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPSin_">
    <keyword>IEEEDPSin_</keyword>
    <fullCommand>IEEEDPSin_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPCos_">
    <keyword>IEEEDPCos_</keyword>
    <fullCommand>IEEEDPCos_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPTan_">
    <keyword>IEEEDPTan_</keyword>
    <fullCommand>IEEEDPTan_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPSinh_">
    <keyword>IEEEDPSinh_</keyword>
    <fullCommand>IEEEDPSinh_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPCosh_">
    <keyword>IEEEDPCosh_</keyword>
    <fullCommand>IEEEDPCosh_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPTanh_">
    <keyword>IEEEDPTanh_</keyword>
    <fullCommand>IEEEDPTanh_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPExp_">
    <keyword>IEEEDPExp_</keyword>
    <fullCommand>IEEEDPExp_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPLog_">
    <keyword>IEEEDPLog_</keyword>
    <fullCommand>IEEEDPLog_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPPow_">
    <keyword>IEEEDPPow_</keyword>
    <fullCommand>IEEEDPPow_(exp,arg)</fullCommand>
    <parameters>(exp,arg)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPSqrt_">
    <keyword>IEEEDPSqrt_</keyword>
    <fullCommand>IEEEDPSqrt_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPTieee_">
    <keyword>IEEEDPTieee_</keyword>
    <fullCommand>IEEEDPTieee_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPAsin_">
    <keyword>IEEEDPAsin_</keyword>
    <fullCommand>IEEEDPAsin_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPAcos_">
    <keyword>IEEEDPAcos_</keyword>
    <fullCommand>IEEEDPAcos_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPLog10_">
    <keyword>IEEEDPLog10_</keyword>
    <fullCommand>IEEEDPLog10_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPFix_">
    <keyword>IEEEDPFix_</keyword>
    <fullCommand>IEEEDPFix_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPCmp_">
    <keyword>IEEEDPCmp_</keyword>
    <fullCommand>IEEEDPCmp_(leftParm,rightParm)</fullCommand>
    <parameters>(leftParm,rightParm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPTst_">
    <keyword>IEEEDPTst_</keyword>
    <fullCommand>IEEEDPTst_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPAbs_">
    <keyword>IEEEDPAbs_</keyword>
    <fullCommand>IEEEDPAbs_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPNeg_">
    <keyword>IEEEDPNeg_</keyword>
    <fullCommand>IEEEDPNeg_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPAdd_">
    <keyword>IEEEDPAdd_</keyword>
    <fullCommand>IEEEDPAdd_(leftParm,rightParm)</fullCommand>
    <parameters>(leftParm,rightParm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPSub_">
    <keyword>IEEEDPSub_</keyword>
    <fullCommand>IEEEDPSub_(leftParm,rightParm)</fullCommand>
    <parameters>(leftParm,rightParm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPMul_">
    <keyword>IEEEDPMul_</keyword>
    <fullCommand>IEEEDPMul_(factor1,factor2)</fullCommand>
    <parameters>(factor1,factor2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPDiv_">
    <keyword>IEEEDPDiv_</keyword>
    <fullCommand>IEEEDPDiv_(dividend,divisor)</fullCommand>
    <parameters>(dividend,divisor)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPFloor_">
    <keyword>IEEEDPFloor_</keyword>
    <fullCommand>IEEEDPFloor_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPCeil_">
    <keyword>IEEEDPCeil_</keyword>
    <fullCommand>IEEEDPCeil_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPCmp_">
    <keyword>SPCmp_</keyword>
    <fullCommand>SPCmp_(leftParm,rightParm)</fullCommand>
    <parameters>(leftParm,rightParm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPAdd_">
    <keyword>SPAdd_</keyword>
    <fullCommand>SPAdd_(leftParm,rightParm)</fullCommand>
    <parameters>(leftParm,rightParm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPSub_">
    <keyword>SPSub_</keyword>
    <fullCommand>SPSub_(leftParm,rightParm)</fullCommand>
    <parameters>(leftParm,rightParm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPMul_">
    <keyword>SPMul_</keyword>
    <fullCommand>SPMul_(leftParm,rightParm)</fullCommand>
    <parameters>(leftParm,rightParm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPDiv_">
    <keyword>SPDiv_</keyword>
    <fullCommand>SPDiv_(leftParm,rightParm)</fullCommand>
    <parameters>(leftParm,rightParm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ConvToLower_">
    <keyword>ConvToLower_</keyword>
    <fullCommand>ConvToLower_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ConvToUpper_">
    <keyword>ConvToUpper_</keyword>
    <fullCommand>ConvToUpper_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FormatDate_">
    <keyword>FormatDate_</keyword>
    <fullCommand>FormatDate_(locale,template,date,putCharFunc)</fullCommand>
    <parameters>(locale,template,date,putCharFunc)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FormatString_">
    <keyword>FormatString_</keyword>
    <fullCommand>FormatString_(locale,string,dataStream,putCharFunc)</fullCommand>
    <parameters>(locale,string,dataStream,putCharFunc)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetLocaleStr_">
    <keyword>GetLocaleStr_</keyword>
    <fullCommand>GetLocaleStr_(locale,stringNum)</fullCommand>
    <parameters>(locale,stringNum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsAlNum_">
    <keyword>IsAlNum_</keyword>
    <fullCommand>IsAlNum_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsAlpha_">
    <keyword>IsAlpha_</keyword>
    <fullCommand>IsAlpha_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsCntrl_">
    <keyword>IsCntrl_</keyword>
    <fullCommand>IsCntrl_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsDigit_">
    <keyword>IsDigit_</keyword>
    <fullCommand>IsDigit_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsGraph_">
    <keyword>IsGraph_</keyword>
    <fullCommand>IsGraph_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsLower_">
    <keyword>IsLower_</keyword>
    <fullCommand>IsLower_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsPrint_">
    <keyword>IsPrint_</keyword>
    <fullCommand>IsPrint_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsPunct_">
    <keyword>IsPunct_</keyword>
    <fullCommand>IsPunct_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsSpace_">
    <keyword>IsSpace_</keyword>
    <fullCommand>IsSpace_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsUpper_">
    <keyword>IsUpper_</keyword>
    <fullCommand>IsUpper_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsXDigit_">
    <keyword>IsXDigit_</keyword>
    <fullCommand>IsXDigit_(locale,character)</fullCommand>
    <parameters>(locale,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ParseDate_">
    <keyword>ParseDate_</keyword>
    <fullCommand>ParseDate_(locale,date,template,getCharFunc)</fullCommand>
    <parameters>(locale,date,template,getCharFunc)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateUpfrontLayer_">
    <keyword>CreateUpfrontLayer_</keyword>
    <fullCommand>CreateUpfrontLayer_(li,bm,x0,y0,x1,y1,flags,bm2)</fullCommand>
    <parameters>(li,bm,x0,y0,x1,y1,flags,bm2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateBehindLayer_">
    <keyword>CreateBehindLayer_</keyword>
    <fullCommand>CreateBehindLayer_(li,bm,x0,y0,x1,y1,flags,bm2)</fullCommand>
    <parameters>(li,bm,x0,y0,x1,y1,flags,bm2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UpfrontLayer_">
    <keyword>UpfrontLayer_</keyword>
    <fullCommand>UpfrontLayer_(dummy,layer)</fullCommand>
    <parameters>(dummy,layer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BehindLayer_">
    <keyword>BehindLayer_</keyword>
    <fullCommand>BehindLayer_(dummy,layer)</fullCommand>
    <parameters>(dummy,layer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MoveLayer_">
    <keyword>MoveLayer_</keyword>
    <fullCommand>MoveLayer_(dummy,layer,dx,dy)</fullCommand>
    <parameters>(dummy,layer,dx,dy)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SizeLayer_">
    <keyword>SizeLayer_</keyword>
    <fullCommand>SizeLayer_(dummy,layer,dx,dy)</fullCommand>
    <parameters>(dummy,layer,dx,dy)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ScrollLayer_">
    <keyword>ScrollLayer_</keyword>
    <fullCommand>ScrollLayer_(dummy,layer,dx,dy)</fullCommand>
    <parameters>(dummy,layer,dx,dy)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EndUpdate_">
    <keyword>EndUpdate_</keyword>
    <fullCommand>EndUpdate_(layer,flag)</fullCommand>
    <parameters>(layer,flag)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeleteLayer_">
    <keyword>DeleteLayer_</keyword>
    <fullCommand>DeleteLayer_(dummy,layer)</fullCommand>
    <parameters>(dummy,layer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LockLayer_">
    <keyword>LockLayer_</keyword>
    <fullCommand>LockLayer_(dummy,layer)</fullCommand>
    <parameters>(dummy,layer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SwapBitsRastPortClipRect_">
    <keyword>SwapBitsRastPortClipRect_</keyword>
    <fullCommand>SwapBitsRastPortClipRect_(rp,cr)</fullCommand>
    <parameters>(rp,cr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NewLayerInfo_">
    <keyword>NewLayerInfo_</keyword>
    <fullCommand>NewLayerInfo_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MoveLayerInFrontOf_">
    <keyword>MoveLayerInFrontOf_</keyword>
    <fullCommand>MoveLayerInFrontOf_(layer_to_move,other_layer)</fullCommand>
    <parameters>(layer_to_move,other_layer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InstallClipRegion_">
    <keyword>InstallClipRegion_</keyword>
    <fullCommand>InstallClipRegion_(layer,region)</fullCommand>
    <parameters>(layer,region)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InstallLayerHook_">
    <keyword>InstallLayerHook_</keyword>
    <fullCommand>InstallLayerHook_(layer,hook)</fullCommand>
    <parameters>(layer,hook)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InstallLayerInfoHook_">
    <keyword>InstallLayerInfoHook_</keyword>
    <fullCommand>InstallLayerInfoHook_(li,hook)</fullCommand>
    <parameters>(li,hook)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AskKeyMapDefault_">
    <keyword>AskKeyMapDefault_</keyword>
    <fullCommand>AskKeyMapDefault_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MapRawKey_">
    <keyword>MapRawKey_</keyword>
    <fullCommand>MapRawKey_(event,buffer,length,keyMap)</fullCommand>
    <parameters>(event,buffer,length,keyMap)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenIntuition_">
    <keyword>OpenIntuition_</keyword>
    <fullCommand>OpenIntuition_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseWorkBench_">
    <keyword>CloseWorkBench_</keyword>
    <fullCommand>CloseWorkBench_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CurrentTime_">
    <keyword>CurrentTime_</keyword>
    <fullCommand>CurrentTime_(seconds,micros)</fullCommand>
    <parameters>(seconds,micros)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DoubleClick_">
    <keyword>DoubleClick_</keyword>
    <fullCommand>DoubleClick_(sSeconds,sMicros,cSeconds,cMicros)</fullCommand>
    <parameters>(sSeconds,sMicros,cSeconds,cMicros)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DrawBorder_">
    <keyword>DrawBorder_</keyword>
    <fullCommand>DrawBorder_(rp,border,leftOffset,topOffset)</fullCommand>
    <parameters>(rp,border,leftOffset,topOffset)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DrawImage_">
    <keyword>DrawImage_</keyword>
    <fullCommand>DrawImage_(rp,image,leftOffset,topOffset)</fullCommand>
    <parameters>(rp,image,leftOffset,topOffset)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EndRequest_">
    <keyword>EndRequest_</keyword>
    <fullCommand>EndRequest_(requester,window)</fullCommand>
    <parameters>(requester,window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDefPrefs_">
    <keyword>GetDefPrefs_</keyword>
    <fullCommand>GetDefPrefs_(preferences,size)</fullCommand>
    <parameters>(preferences,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPrefs_">
    <keyword>GetPrefs_</keyword>
    <fullCommand>GetPrefs_(preferences,size)</fullCommand>
    <parameters>(preferences,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ItemAddress_">
    <keyword>ItemAddress_</keyword>
    <fullCommand>ItemAddress_(menuStrip,menuNumber)</fullCommand>
    <parameters>(menuStrip,menuNumber)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ModifyIDCMP_">
    <keyword>ModifyIDCMP_</keyword>
    <fullCommand>ModifyIDCMP_(window,flags)</fullCommand>
    <parameters>(window,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ModifyProp_">
    <keyword>ModifyProp_</keyword>
    <fullCommand>ModifyProp_(gadget,window,requester,flags,horizPot,vertPot,horizBody,vertBody)</fullCommand>
    <parameters>(gadget,window,requester,flags,horizPot,vertPot,horizBody,vertBody)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OffMenu_">
    <keyword>OffMenu_</keyword>
    <fullCommand>OffMenu_(window,menuNumber)</fullCommand>
    <parameters>(window,menuNumber)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OnMenu_">
    <keyword>OnMenu_</keyword>
    <fullCommand>OnMenu_(window,menuNumber)</fullCommand>
    <parameters>(window,menuNumber)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenWorkBench_">
    <keyword>OpenWorkBench_</keyword>
    <fullCommand>OpenWorkBench_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PrintIText_">
    <keyword>PrintIText_</keyword>
    <fullCommand>PrintIText_(rp,iText,left,top)</fullCommand>
    <parameters>(rp,iText,left,top)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemoveGadget_">
    <keyword>RemoveGadget_</keyword>
    <fullCommand>RemoveGadget_(window,gadget)</fullCommand>
    <parameters>(window,gadget)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReportMouse_">
    <keyword>ReportMouse_</keyword>
    <fullCommand>ReportMouse_(flag,window)</fullCommand>
    <parameters>(flag,window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Request_">
    <keyword>Request_</keyword>
    <fullCommand>Request_(requester,window)</fullCommand>
    <parameters>(requester,window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetDMRequest_">
    <keyword>SetDMRequest_</keyword>
    <fullCommand>SetDMRequest_(window,requester)</fullCommand>
    <parameters>(window,requester)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetMenuStrip_">
    <keyword>SetMenuStrip_</keyword>
    <fullCommand>SetMenuStrip_(window,menu)</fullCommand>
    <parameters>(window,menu)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPointer_">
    <keyword>SetPointer_</keyword>
    <fullCommand>SetPointer_(window,pointer,height,width,xOffset,yOffset)</fullCommand>
    <parameters>(window,pointer,height,width,xOffset,yOffset)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ShowTitle_">
    <keyword>ShowTitle_</keyword>
    <fullCommand>ShowTitle_(screen,showIt)</fullCommand>
    <parameters>(screen,showIt)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ViewAddress_">
    <keyword>ViewAddress_</keyword>
    <fullCommand>ViewAddress_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WBenchToBack_">
    <keyword>WBenchToBack_</keyword>
    <fullCommand>WBenchToBack_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WBenchToFront_">
    <keyword>WBenchToFront_</keyword>
    <fullCommand>WBenchToFront_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AutoRequest_">
    <keyword>AutoRequest_</keyword>
    <fullCommand>AutoRequest_(window,body,posText,negText,pFlag,nFlag,width,height)</fullCommand>
    <parameters>(window,body,posText,negText,pFlag,nFlag,width,height)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EndRefresh_">
    <keyword>EndRefresh_</keyword>
    <fullCommand>EndRefresh_(window,complete)</fullCommand>
    <parameters>(window,complete)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemakeDisplay_">
    <keyword>RemakeDisplay_</keyword>
    <fullCommand>RemakeDisplay_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RethinkDisplay_">
    <keyword>RethinkDisplay_</keyword>
    <fullCommand>RethinkDisplay_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeRemember_">
    <keyword>FreeRemember_</keyword>
    <fullCommand>FreeRemember_(rememberKey,reallyForget)</fullCommand>
    <parameters>(rememberKey,reallyForget)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetScreenData_">
    <keyword>GetScreenData_</keyword>
    <fullCommand>GetScreenData_(buffer,size,type,screen)</fullCommand>
    <parameters>(buffer,size,type,screen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RefreshGList_">
    <keyword>RefreshGList_</keyword>
    <fullCommand>RefreshGList_(gadgets,window,requester,numGad)</fullCommand>
    <parameters>(gadgets,window,requester,numGad)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MoveWindowInFrontOf_">
    <keyword>MoveWindowInFrontOf_</keyword>
    <fullCommand>MoveWindowInFrontOf_(window,behindWindow)</fullCommand>
    <parameters>(window,behindWindow)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetMouseQueue_">
    <keyword>SetMouseQueue_</keyword>
    <fullCommand>SetMouseQueue_(window,queueLength)</fullCommand>
    <parameters>(window,queueLength)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnlockPubScreen_">
    <keyword>UnlockPubScreen_</keyword>
    <fullCommand>UnlockPubScreen_(name,screen)</fullCommand>
    <parameters>(name,screen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LockPubScreenList_">
    <keyword>LockPubScreenList_</keyword>
    <fullCommand>LockPubScreenList_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnlockPubScreenList_">
    <keyword>UnlockPubScreenList_</keyword>
    <fullCommand>UnlockPubScreenList_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NextPubScreen_">
    <keyword>NextPubScreen_</keyword>
    <fullCommand>NextPubScreen_(screen,namebuf)</fullCommand>
    <parameters>(screen,namebuf)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PubScreenStatus_">
    <keyword>PubScreenStatus_</keyword>
    <fullCommand>PubScreenStatus_(screen,statusFlags)</fullCommand>
    <parameters>(screen,statusFlags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EasyRequestArgs_">
    <keyword>EasyRequestArgs_</keyword>
    <fullCommand>EasyRequestArgs_(window,easyStruct,idcmpPtr,args)</fullCommand>
    <parameters>(window,easyStruct,idcmpPtr,args)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BuildEasyRequestArgs_">
    <keyword>BuildEasyRequestArgs_</keyword>
    <fullCommand>BuildEasyRequestArgs_(window,easyStruct,idcmp,args)</fullCommand>
    <parameters>(window,easyStruct,idcmp,args)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenWindowTagList_">
    <keyword>OpenWindowTagList_</keyword>
    <fullCommand>OpenWindowTagList_(newWindow,tagList)</fullCommand>
    <parameters>(newWindow,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenScreenTagList_">
    <keyword>OpenScreenTagList_</keyword>
    <fullCommand>OpenScreenTagList_(newScreen,tagList)</fullCommand>
    <parameters>(newScreen,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DrawImageState_">
    <keyword>DrawImageState_</keyword>
    <fullCommand>DrawImageState_(rp,image,leftOffset,topOffset,state,drawInfo)</fullCommand>
    <parameters>(rp,image,leftOffset,topOffset,state,drawInfo)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PointInImage_">
    <keyword>PointInImage_</keyword>
    <fullCommand>PointInImage_(point,image)</fullCommand>
    <parameters>(point,image)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EraseImage_">
    <keyword>EraseImage_</keyword>
    <fullCommand>EraseImage_(rp,image,leftOffset,topOffset)</fullCommand>
    <parameters>(rp,image,leftOffset,topOffset)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetAttrsA_">
    <keyword>SetAttrsA_</keyword>
    <fullCommand>SetAttrsA_(object,tagList)</fullCommand>
    <parameters>(object,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetGadgetAttrsA_">
    <keyword>SetGadgetAttrsA_</keyword>
    <fullCommand>SetGadgetAttrsA_(gadget,window,requester,tagList)</fullCommand>
    <parameters>(gadget,window,requester,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeScreenDrawInfo_">
    <keyword>FreeScreenDrawInfo_</keyword>
    <fullCommand>FreeScreenDrawInfo_(screen,drawInfo)</fullCommand>
    <parameters>(screen,drawInfo)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ResetMenuStrip_">
    <keyword>ResetMenuStrip_</keyword>
    <fullCommand>ResetMenuStrip_(window,menu)</fullCommand>
    <parameters>(window,menu)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeScreenBuffer_">
    <keyword>FreeScreenBuffer_</keyword>
    <fullCommand>FreeScreenBuffer_(sc,sb)</fullCommand>
    <parameters>(sc,sb)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChangeScreenBuffer_">
    <keyword>ChangeScreenBuffer_</keyword>
    <fullCommand>ChangeScreenBuffer_(sc,sb)</fullCommand>
    <parameters>(sc,sb)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ScreenPosition_">
    <keyword>ScreenPosition_</keyword>
    <fullCommand>ScreenPosition_(screen,flags,x1,y1,x2,y2)</fullCommand>
    <parameters>(screen,flags,x1,y1,x2,y2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LendMenus_">
    <keyword>LendMenus_</keyword>
    <fullCommand>LendMenus_(fromwindow,towindow)</fullCommand>
    <parameters>(fromwindow,towindow)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DoGadgetMethodA_">
    <keyword>DoGadgetMethodA_</keyword>
    <fullCommand>DoGadgetMethodA_(gad,win,req,message)</fullCommand>
    <parameters>(gad,win,req,message)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetWindowPointerA_">
    <keyword>SetWindowPointerA_</keyword>
    <fullCommand>SetWindowPointerA_(win,taglist)</fullCommand>
    <parameters>(win,taglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TimedDisplayAlert_">
    <keyword>TimedDisplayAlert_</keyword>
    <fullCommand>TimedDisplayAlert_(alertNumber,string,height,time)</fullCommand>
    <parameters>(alertNumber,string,height,time)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="HelpControl_">
    <keyword>HelpControl_</keyword>
    <fullCommand>HelpControl_(win,flags)</fullCommand>
    <parameters>(win,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocIFF_">
    <keyword>AllocIFF_</keyword>
    <fullCommand>AllocIFF_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenIFF_">
    <keyword>OpenIFF_</keyword>
    <fullCommand>OpenIFF_(iff,rwMode)</fullCommand>
    <parameters>(iff,rwMode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ParseIFF_">
    <keyword>ParseIFF_</keyword>
    <fullCommand>ParseIFF_(iff,control)</fullCommand>
    <parameters>(iff,control)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadChunkRecords_">
    <keyword>ReadChunkRecords_</keyword>
    <fullCommand>ReadChunkRecords_(iff,buf,bytesPerRecord,numRecords)</fullCommand>
    <parameters>(iff,buf,bytesPerRecord,numRecords)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WriteChunkRecords_">
    <keyword>WriteChunkRecords_</keyword>
    <fullCommand>WriteChunkRecords_(iff,buf,bytesPerRecord,numRecords)</fullCommand>
    <parameters>(iff,buf,bytesPerRecord,numRecords)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PushChunk_">
    <keyword>PushChunk_</keyword>
    <fullCommand>PushChunk_(iff,type,id,size)</fullCommand>
    <parameters>(iff,type,id,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EntryHandler_">
    <keyword>EntryHandler_</keyword>
    <fullCommand>EntryHandler_(iff,type,id,position,handler,object)</fullCommand>
    <parameters>(iff,type,id,position,handler,object)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExitHandler_">
    <keyword>ExitHandler_</keyword>
    <fullCommand>ExitHandler_(iff,type,id,position,handler,object)</fullCommand>
    <parameters>(iff,type,id,position,handler,object)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocLocalItem_">
    <keyword>AllocLocalItem_</keyword>
    <fullCommand>AllocLocalItem_(type,id,ident,dataSize)</fullCommand>
    <parameters>(type,id,ident,dataSize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetLocalItemPurge_">
    <keyword>SetLocalItemPurge_</keyword>
    <fullCommand>SetLocalItemPurge_(localItem,purgeHook)</fullCommand>
    <parameters>(localItem,purgeHook)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindLocalItem_">
    <keyword>FindLocalItem_</keyword>
    <fullCommand>FindLocalItem_(iff,type,id,ident)</fullCommand>
    <parameters>(iff,type,id,ident)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IDtoStr_">
    <keyword>IDtoStr_</keyword>
    <fullCommand>IDtoStr_(id,buf)</fullCommand>
    <parameters>(id,buf)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PutIcon_">
    <keyword>PutIcon_</keyword>
    <fullCommand>PutIcon_(name,icon)</fullCommand>
    <parameters>(name,icon)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PutDiskObject_">
    <keyword>PutDiskObject_</keyword>
    <fullCommand>PutDiskObject_(name,diskobj)</fullCommand>
    <parameters>(name,diskobj)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindToolType_">
    <keyword>FindToolType_</keyword>
    <fullCommand>FindToolType_(toolTypeArray,typeName)</fullCommand>
    <parameters>(toolTypeArray,typeName)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MatchToolValue_">
    <keyword>MatchToolValue_</keyword>
    <fullCommand>MatchToolValue_(typeString,value)</fullCommand>
    <parameters>(typeString,value)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BumpRevision_">
    <keyword>BumpRevision_</keyword>
    <fullCommand>BumpRevision_(newname,oldname)</fullCommand>
    <parameters>(newname,oldname)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExtendFont_">
    <keyword>ExtendFont_</keyword>
    <fullCommand>ExtendFont_(font,fontTags)</fullCommand>
    <parameters>(font,fontTags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CalcIVG_">
    <keyword>CalcIVG_</keyword>
    <fullCommand>CalcIVG_(v,vp)</fullCommand>
    <parameters>(v,vp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AttachPalExtra_">
    <keyword>AttachPalExtra_</keyword>
    <fullCommand>AttachPalExtra_(cm,vp)</fullCommand>
    <parameters>(cm,vp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GfxInternal3_">
    <keyword>GfxInternal3_</keyword>
    <fullCommand>GfxInternal3_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LoadRGB32_">
    <keyword>LoadRGB32_</keyword>
    <fullCommand>LoadRGB32_(vp,table)</fullCommand>
    <parameters>(vp,table)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetABPenDrMd_">
    <keyword>SetABPenDrMd_</keyword>
    <fullCommand>SetABPenDrMd_(rp,apen,bpen,drawmode)</fullCommand>
    <parameters>(rp,apen,bpen,drawmode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetRGB32_">
    <keyword>GetRGB32_</keyword>
    <fullCommand>GetRGB32_(cm,firstcolor,ncolors,table)</fullCommand>
    <parameters>(cm,firstcolor,ncolors,table)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GfxSpare1_">
    <keyword>GfxSpare1_</keyword>
    <fullCommand>GfxSpare1_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetExtSpriteA_">
    <keyword>GetExtSpriteA_</keyword>
    <fullCommand>GetExtSpriteA_(ss,tags)</fullCommand>
    <parameters>(ss,tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReleasePen_">
    <keyword>ReleasePen_</keyword>
    <fullCommand>ReleasePen_(cm,n)</fullCommand>
    <parameters>(cm,n)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ObtainPen_">
    <keyword>ObtainPen_</keyword>
    <fullCommand>ObtainPen_(cm,n,r,g,b,f)</fullCommand>
    <parameters>(cm,n,r,g,b,f)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetBitMapAttr_">
    <keyword>GetBitMapAttr_</keyword>
    <fullCommand>GetBitMapAttr_(bm,attrnum)</fullCommand>
    <parameters>(bm,attrnum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetOutlinePen_">
    <keyword>SetOutlinePen_</keyword>
    <fullCommand>SetOutlinePen_(rp,pen)</fullCommand>
    <parameters>(rp,pen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetWriteMask_">
    <keyword>SetWriteMask_</keyword>
    <fullCommand>SetWriteMask_(rp,msk)</fullCommand>
    <parameters>(rp,msk)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetMaxPen_">
    <keyword>SetMaxPen_</keyword>
    <fullCommand>SetMaxPen_(rp,maxpen)</fullCommand>
    <parameters>(rp,maxpen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GfxSpare2_">
    <keyword>GfxSpare2_</keyword>
    <fullCommand>GfxSpare2_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocSpriteDataA_">
    <keyword>AllocSpriteDataA_</keyword>
    <fullCommand>AllocSpriteDataA_(bm,tags)</fullCommand>
    <parameters>(bm,tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChangeExtSpriteA_">
    <keyword>ChangeExtSpriteA_</keyword>
    <fullCommand>ChangeExtSpriteA_(vp,oldsprite,newsprite,tags)</fullCommand>
    <parameters>(vp,oldsprite,newsprite,tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetRPAttrsA_">
    <keyword>SetRPAttrsA_</keyword>
    <fullCommand>SetRPAttrsA_(rp,tags)</fullCommand>
    <parameters>(rp,tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetRPAttrsA_">
    <keyword>GetRPAttrsA_</keyword>
    <fullCommand>GetRPAttrsA_(rp,tags)</fullCommand>
    <parameters>(rp,tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BltTemplate_">
    <keyword>BltTemplate_</keyword>
    <fullCommand>BltTemplate_(source,xSrc,srcMod,destRP,xDest,yDest,xSize,ySize)</fullCommand>
    <parameters>(source,xSrc,srcMod,destRP,xDest,yDest,xSize,ySize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetFont_">
    <keyword>SetFont_</keyword>
    <fullCommand>SetFont_(rp,textFont)</fullCommand>
    <parameters>(rp,textFont)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddBob_">
    <keyword>AddBob_</keyword>
    <fullCommand>AddBob_(bob,rp)</fullCommand>
    <parameters>(bob,rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddVSprite_">
    <keyword>AddVSprite_</keyword>
    <fullCommand>AddVSprite_(vSprite,rp)</fullCommand>
    <parameters>(vSprite,rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DrawGList_">
    <keyword>DrawGList_</keyword>
    <fullCommand>DrawGList_(rp,vp)</fullCommand>
    <parameters>(rp,vp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Animate_">
    <keyword>Animate_</keyword>
    <fullCommand>Animate_(anKey,rp)</fullCommand>
    <parameters>(anKey,rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MakeVPort_">
    <keyword>MakeVPort_</keyword>
    <fullCommand>MakeVPort_(view,vp)</fullCommand>
    <parameters>(view,vp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WaitBlit_">
    <keyword>WaitBlit_</keyword>
    <fullCommand>WaitBlit_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetRast_">
    <keyword>SetRast_</keyword>
    <fullCommand>SetRast_(rp,pen)</fullCommand>
    <parameters>(rp,pen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WaitTOF_">
    <keyword>WaitTOF_</keyword>
    <fullCommand>WaitTOF_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Flood_">
    <keyword>Flood_</keyword>
    <fullCommand>Flood_(rp,mode,x,y)</fullCommand>
    <parameters>(rp,mode,x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetAPen_">
    <keyword>SetAPen_</keyword>
    <fullCommand>SetAPen_(rp,pen)</fullCommand>
    <parameters>(rp,pen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetBPen_">
    <keyword>SetBPen_</keyword>
    <fullCommand>SetBPen_(rp,pen)</fullCommand>
    <parameters>(rp,pen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetDrMd_">
    <keyword>SetDrMd_</keyword>
    <fullCommand>SetDrMd_(rp,drawMode)</fullCommand>
    <parameters>(rp,drawMode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="VBeamPos_">
    <keyword>VBeamPos_</keyword>
    <fullCommand>VBeamPos_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitBitMap_">
    <keyword>InitBitMap_</keyword>
    <fullCommand>InitBitMap_(bitMap,depth,width,height)</fullCommand>
    <parameters>(bitMap,depth,width,height)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetSprite_">
    <keyword>GetSprite_</keyword>
    <fullCommand>GetSprite_(sprite,num)</fullCommand>
    <parameters>(sprite,num)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MoveSprite_">
    <keyword>MoveSprite_</keyword>
    <fullCommand>MoveSprite_(vp,sprite,x,y)</fullCommand>
    <parameters>(vp,sprite,x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OwnBlitter_">
    <keyword>OwnBlitter_</keyword>
    <fullCommand>OwnBlitter_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DisownBlitter_">
    <keyword>DisownBlitter_</keyword>
    <fullCommand>DisownBlitter_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AskFont_">
    <keyword>AskFont_</keyword>
    <fullCommand>AskFont_(rp,textAttr)</fullCommand>
    <parameters>(rp,textAttr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocRaster_">
    <keyword>AllocRaster_</keyword>
    <fullCommand>AllocRaster_(width,height)</fullCommand>
    <parameters>(width,height)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AndRectRegion_">
    <keyword>AndRectRegion_</keyword>
    <fullCommand>AndRectRegion_(region,rectangle)</fullCommand>
    <parameters>(region,rectangle)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OrRectRegion_">
    <keyword>OrRectRegion_</keyword>
    <fullCommand>OrRectRegion_(region,rectangle)</fullCommand>
    <parameters>(region,rectangle)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NewRegion_">
    <keyword>NewRegion_</keyword>
    <fullCommand>NewRegion_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClearRectRegion_">
    <keyword>ClearRectRegion_</keyword>
    <fullCommand>ClearRectRegion_(region,rectangle)</fullCommand>
    <parameters>(region,rectangle)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XorRectRegion_">
    <keyword>XorRectRegion_</keyword>
    <fullCommand>XorRectRegion_(region,rectangle)</fullCommand>
    <parameters>(region,rectangle)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetRGB4_">
    <keyword>GetRGB4_</keyword>
    <fullCommand>GetRGB4_(colorMap,entry)</fullCommand>
    <parameters>(colorMap,entry)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UCopperListInit_">
    <keyword>UCopperListInit_</keyword>
    <fullCommand>UCopperListInit_(uCopList,n)</fullCommand>
    <parameters>(uCopList,n)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OrRegionRegion_">
    <keyword>OrRegionRegion_</keyword>
    <fullCommand>OrRegionRegion_(srcRegion,destRegion)</fullCommand>
    <parameters>(srcRegion,destRegion)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XorRegionRegion_">
    <keyword>XorRegionRegion_</keyword>
    <fullCommand>XorRegionRegion_(srcRegion,destRegion)</fullCommand>
    <parameters>(srcRegion,destRegion)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AndRegionRegion_">
    <keyword>AndRegionRegion_</keyword>
    <fullCommand>AndRegionRegion_(srcRegion,destRegion)</fullCommand>
    <parameters>(srcRegion,destRegion)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BltMaskBitMapRastPort_">
    <keyword>BltMaskBitMapRastPort_</keyword>
    <fullCommand>BltMaskBitMapRastPort_(srcBitMap,xSrc,ySrc,destRP,xDest,yDest,xSize,ySize,minterm,bltMask)</fullCommand>
    <parameters>(srcBitMap,xSrc,ySrc,destRP,xDest,yDest,xSize,ySize,minterm,bltMask)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GfxInternal1_">
    <keyword>GfxInternal1_</keyword>
    <fullCommand>GfxInternal1_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GfxInternal2_">
    <keyword>GfxInternal2_</keyword>
    <fullCommand>GfxInternal2_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GfxAssociate_">
    <keyword>GfxAssociate_</keyword>
    <fullCommand>GfxAssociate_(associateNode,gfxNodePtr)</fullCommand>
    <parameters>(associateNode,gfxNodePtr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TextExtent_">
    <keyword>TextExtent_</keyword>
    <fullCommand>TextExtent_(rp,string,count,textExtent)</fullCommand>
    <parameters>(rp,string,count,textExtent)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TextFit_">
    <keyword>TextFit_</keyword>
    <fullCommand>TextFit_(rp,string,strLen,textExtent,constrainingExtent,strDirection,constrainingBitWidth,constrainingBitHeight)</fullCommand>
    <parameters>(rp,string,strLen,textExtent,constrainingExtent,strDirection,constrainingBitWidth,constrainingBitHeight)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="VideoControl_">
    <keyword>VideoControl_</keyword>
    <fullCommand>VideoControl_(colorMap,tagarray)</fullCommand>
    <parameters>(colorMap,tagarray)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenMonitor_">
    <keyword>OpenMonitor_</keyword>
    <fullCommand>OpenMonitor_(monitorName,displayID)</fullCommand>
    <parameters>(monitorName,displayID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FontExtent_">
    <keyword>FontExtent_</keyword>
    <fullCommand>FontExtent_(font,fontExtent)</fullCommand>
    <parameters>(font,fontExtent)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadPixelLine8_">
    <keyword>ReadPixelLine8_</keyword>
    <fullCommand>ReadPixelLine8_(rp,xstart,ystart,width,array,tempRP)</fullCommand>
    <parameters>(rp,xstart,ystart,width,array,tempRP)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WritePixelLine8_">
    <keyword>WritePixelLine8_</keyword>
    <fullCommand>WritePixelLine8_(rp,xstart,ystart,width,array,tempRP)</fullCommand>
    <parameters>(rp,xstart,ystart,width,array,tempRP)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateGadgetA_">
    <keyword>CreateGadgetA_</keyword>
    <fullCommand>CreateGadgetA_(kind,gad,ng,taglist)</fullCommand>
    <parameters>(kind,gad,ng,taglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GT_SetGadgetAttrsA_">
    <keyword>GT_SetGadgetAttrsA_</keyword>
    <fullCommand>GT_SetGadgetAttrsA_(gad,win,req,taglist)</fullCommand>
    <parameters>(gad,win,req,taglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateMenusA_">
    <keyword>CreateMenusA_</keyword>
    <fullCommand>CreateMenusA_(newmenu,taglist)</fullCommand>
    <parameters>(newmenu,taglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GT_RefreshWindow_">
    <keyword>GT_RefreshWindow_</keyword>
    <fullCommand>GT_RefreshWindow_(win,req)</fullCommand>
    <parameters>(win,req)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GT_EndRefresh_">
    <keyword>GT_EndRefresh_</keyword>
    <fullCommand>GT_EndRefresh_(win,complete)</fullCommand>
    <parameters>(win,complete)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DrawBevelBoxA_">
    <keyword>DrawBevelBoxA_</keyword>
    <fullCommand>DrawBevelBoxA_(rport,left,top,width,height,taglist)</fullCommand>
    <parameters>(rport,left,top,width,height,taglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetVisualInfoA_">
    <keyword>GetVisualInfoA_</keyword>
    <fullCommand>GetVisualInfoA_(screen,taglist)</fullCommand>
    <parameters>(screen,taglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GT_GetGadgetAttrsA_">
    <keyword>GT_GetGadgetAttrsA_</keyword>
    <fullCommand>GT_GetGadgetAttrsA_(gad,win,req,taglist)</fullCommand>
    <parameters>(gad,win,req,taglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddBootNode_">
    <keyword>AddBootNode_</keyword>
    <fullCommand>AddBootNode_(bootPri,flags,deviceNode,configDev)</fullCommand>
    <parameters>(bootPri,flags,deviceNode,configDev)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocConfigDev_">
    <keyword>AllocConfigDev_</keyword>
    <fullCommand>AllocConfigDev_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocExpansionMem_">
    <keyword>AllocExpansionMem_</keyword>
    <fullCommand>AllocExpansionMem_(numSlots,slotAlign)</fullCommand>
    <parameters>(numSlots,slotAlign)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ConfigBoard_">
    <keyword>ConfigBoard_</keyword>
    <fullCommand>ConfigBoard_(board,configDev)</fullCommand>
    <parameters>(board,configDev)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeBoardMem_">
    <keyword>FreeBoardMem_</keyword>
    <fullCommand>FreeBoardMem_(startSlot,slotSpec)</fullCommand>
    <parameters>(startSlot,slotSpec)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeExpansionMem_">
    <keyword>FreeExpansionMem_</keyword>
    <fullCommand>FreeExpansionMem_(startSlot,numSlots)</fullCommand>
    <parameters>(startSlot,numSlots)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadExpansionByte_">
    <keyword>ReadExpansionByte_</keyword>
    <fullCommand>ReadExpansionByte_(board,offset)</fullCommand>
    <parameters>(board,offset)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadExpansionRom_">
    <keyword>ReadExpansionRom_</keyword>
    <fullCommand>ReadExpansionRom_(board,configDev)</fullCommand>
    <parameters>(board,configDev)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ObtainConfigBinding_">
    <keyword>ObtainConfigBinding_</keyword>
    <fullCommand>ObtainConfigBinding_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReleaseConfigBinding_">
    <keyword>ReleaseConfigBinding_</keyword>
    <fullCommand>ReleaseConfigBinding_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetCurrentBinding_">
    <keyword>SetCurrentBinding_</keyword>
    <fullCommand>SetCurrentBinding_(currentBinding,bindingSize)</fullCommand>
    <parameters>(currentBinding,bindingSize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetCurrentBinding_">
    <keyword>GetCurrentBinding_</keyword>
    <fullCommand>GetCurrentBinding_(currentBinding,bindingSize)</fullCommand>
    <parameters>(currentBinding,bindingSize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitCode_">
    <keyword>InitCode_</keyword>
    <fullCommand>InitCode_(startClass,version)</fullCommand>
    <parameters>(startClass,version)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitResident_">
    <keyword>InitResident_</keyword>
    <fullCommand>InitResident_(resident,segList)</fullCommand>
    <parameters>(resident,segList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Disable_">
    <keyword>Disable_</keyword>
    <fullCommand>Disable_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Enable_">
    <keyword>Enable_</keyword>
    <fullCommand>Enable_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Forbid_">
    <keyword>Forbid_</keyword>
    <fullCommand>Forbid_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Permit_">
    <keyword>Permit_</keyword>
    <fullCommand>Permit_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetSR_">
    <keyword>SetSR_</keyword>
    <fullCommand>SetSR_(newSR,mask)</fullCommand>
    <parameters>(newSR,mask)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SuperState_">
    <keyword>SuperState_</keyword>
    <fullCommand>SuperState_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetIntVector_">
    <keyword>SetIntVector_</keyword>
    <fullCommand>SetIntVector_(intNumber,interrupt)</fullCommand>
    <parameters>(intNumber,interrupt)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddIntServer_">
    <keyword>AddIntServer_</keyword>
    <fullCommand>AddIntServer_(intNumber,interrupt)</fullCommand>
    <parameters>(intNumber,interrupt)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemIntServer_">
    <keyword>RemIntServer_</keyword>
    <fullCommand>RemIntServer_(intNumber,interrupt)</fullCommand>
    <parameters>(intNumber,interrupt)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Allocate_">
    <keyword>Allocate_</keyword>
    <fullCommand>Allocate_(freeList,byteSize)</fullCommand>
    <parameters>(freeList,byteSize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocMem_">
    <keyword>AllocMem_</keyword>
    <fullCommand>AllocMem_(byteSize,requirements)</fullCommand>
    <parameters>(byteSize,requirements)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocAbs_">
    <keyword>AllocAbs_</keyword>
    <fullCommand>AllocAbs_(byteSize,location)</fullCommand>
    <parameters>(byteSize,location)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeMem_">
    <keyword>FreeMem_</keyword>
    <fullCommand>FreeMem_(memoryBlock,byteSize)</fullCommand>
    <parameters>(memoryBlock,byteSize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddHead_">
    <keyword>AddHead_</keyword>
    <fullCommand>AddHead_(list,node)</fullCommand>
    <parameters>(list,node)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddTail_">
    <keyword>AddTail_</keyword>
    <fullCommand>AddTail_(list,node)</fullCommand>
    <parameters>(list,node)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Enqueue_">
    <keyword>Enqueue_</keyword>
    <fullCommand>Enqueue_(list,node)</fullCommand>
    <parameters>(list,node)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindName_">
    <keyword>FindName_</keyword>
    <fullCommand>FindName_(list,name)</fullCommand>
    <parameters>(list,name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetTaskPri_">
    <keyword>SetTaskPri_</keyword>
    <fullCommand>SetTaskPri_(task,priority)</fullCommand>
    <parameters>(task,priority)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetSignal_">
    <keyword>SetSignal_</keyword>
    <fullCommand>SetSignal_(newSignals,signalSet)</fullCommand>
    <parameters>(newSignals,signalSet)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetExcept_">
    <keyword>SetExcept_</keyword>
    <fullCommand>SetExcept_(newSignals,signalSet)</fullCommand>
    <parameters>(newSignals,signalSet)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Signal_">
    <keyword>Signal_</keyword>
    <fullCommand>Signal_(task,signalSet)</fullCommand>
    <parameters>(task,signalSet)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PutMsg_">
    <keyword>PutMsg_</keyword>
    <fullCommand>PutMsg_(port,message)</fullCommand>
    <parameters>(port,message)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenDevice_">
    <keyword>OpenDevice_</keyword>
    <fullCommand>OpenDevice_(devName,unit,ioRequest,flags)</fullCommand>
    <parameters>(devName,unit,ioRequest,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RawDoFmt_">
    <keyword>RawDoFmt_</keyword>
    <fullCommand>RawDoFmt_(formatString,dataStream,putChProc,putChData)</fullCommand>
    <parameters>(formatString,dataStream,putChProc,putChData)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetCC_">
    <keyword>GetCC_</keyword>
    <fullCommand>GetCC_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Procure_">
    <keyword>Procure_</keyword>
    <fullCommand>Procure_(sigSem,bidMsg)</fullCommand>
    <parameters>(sigSem,bidMsg)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Vacate_">
    <keyword>Vacate_</keyword>
    <fullCommand>Vacate_(sigSem,bidMsg)</fullCommand>
    <parameters>(sigSem,bidMsg)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenLibrary_">
    <keyword>OpenLibrary_</keyword>
    <fullCommand>OpenLibrary_(libName,version)</fullCommand>
    <parameters>(libName,version)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SumKickData_">
    <keyword>SumKickData_</keyword>
    <fullCommand>SumKickData_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CacheClearU_">
    <keyword>CacheClearU_</keyword>
    <fullCommand>CacheClearU_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CacheControl_">
    <keyword>CacheControl_</keyword>
    <fullCommand>CacheControl_(cacheBits,cacheMask)</fullCommand>
    <parameters>(cacheBits,cacheMask)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateIORequest_">
    <keyword>CreateIORequest_</keyword>
    <fullCommand>CreateIORequest_(port,size)</fullCommand>
    <parameters>(port,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateMsgPort_">
    <keyword>CreateMsgPort_</keyword>
    <fullCommand>CreateMsgPort_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocVec_">
    <keyword>AllocVec_</keyword>
    <fullCommand>AllocVec_(byteSize,requirements)</fullCommand>
    <parameters>(byteSize,requirements)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocPooled_">
    <keyword>AllocPooled_</keyword>
    <fullCommand>AllocPooled_(poolHeader,memSize)</fullCommand>
    <parameters>(poolHeader,memSize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ColdReboot_">
    <keyword>ColdReboot_</keyword>
    <fullCommand>ColdReboot_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrToLong_">
    <keyword>StrToLong_</keyword>
    <fullCommand>StrToLong_(string,value)</fullCommand>
    <parameters>(string,value)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MatchFirst_">
    <keyword>MatchFirst_</keyword>
    <fullCommand>MatchFirst_(pat,anchor)</fullCommand>
    <parameters>(pat,anchor)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MatchPattern_">
    <keyword>MatchPattern_</keyword>
    <fullCommand>MatchPattern_(pat,str)</fullCommand>
    <parameters>(pat,str)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetVar_">
    <keyword>SetVar_</keyword>
    <fullCommand>SetVar_(name,buffer,size,flags)</fullCommand>
    <parameters>(name,buffer,size,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetVar_">
    <keyword>GetVar_</keyword>
    <fullCommand>GetVar_(name,buffer,size,flags)</fullCommand>
    <parameters>(name,buffer,size,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeleteVar_">
    <keyword>DeleteVar_</keyword>
    <fullCommand>DeleteVar_(name,flags)</fullCommand>
    <parameters>(name,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindVar_">
    <keyword>FindVar_</keyword>
    <fullCommand>FindVar_(name,type)</fullCommand>
    <parameters>(name,type)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WriteChars_">
    <keyword>WriteChars_</keyword>
    <fullCommand>WriteChars_(buf,buflen)</fullCommand>
    <parameters>(buf,buflen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="VPrintf_">
    <keyword>VPrintf_</keyword>
    <fullCommand>VPrintf_(format,argarray)</fullCommand>
    <parameters>(format,argarray)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MatchPatternNoCase_">
    <keyword>MatchPatternNoCase_</keyword>
    <fullCommand>MatchPatternNoCase_(pat,str)</fullCommand>
    <parameters>(pat,str)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SameDevice_">
    <keyword>SameDevice_</keyword>
    <fullCommand>SameDevice_(lock1,lock2)</fullCommand>
    <parameters>(lock1,lock2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetOwner_">
    <keyword>SetOwner_</keyword>
    <fullCommand>SetOwner_(name,owner_info)</fullCommand>
    <parameters>(name,owner_info)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Open_">
    <keyword>Open_</keyword>
    <fullCommand>Open_(name,accessMode)</fullCommand>
    <parameters>(name,accessMode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Input_">
    <keyword>Input_</keyword>
    <fullCommand>Input_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Output_">
    <keyword>Output_</keyword>
    <fullCommand>Output_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Rename_">
    <keyword>Rename_</keyword>
    <fullCommand>Rename_(oldName,newName)</fullCommand>
    <parameters>(oldName,newName)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Lock_">
    <keyword>Lock_</keyword>
    <fullCommand>Lock_(name,type)</fullCommand>
    <parameters>(name,type)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Examine_">
    <keyword>Examine_</keyword>
    <fullCommand>Examine_(lock,fileInfoBlock)</fullCommand>
    <parameters>(lock,fileInfoBlock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExNext_">
    <keyword>ExNext_</keyword>
    <fullCommand>ExNext_(lock,fileInfoBlock)</fullCommand>
    <parameters>(lock,fileInfoBlock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Info_">
    <keyword>Info_</keyword>
    <fullCommand>Info_(lock,parameterBlock)</fullCommand>
    <parameters>(lock,parameterBlock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IoErr_">
    <keyword>IoErr_</keyword>
    <fullCommand>IoErr_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateProc_">
    <keyword>CreateProc_</keyword>
    <fullCommand>CreateProc_(name,pri,segList,stackSize)</fullCommand>
    <parameters>(name,pri,segList,stackSize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetComment_">
    <keyword>SetComment_</keyword>
    <fullCommand>SetComment_(name,comment)</fullCommand>
    <parameters>(name,comment)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetProtection_">
    <keyword>SetProtection_</keyword>
    <fullCommand>SetProtection_(name,protect)</fullCommand>
    <parameters>(name,protect)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WaitForChar_">
    <keyword>WaitForChar_</keyword>
    <fullCommand>WaitForChar_(file,timeout)</fullCommand>
    <parameters>(file,timeout)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocDosObject_">
    <keyword>AllocDosObject_</keyword>
    <fullCommand>AllocDosObject_(type,tags)</fullCommand>
    <parameters>(type,tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeDosObject_">
    <keyword>FreeDosObject_</keyword>
    <fullCommand>FreeDosObject_(type,ptr)</fullCommand>
    <parameters>(type,ptr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WaitPkt_">
    <keyword>WaitPkt_</keyword>
    <fullCommand>WaitPkt_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AbortPkt_">
    <keyword>AbortPkt_</keyword>
    <fullCommand>AbortPkt_(port,pkt)</fullCommand>
    <parameters>(port,pkt)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LockRecords_">
    <keyword>LockRecords_</keyword>
    <fullCommand>LockRecords_(recArray,timeout)</fullCommand>
    <parameters>(recArray,timeout)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FPutC_">
    <keyword>FPutC_</keyword>
    <fullCommand>FPutC_(fh,ch)</fullCommand>
    <parameters>(fh,ch)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnGetC_">
    <keyword>UnGetC_</keyword>
    <fullCommand>UnGetC_(fh,character)</fullCommand>
    <parameters>(fh,character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FRead_">
    <keyword>FRead_</keyword>
    <fullCommand>FRead_(fh,block,blocklen,number)</fullCommand>
    <parameters>(fh,block,blocklen,number)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FWrite_">
    <keyword>FWrite_</keyword>
    <fullCommand>FWrite_(fh,block,blocklen,number)</fullCommand>
    <parameters>(fh,block,blocklen,number)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FPuts_">
    <keyword>FPuts_</keyword>
    <fullCommand>FPuts_(fh,str)</fullCommand>
    <parameters>(fh,str)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetVBuf_">
    <keyword>SetVBuf_</keyword>
    <fullCommand>SetVBuf_(fh,buff,type,size)</fullCommand>
    <parameters>(fh,buff,type,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExamineFH_">
    <keyword>ExamineFH_</keyword>
    <fullCommand>ExamineFH_(fh,fib)</fullCommand>
    <parameters>(fh,fib)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetFileDate_">
    <keyword>SetFileDate_</keyword>
    <fullCommand>SetFileDate_(name,date)</fullCommand>
    <parameters>(name,date)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SameLock_">
    <keyword>SameLock_</keyword>
    <fullCommand>SameLock_(lock1,lock2)</fullCommand>
    <parameters>(lock1,lock2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetMode_">
    <keyword>SetMode_</keyword>
    <fullCommand>SetMode_(fh,mode)</fullCommand>
    <parameters>(fh,mode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Fault_">
    <keyword>Fault_</keyword>
    <fullCommand>Fault_(code,header,buffer,len)</fullCommand>
    <parameters>(code,header,buffer,len)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PrintFault_">
    <keyword>PrintFault_</keyword>
    <fullCommand>PrintFault_(code,header)</fullCommand>
    <parameters>(code,header)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ErrorReport_">
    <keyword>ErrorReport_</keyword>
    <fullCommand>ErrorReport_(code,type,arg1,device)</fullCommand>
    <parameters>(code,type,arg1,device)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Cli_">
    <keyword>Cli_</keyword>
    <fullCommand>Cli_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RunCommand_">
    <keyword>RunCommand_</keyword>
    <fullCommand>RunCommand_(seg,stack,paramptr,paramlen)</fullCommand>
    <parameters>(seg,stack,paramptr,paramlen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetConsoleTask_">
    <keyword>GetConsoleTask_</keyword>
    <fullCommand>GetConsoleTask_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetFileSysTask_">
    <keyword>GetFileSysTask_</keyword>
    <fullCommand>GetFileSysTask_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetArgStr_">
    <keyword>GetArgStr_</keyword>
    <fullCommand>GetArgStr_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MaxCli_">
    <keyword>MaxCli_</keyword>
    <fullCommand>MaxCli_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetCurrentDirName_">
    <keyword>GetCurrentDirName_</keyword>
    <fullCommand>GetCurrentDirName_(buf,len)</fullCommand>
    <parameters>(buf,len)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetProgramName_">
    <keyword>GetProgramName_</keyword>
    <fullCommand>GetProgramName_(buf,len)</fullCommand>
    <parameters>(buf,len)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPrompt_">
    <keyword>GetPrompt_</keyword>
    <fullCommand>GetPrompt_(buf,len)</fullCommand>
    <parameters>(buf,len)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetProgramDir_">
    <keyword>GetProgramDir_</keyword>
    <fullCommand>GetProgramDir_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SystemTagList_">
    <keyword>SystemTagList_</keyword>
    <fullCommand>SystemTagList_(command,tags)</fullCommand>
    <parameters>(command,tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AssignLock_">
    <keyword>AssignLock_</keyword>
    <fullCommand>AssignLock_(name,lock)</fullCommand>
    <parameters>(name,lock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AssignLate_">
    <keyword>AssignLate_</keyword>
    <fullCommand>AssignLate_(name,path)</fullCommand>
    <parameters>(name,path)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AssignPath_">
    <keyword>AssignPath_</keyword>
    <fullCommand>AssignPath_(name,path)</fullCommand>
    <parameters>(name,path)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AssignAdd_">
    <keyword>AssignAdd_</keyword>
    <fullCommand>AssignAdd_(name,lock)</fullCommand>
    <parameters>(name,lock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemAssignList_">
    <keyword>RemAssignList_</keyword>
    <fullCommand>RemAssignList_(name,lock)</fullCommand>
    <parameters>(name,lock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDeviceProc_">
    <keyword>GetDeviceProc_</keyword>
    <fullCommand>GetDeviceProc_(name,dp)</fullCommand>
    <parameters>(name,dp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NextDosEntry_">
    <keyword>NextDosEntry_</keyword>
    <fullCommand>NextDosEntry_(dlist,flags)</fullCommand>
    <parameters>(dlist,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MakeDosEntry_">
    <keyword>MakeDosEntry_</keyword>
    <fullCommand>MakeDosEntry_(name,type)</fullCommand>
    <parameters>(name,type)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Relabel_">
    <keyword>Relabel_</keyword>
    <fullCommand>Relabel_(drive,newname)</fullCommand>
    <parameters>(drive,newname)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Inhibit_">
    <keyword>Inhibit_</keyword>
    <fullCommand>Inhibit_(name,onoff)</fullCommand>
    <parameters>(name,onoff)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddBuffers_">
    <keyword>AddBuffers_</keyword>
    <fullCommand>AddBuffers_(name,number)</fullCommand>
    <parameters>(name,number)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CompareDates_">
    <keyword>CompareDates_</keyword>
    <fullCommand>CompareDates_(date1,date2)</fullCommand>
    <parameters>(date1,date2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InternalLoadSeg_">
    <keyword>InternalLoadSeg_</keyword>
    <fullCommand>InternalLoadSeg_(fh,table,funcarray,stack)</fullCommand>
    <parameters>(fh,table,funcarray,stack)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InternalUnLoadSeg_">
    <keyword>InternalUnLoadSeg_</keyword>
    <fullCommand>InternalUnLoadSeg_(seglist,freefunc)</fullCommand>
    <parameters>(seglist,freefunc)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NewLoadSeg_">
    <keyword>NewLoadSeg_</keyword>
    <fullCommand>NewLoadSeg_(file,tags)</fullCommand>
    <parameters>(file,tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindArg_">
    <keyword>FindArg_</keyword>
    <fullCommand>FindArg_(keyword,template)</fullCommand>
    <parameters>(keyword,template)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NewFontContents_">
    <keyword>NewFontContents_</keyword>
    <fullCommand>NewFontContents_(fontsLock,fontName)</fullCommand>
    <parameters>(fontsLock,fontName)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NewScaledDiskFont_">
    <keyword>NewScaledDiskFont_</keyword>
    <fullCommand>NewScaledDiskFont_(sourceFont,destTextAttr)</fullCommand>
    <parameters>(sourceFont,destTextAttr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GiveUnit_">
    <keyword>GiveUnit_</keyword>
    <fullCommand>GiveUnit_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RLDispatch_">
    <keyword>RLDispatch_</keyword>
    <fullCommand>RLDispatch_(rmsg,result)</fullCommand>
    <parameters>(rmsg,result)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NewDTObjectA_">
    <keyword>NewDTObjectA_</keyword>
    <fullCommand>NewDTObjectA_(name,attrs)</fullCommand>
    <parameters>(name,attrs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetDTAttrsA_">
    <keyword>SetDTAttrsA_</keyword>
    <fullCommand>SetDTAttrsA_(o,win,req,attrs)</fullCommand>
    <parameters>(o,win,req,attrs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDTAttrsA_">
    <keyword>GetDTAttrsA_</keyword>
    <fullCommand>GetDTAttrsA_(o,attrs)</fullCommand>
    <parameters>(o,attrs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddDTObject_">
    <keyword>AddDTObject_</keyword>
    <fullCommand>AddDTObject_(win,req,o,pos)</fullCommand>
    <parameters>(win,req,o,pos)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RefreshDTObjectA_">
    <keyword>RefreshDTObjectA_</keyword>
    <fullCommand>RefreshDTObjectA_(o,win,req,attrs)</fullCommand>
    <parameters>(o,win,req,attrs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DoAsyncLayout_">
    <keyword>DoAsyncLayout_</keyword>
    <fullCommand>DoAsyncLayout_(o,gpl)</fullCommand>
    <parameters>(o,gpl)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DoDTMethodA_">
    <keyword>DoDTMethodA_</keyword>
    <fullCommand>DoDTMethodA_(o,win,req,msg)</fullCommand>
    <parameters>(o,win,req,msg)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemoveDTObject_">
    <keyword>RemoveDTObject_</keyword>
    <fullCommand>RemoveDTObject_(win,o)</fullCommand>
    <parameters>(win,o)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PrintDTObjectA_">
    <keyword>PrintDTObjectA_</keyword>
    <fullCommand>PrintDTObjectA_(o,w,r,msg)</fullCommand>
    <parameters>(o,w,r,msg)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxBroker_">
    <keyword>CxBroker_</keyword>
    <fullCommand>CxBroker_(nb,error)</fullCommand>
    <parameters>(nb,error)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ActivateCxObj_">
    <keyword>ActivateCxObj_</keyword>
    <fullCommand>ActivateCxObj_(co,true)</fullCommand>
    <parameters>(co,true)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetCxObjPri_">
    <keyword>SetCxObjPri_</keyword>
    <fullCommand>SetCxObjPri_(co,pri)</fullCommand>
    <parameters>(co,pri)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AttachCxObj_">
    <keyword>AttachCxObj_</keyword>
    <fullCommand>AttachCxObj_(headObj,co)</fullCommand>
    <parameters>(headObj,co)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EnqueueCxObj_">
    <keyword>EnqueueCxObj_</keyword>
    <fullCommand>EnqueueCxObj_(headObj,co)</fullCommand>
    <parameters>(headObj,co)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetTranslate_">
    <keyword>SetTranslate_</keyword>
    <fullCommand>SetTranslate_(translator,events)</fullCommand>
    <parameters>(translator,events)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetFilter_">
    <keyword>SetFilter_</keyword>
    <fullCommand>SetFilter_(filter,text)</fullCommand>
    <parameters>(filter,text)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetFilterIX_">
    <keyword>SetFilterIX_</keyword>
    <fullCommand>SetFilterIX_(filter,ix)</fullCommand>
    <parameters>(filter,ix)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ParseIX_">
    <keyword>ParseIX_</keyword>
    <fullCommand>ParseIX_(description,ix)</fullCommand>
    <parameters>(description,ix)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RouteCxMsg_">
    <keyword>RouteCxMsg_</keyword>
    <fullCommand>RouteCxMsg_(cxm,co)</fullCommand>
    <parameters>(cxm,co)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MatchIX_">
    <keyword>MatchIX_</keyword>
    <fullCommand>MatchIX_(event,ix)</fullCommand>
    <parameters>(event,ix)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ConvertHSBToRGB_">
    <keyword>ConvertHSBToRGB_</keyword>
    <fullCommand>ConvertHSBToRGB_(hsb,rgb)</fullCommand>
    <parameters>(hsb,rgb)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ConvertRGBToHSB_">
    <keyword>ConvertRGBToHSB_</keyword>
    <fullCommand>ConvertRGBToHSB_(rgb,hsb)</fullCommand>
    <parameters>(rgb,hsb)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AbleICR_b">
    <keyword>AbleICR_b</keyword>
    <fullCommand>AbleICR_b(resource,mask)</fullCommand>
    <parameters>(resource,mask)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetICR_b">
    <keyword>SetICR_b</keyword>
    <fullCommand>SetICR_b(resource,mask)</fullCommand>
    <parameters>(resource,mask)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AbleICR_a">
    <keyword>AbleICR_a</keyword>
    <fullCommand>AbleICR_a(resource,mask)</fullCommand>
    <parameters>(resource,mask)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetICR_a">
    <keyword>SetICR_a</keyword>
    <fullCommand>SetICR_a(resource,mask)</fullCommand>
    <parameters>(resource,mask)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReleaseCard_">
    <keyword>ReleaseCard_</keyword>
    <fullCommand>ReleaseCard_(handle,flags)</fullCommand>
    <parameters>(handle,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetCardMap_">
    <keyword>GetCardMap_</keyword>
    <fullCommand>GetCardMap_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadCardStatus_">
    <keyword>ReadCardStatus_</keyword>
    <fullCommand>ReadCardStatus_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CardResetRemove_">
    <keyword>CardResetRemove_</keyword>
    <fullCommand>CardResetRemove_(handle,flag)</fullCommand>
    <parameters>(handle,flag)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CardMiscControl_">
    <keyword>CardMiscControl_</keyword>
    <fullCommand>CardMiscControl_(handle,control_bits)</fullCommand>
    <parameters>(handle,control_bits)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CardAccessSpeed_">
    <keyword>CardAccessSpeed_</keyword>
    <fullCommand>CardAccessSpeed_(handle,nanoseconds)</fullCommand>
    <parameters>(handle,nanoseconds)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CardProgramVoltage_">
    <keyword>CardProgramVoltage_</keyword>
    <fullCommand>CardProgramVoltage_(handle,voltage)</fullCommand>
    <parameters>(handle,voltage)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopyTuple_">
    <keyword>CopyTuple_</keyword>
    <fullCommand>CopyTuple_(handle,buffer,tuplecode,size)</fullCommand>
    <parameters>(handle,buffer,tuplecode,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeviceTuple_">
    <keyword>DeviceTuple_</keyword>
    <fullCommand>DeviceTuple_(tuple_data,storage)</fullCommand>
    <parameters>(tuple_data,storage)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CardForceChange_">
    <keyword>CardForceChange_</keyword>
    <fullCommand>CardForceChange_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CardChangeCount_">
    <keyword>CardChangeCount_</keyword>
    <fullCommand>CardChangeCount_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CardInterface_">
    <keyword>CardInterface_</keyword>
    <fullCommand>CardInterface_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenEngine_">
    <keyword>OpenEngine_</keyword>
    <fullCommand>OpenEngine_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetInfoA_">
    <keyword>SetInfoA_</keyword>
    <fullCommand>SetInfoA_(glyphEngine,tagList)</fullCommand>
    <parameters>(glyphEngine,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ObtainInfoA_">
    <keyword>ObtainInfoA_</keyword>
    <fullCommand>ObtainInfoA_(glyphEngine,tagList)</fullCommand>
    <parameters>(glyphEngine,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReleaseInfoA_">
    <keyword>ReleaseInfoA_</keyword>
    <fullCommand>ReleaseInfoA_(glyphEngine,tagList)</fullCommand>
    <parameters>(glyphEngine,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ObtainBattSemaphore_">
    <keyword>ObtainBattSemaphore_</keyword>
    <fullCommand>ObtainBattSemaphore_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReleaseBattSemaphore_">
    <keyword>ReleaseBattSemaphore_</keyword>
    <fullCommand>ReleaseBattSemaphore_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ResetBattClock_">
    <keyword>ResetBattClock_</keyword>
    <fullCommand>ResetBattClock_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadBattClock_">
    <keyword>ReadBattClock_</keyword>
    <fullCommand>ReadBattClock_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocFileRequest_">
    <keyword>AllocFileRequest_</keyword>
    <fullCommand>AllocFileRequest_</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocAslRequest_">
    <keyword>AllocAslRequest_</keyword>
    <fullCommand>AllocAslRequest_(reqType,tagList)</fullCommand>
    <parameters>(reqType,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AslRequest_">
    <keyword>AslRequest_</keyword>
    <fullCommand>AslRequest_(requester,tagList)</fullCommand>
    <parameters>(requester,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AGARexxHost_">
    <keyword>AGARexxHost_</keyword>
    <fullCommand>AGARexxHost_(rmsg,result)</fullCommand>
    <parameters>(rmsg,result)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenAmigaGuideA_">
    <keyword>OpenAmigaGuideA_</keyword>
    <fullCommand>OpenAmigaGuideA_(nag,*)</fullCommand>
    <parameters>(nag,*)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenAmigaGuideAsyncA_">
    <keyword>OpenAmigaGuideAsyncA_</keyword>
    <fullCommand>OpenAmigaGuideAsyncA_(nag,attrs)</fullCommand>
    <parameters>(nag,attrs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SendAmigaGuideContextA_">
    <keyword>SendAmigaGuideContextA_</keyword>
    <fullCommand>SendAmigaGuideContextA_(cl,attrs)</fullCommand>
    <parameters>(cl,attrs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetAmigaGuideAttrsA_">
    <keyword>SetAmigaGuideAttrsA_</keyword>
    <fullCommand>SetAmigaGuideAttrsA_(cl,attrs)</fullCommand>
    <parameters>(cl,attrs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemoveAmigaGuideHostA_">
    <keyword>RemoveAmigaGuideHostA_</keyword>
    <fullCommand>RemoveAmigaGuideHostA_(hh,attrs)</fullCommand>
    <parameters>(hh,attrs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TEDGetLabelList_">
    <keyword>TEDGetLabelList_</keyword>
    <fullCommand>TEDGetLabelList_()-42</fullCommand>
    <parameters>()-42</parameters>
    <shortDescription>()-42.</shortDescription>
    <longDescription />
  </command>
  <command name="TEDGetLabelCount_">
    <keyword>TEDGetLabelCount_</keyword>
    <fullCommand>TEDGetLabelCount_()-48</fullCommand>
    <parameters>()-48</parameters>
    <shortDescription>()-48.</shortDescription>
    <longDescription />
  </command>
  <command name="TEDSetJumpTable_">
    <keyword>TEDSetJumpTable_</keyword>
    <fullCommand>TEDSetJumpTable_()-54</fullCommand>
    <parameters>()-54</parameters>
    <shortDescription>()-54.</shortDescription>
    <longDescription />
  </command>
  <command name="TEDGetJumpTable_">
    <keyword>TEDGetJumpTable_</keyword>
    <fullCommand>TEDGetJumpTable_()-60</fullCommand>
    <parameters>()-60</parameters>
    <shortDescription>()-60.</shortDescription>
    <longDescription />
  </command>
  <command name="TEDGetFirstLine_">
    <keyword>TEDGetFirstLine_</keyword>
    <fullCommand>TEDGetFirstLine_()-84</fullCommand>
    <parameters>()-84</parameters>
    <shortDescription>()-84.</shortDescription>
    <longDescription />
  </command>
  <command name="TEDGetCurrentLine_">
    <keyword>TEDGetCurrentLine_</keyword>
    <fullCommand>TEDGetCurrentLine_()-90</fullCommand>
    <parameters>()-90</parameters>
    <shortDescription>()-90.</shortDescription>
    <longDescription />
  </command>
  <command name="TEDGetFilename_">
    <keyword>TEDGetFilename_</keyword>
    <fullCommand>TEDGetFilename_()-102</fullCommand>
    <parameters>()-102</parameters>
    <shortDescription>()-102.</shortDescription>
    <longDescription />
  </command>
  <command name="XProtocolCleanup_">
    <keyword>XProtocolCleanup_</keyword>
    <fullCommand>XProtocolCleanup_(io)</fullCommand>
    <parameters>(io)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XProtocolSetup_">
    <keyword>XProtocolSetup_</keyword>
    <fullCommand>XProtocolSetup_(io)</fullCommand>
    <parameters>(io)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XProtocolSend_">
    <keyword>XProtocolSend_</keyword>
    <fullCommand>XProtocolSend_(io)</fullCommand>
    <parameters>(io)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="XProtocolReceive_">
    <keyword>XProtocolReceive_</keyword>
    <fullCommand>XProtocolReceive_(io)</fullCommand>
    <parameters>(io)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddAppWindowA_">
    <keyword>AddAppWindowA_</keyword>
    <fullCommand>AddAppWindowA_(id,userdata,window,msgport,taglist)</fullCommand>
    <parameters>(id,userdata,window,msgport,taglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemoveAppWindow_">
    <keyword>RemoveAppWindow_</keyword>
    <fullCommand>RemoveAppWindow_(appWindow)</fullCommand>
    <parameters>(appWindow)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddAppIconA_">
    <keyword>AddAppIconA_</keyword>
    <fullCommand>AddAppIconA_(id,userdata,text,msgport,lock,diskobj,taglist)</fullCommand>
    <parameters>(id,userdata,text,msgport,lock,diskobj,taglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemoveAppIcon_">
    <keyword>RemoveAppIcon_</keyword>
    <fullCommand>RemoveAppIcon_(appIcon)</fullCommand>
    <parameters>(appIcon)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddAppMenuItemA_">
    <keyword>AddAppMenuItemA_</keyword>
    <fullCommand>AddAppMenuItemA_(id,userdata,text,msgport,taglist)</fullCommand>
    <parameters>(id,userdata,text,msgport,taglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemoveAppMenuItem_">
    <keyword>RemoveAppMenuItem_</keyword>
    <fullCommand>RemoveAppMenuItem_(appMenuItem)</fullCommand>
    <parameters>(appMenuItem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WBInfo_">
    <keyword>WBInfo_</keyword>
    <fullCommand>WBInfo_(lock,name,screen)</fullCommand>
    <parameters>(lock,name,screen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetTagData_">
    <keyword>GetTagData_</keyword>
    <fullCommand>GetTagData_(tagValue,defaultVal,tagList)</fullCommand>
    <parameters>(tagValue,defaultVal,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PackBoolTags_">
    <keyword>PackBoolTags_</keyword>
    <fullCommand>PackBoolTags_(initialFlags,tagList,boolMap)</fullCommand>
    <parameters>(initialFlags,tagList,boolMap)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NextTagItem_">
    <keyword>NextTagItem_</keyword>
    <fullCommand>NextTagItem_(tagListPtr)</fullCommand>
    <parameters>(tagListPtr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FilterTagChanges_">
    <keyword>FilterTagChanges_</keyword>
    <fullCommand>FilterTagChanges_(changeList,originalList,apply)</fullCommand>
    <parameters>(changeList,originalList,apply)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MapTags_">
    <keyword>MapTags_</keyword>
    <fullCommand>MapTags_(tagList,mapList,mapType)</fullCommand>
    <parameters>(tagList,mapList,mapType)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocateTagItems_">
    <keyword>AllocateTagItems_</keyword>
    <fullCommand>AllocateTagItems_(numTags)</fullCommand>
    <parameters>(numTags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloneTagItems_">
    <keyword>CloneTagItems_</keyword>
    <fullCommand>CloneTagItems_(tagList)</fullCommand>
    <parameters>(tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeTagItems_">
    <keyword>FreeTagItems_</keyword>
    <fullCommand>FreeTagItems_(tagList)</fullCommand>
    <parameters>(tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FilterTagItems_">
    <keyword>FilterTagItems_</keyword>
    <fullCommand>FilterTagItems_(tagList,filterArray,logic)</fullCommand>
    <parameters>(tagList,filterArray,logic)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CallHookPkt_">
    <keyword>CallHookPkt_</keyword>
    <fullCommand>CallHookPkt_(hook,object,paramPacket)</fullCommand>
    <parameters>(hook,object,paramPacket)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Date2Amiga_">
    <keyword>Date2Amiga_</keyword>
    <fullCommand>Date2Amiga_(date)</fullCommand>
    <parameters>(date)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CheckDate_">
    <keyword>CheckDate_</keyword>
    <fullCommand>CheckDate_(date)</fullCommand>
    <parameters>(date)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Strnicmp_">
    <keyword>Strnicmp_</keyword>
    <fullCommand>Strnicmp_(string1,string2,length)</fullCommand>
    <parameters>(string1,string2,length)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ToUpper_">
    <keyword>ToUpper_</keyword>
    <fullCommand>ToUpper_(character)</fullCommand>
    <parameters>(character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ToLower_">
    <keyword>ToLower_</keyword>
    <fullCommand>ToLower_(character)</fullCommand>
    <parameters>(character)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PackStructureTags_">
    <keyword>PackStructureTags_</keyword>
    <fullCommand>PackStructureTags_(pack,packtable,tagList)</fullCommand>
    <parameters>(pack,packtable,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnpackStructureTags_">
    <keyword>UnpackStructureTags_</keyword>
    <fullCommand>UnpackStructureTags_(pack,packtable,tagList)</fullCommand>
    <parameters>(pack,packtable,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AttemptRemNamedObject_">
    <keyword>AttemptRemNamedObject_</keyword>
    <fullCommand>AttemptRemNamedObject_(object)</fullCommand>
    <parameters>(object)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindNamedObject_">
    <keyword>FindNamedObject_</keyword>
    <fullCommand>FindNamedObject_(namespace,name,lastobject)</fullCommand>
    <parameters>(namespace,name,lastobject)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeNamedObject_">
    <keyword>FreeNamedObject_</keyword>
    <fullCommand>FreeNamedObject_(object)</fullCommand>
    <parameters>(object)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NamedObjectName_">
    <keyword>NamedObjectName_</keyword>
    <fullCommand>NamedObjectName_(object)</fullCommand>
    <parameters>(object)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReleaseNamedObject_">
    <keyword>ReleaseNamedObject_</keyword>
    <fullCommand>ReleaseNamedObject_(object)</fullCommand>
    <parameters>(object)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeleteArgstring_">
    <keyword>DeleteArgstring_</keyword>
    <fullCommand>DeleteArgstring_(argstring)</fullCommand>
    <parameters>(argstring)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LengthArgstring_">
    <keyword>LengthArgstring_</keyword>
    <fullCommand>LengthArgstring_(argstring)</fullCommand>
    <parameters>(argstring)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateRexxMsg_">
    <keyword>CreateRexxMsg_</keyword>
    <fullCommand>CreateRexxMsg_(port,extension,host)</fullCommand>
    <parameters>(port,extension,host)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeleteRexxMsg_">
    <keyword>DeleteRexxMsg_</keyword>
    <fullCommand>DeleteRexxMsg_(packet)</fullCommand>
    <parameters>(packet)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FillRexxMsg_">
    <keyword>FillRexxMsg_</keyword>
    <fullCommand>FillRexxMsg_(msgptr,count,mask)</fullCommand>
    <parameters>(msgptr,count,mask)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsRexxMsg_">
    <keyword>IsRexxMsg_</keyword>
    <fullCommand>IsRexxMsg_(msgptr)</fullCommand>
    <parameters>(msgptr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LockRexxBase_">
    <keyword>LockRexxBase_</keyword>
    <fullCommand>LockRexxBase_(resource)</fullCommand>
    <parameters>(resource)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnlockRexxBase_">
    <keyword>UnlockRexxBase_</keyword>
    <fullCommand>UnlockRexxBase_(resource)</fullCommand>
    <parameters>(resource)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocPotBits_">
    <keyword>AllocPotBits_</keyword>
    <fullCommand>AllocPotBits_(bits)</fullCommand>
    <parameters>(bits)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreePotBits_">
    <keyword>FreePotBits_</keyword>
    <fullCommand>FreePotBits_(bits)</fullCommand>
    <parameters>(bits)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeMiscResource_">
    <keyword>FreeMiscResource_</keyword>
    <fullCommand>FreeMiscResource_(unitNum)</fullCommand>
    <parameters>(unitNum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPAtan_">
    <keyword>SPAtan_</keyword>
    <fullCommand>SPAtan_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPSin_">
    <keyword>SPSin_</keyword>
    <fullCommand>SPSin_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPCos_">
    <keyword>SPCos_</keyword>
    <fullCommand>SPCos_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPTan_">
    <keyword>SPTan_</keyword>
    <fullCommand>SPTan_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPSinh_">
    <keyword>SPSinh_</keyword>
    <fullCommand>SPSinh_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPCosh_">
    <keyword>SPCosh_</keyword>
    <fullCommand>SPCosh_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPTanh_">
    <keyword>SPTanh_</keyword>
    <fullCommand>SPTanh_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPExp_">
    <keyword>SPExp_</keyword>
    <fullCommand>SPExp_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPLog_">
    <keyword>SPLog_</keyword>
    <fullCommand>SPLog_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPSqrt_">
    <keyword>SPSqrt_</keyword>
    <fullCommand>SPSqrt_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPTieee_">
    <keyword>SPTieee_</keyword>
    <fullCommand>SPTieee_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPFieee_">
    <keyword>SPFieee_</keyword>
    <fullCommand>SPFieee_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPAsin_">
    <keyword>SPAsin_</keyword>
    <fullCommand>SPAsin_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPAcos_">
    <keyword>SPAcos_</keyword>
    <fullCommand>SPAcos_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPLog10_">
    <keyword>SPLog10_</keyword>
    <fullCommand>SPLog10_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPAtan_">
    <keyword>IEEESPAtan_</keyword>
    <fullCommand>IEEESPAtan_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPSin_">
    <keyword>IEEESPSin_</keyword>
    <fullCommand>IEEESPSin_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPCos_">
    <keyword>IEEESPCos_</keyword>
    <fullCommand>IEEESPCos_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPTan_">
    <keyword>IEEESPTan_</keyword>
    <fullCommand>IEEESPTan_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPSinh_">
    <keyword>IEEESPSinh_</keyword>
    <fullCommand>IEEESPSinh_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPCosh_">
    <keyword>IEEESPCosh_</keyword>
    <fullCommand>IEEESPCosh_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPTanh_">
    <keyword>IEEESPTanh_</keyword>
    <fullCommand>IEEESPTanh_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPExp_">
    <keyword>IEEESPExp_</keyword>
    <fullCommand>IEEESPExp_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPLog_">
    <keyword>IEEESPLog_</keyword>
    <fullCommand>IEEESPLog_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPSqrt_">
    <keyword>IEEESPSqrt_</keyword>
    <fullCommand>IEEESPSqrt_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPTieee_">
    <keyword>IEEESPTieee_</keyword>
    <fullCommand>IEEESPTieee_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPFieee_">
    <keyword>IEEESPFieee_</keyword>
    <fullCommand>IEEESPFieee_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPAsin_">
    <keyword>IEEESPAsin_</keyword>
    <fullCommand>IEEESPAsin_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPAcos_">
    <keyword>IEEESPAcos_</keyword>
    <fullCommand>IEEESPAcos_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPLog10_">
    <keyword>IEEESPLog10_</keyword>
    <fullCommand>IEEESPLog10_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPFix_">
    <keyword>IEEESPFix_</keyword>
    <fullCommand>IEEESPFix_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPFlt_">
    <keyword>IEEESPFlt_</keyword>
    <fullCommand>IEEESPFlt_(integer)</fullCommand>
    <parameters>(integer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPTst_">
    <keyword>IEEESPTst_</keyword>
    <fullCommand>IEEESPTst_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPAbs_">
    <keyword>IEEESPAbs_</keyword>
    <fullCommand>IEEESPAbs_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPNeg_">
    <keyword>IEEESPNeg_</keyword>
    <fullCommand>IEEESPNeg_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPFloor_">
    <keyword>IEEESPFloor_</keyword>
    <fullCommand>IEEESPFloor_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEESPCeil_">
    <keyword>IEEESPCeil_</keyword>
    <fullCommand>IEEESPCeil_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPSincos_">
    <keyword>IEEEDPSincos_</keyword>
    <fullCommand>IEEEDPSincos_(pf2,parm)</fullCommand>
    <parameters>(pf2,parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPFieee_">
    <keyword>IEEEDPFieee_</keyword>
    <fullCommand>IEEEDPFieee_(single)</fullCommand>
    <parameters>(single)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IEEEDPFlt_">
    <keyword>IEEEDPFlt_</keyword>
    <fullCommand>IEEEDPFlt_(integer)</fullCommand>
    <parameters>(integer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPFix_">
    <keyword>SPFix_</keyword>
    <fullCommand>SPFix_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPFlt_">
    <keyword>SPFlt_</keyword>
    <fullCommand>SPFlt_(integer)</fullCommand>
    <parameters>(integer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPTst_">
    <keyword>SPTst_</keyword>
    <fullCommand>SPTst_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPAbs_">
    <keyword>SPAbs_</keyword>
    <fullCommand>SPAbs_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPNeg_">
    <keyword>SPNeg_</keyword>
    <fullCommand>SPNeg_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPFloor_">
    <keyword>SPFloor_</keyword>
    <fullCommand>SPFloor_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SPCeil_">
    <keyword>SPCeil_</keyword>
    <fullCommand>SPCeil_(parm)</fullCommand>
    <parameters>(parm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseCatalog_">
    <keyword>CloseCatalog_</keyword>
    <fullCommand>CloseCatalog_(catalog)</fullCommand>
    <parameters>(catalog)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseLocale_">
    <keyword>CloseLocale_</keyword>
    <fullCommand>CloseLocale_(locale)</fullCommand>
    <parameters>(locale)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetCatalogStr_">
    <keyword>GetCatalogStr_</keyword>
    <fullCommand>GetCatalogStr_(catalog,stringNum,defaultString)</fullCommand>
    <parameters>(catalog,stringNum,defaultString)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenCatalogA_">
    <keyword>OpenCatalogA_</keyword>
    <fullCommand>OpenCatalogA_(locale,name,tags)</fullCommand>
    <parameters>(locale,name,tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenLocale_">
    <keyword>OpenLocale_</keyword>
    <fullCommand>OpenLocale_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrConvert_">
    <keyword>StrConvert_</keyword>
    <fullCommand>StrConvert_(locale,string,buffer,bufferSize,type)</fullCommand>
    <parameters>(locale,string,buffer,bufferSize,type)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrnCmp_">
    <keyword>StrnCmp_</keyword>
    <fullCommand>StrnCmp_(locale,string1,string2,length,type)</fullCommand>
    <parameters>(locale,string1,string2,length,type)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitLayers_">
    <keyword>InitLayers_</keyword>
    <fullCommand>InitLayers_(li)</fullCommand>
    <parameters>(li)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BeginUpdate_">
    <keyword>BeginUpdate_</keyword>
    <fullCommand>BeginUpdate_(l)</fullCommand>
    <parameters>(l)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnlockLayer_">
    <keyword>UnlockLayer_</keyword>
    <fullCommand>UnlockLayer_(layer)</fullCommand>
    <parameters>(layer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LockLayers_">
    <keyword>LockLayers_</keyword>
    <fullCommand>LockLayers_(li)</fullCommand>
    <parameters>(li)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnlockLayers_">
    <keyword>UnlockLayers_</keyword>
    <fullCommand>UnlockLayers_(li)</fullCommand>
    <parameters>(li)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LockLayerInfo_">
    <keyword>LockLayerInfo_</keyword>
    <fullCommand>LockLayerInfo_(li)</fullCommand>
    <parameters>(li)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WhichLayer_">
    <keyword>WhichLayer_</keyword>
    <fullCommand>WhichLayer_(li,x,y)</fullCommand>
    <parameters>(li,x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnlockLayerInfo_">
    <keyword>UnlockLayerInfo_</keyword>
    <fullCommand>UnlockLayerInfo_(li)</fullCommand>
    <parameters>(li)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DisposeLayerInfo_">
    <keyword>DisposeLayerInfo_</keyword>
    <fullCommand>DisposeLayerInfo_(li)</fullCommand>
    <parameters>(li)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FattenLayerInfo_">
    <keyword>FattenLayerInfo_</keyword>
    <fullCommand>FattenLayerInfo_(li)</fullCommand>
    <parameters>(li)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ThinLayerInfo_">
    <keyword>ThinLayerInfo_</keyword>
    <fullCommand>ThinLayerInfo_(li)</fullCommand>
    <parameters>(li)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MoveSizeLayer_">
    <keyword>MoveSizeLayer_</keyword>
    <fullCommand>MoveSizeLayer_(layer,dx,dy,dw,dh)</fullCommand>
    <parameters>(layer,dx,dy,dw,dh)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateUpfrontHookLayer_">
    <keyword>CreateUpfrontHookLayer_</keyword>
    <fullCommand>CreateUpfrontHookLayer_(li,bm,x0,y0,x1,y1,flags,hook,bm2)</fullCommand>
    <parameters>(li,bm,x0,y0,x1,y1,flags,hook,bm2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateBehindHookLayer_">
    <keyword>CreateBehindHookLayer_</keyword>
    <fullCommand>CreateBehindHookLayer_(li,bm,x0,y0,x1,y1,flags,hook,bm2)</fullCommand>
    <parameters>(li,bm,x0,y0,x1,y1,flags,hook,bm2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SortLayerCR_">
    <keyword>SortLayerCR_</keyword>
    <fullCommand>SortLayerCR_(layer,dx,dy)</fullCommand>
    <parameters>(layer,dx,dy)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DoHookClipRects_">
    <keyword>DoHookClipRects_</keyword>
    <fullCommand>DoHookClipRects_(hook,rport,rect)</fullCommand>
    <parameters>(hook,rport,rect)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetKeyMapDefault_">
    <keyword>SetKeyMapDefault_</keyword>
    <fullCommand>SetKeyMapDefault_(keyMap)</fullCommand>
    <parameters>(keyMap)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MapANSI_">
    <keyword>MapANSI_</keyword>
    <fullCommand>MapANSI_(string,count,buffer,length,keyMap)</fullCommand>
    <parameters>(string,count,buffer,length,keyMap)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Intuition_">
    <keyword>Intuition_</keyword>
    <fullCommand>Intuition_(iEvent)</fullCommand>
    <parameters>(iEvent)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddGadget_">
    <keyword>AddGadget_</keyword>
    <fullCommand>AddGadget_(window,gadget,position)</fullCommand>
    <parameters>(window,gadget,position)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClearDMRequest_">
    <keyword>ClearDMRequest_</keyword>
    <fullCommand>ClearDMRequest_(window)</fullCommand>
    <parameters>(window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClearMenuStrip_">
    <keyword>ClearMenuStrip_</keyword>
    <fullCommand>ClearMenuStrip_(window)</fullCommand>
    <parameters>(window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClearPointer_">
    <keyword>ClearPointer_</keyword>
    <fullCommand>ClearPointer_(window)</fullCommand>
    <parameters>(window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseScreen_">
    <keyword>CloseScreen_</keyword>
    <fullCommand>CloseScreen_(screen)</fullCommand>
    <parameters>(screen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseWindow_">
    <keyword>CloseWindow_</keyword>
    <fullCommand>CloseWindow_(window)</fullCommand>
    <parameters>(window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DisplayAlert_">
    <keyword>DisplayAlert_</keyword>
    <fullCommand>DisplayAlert_(alertNumber,string,height)</fullCommand>
    <parameters>(alertNumber,string,height)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DisplayBeep_">
    <keyword>DisplayBeep_</keyword>
    <fullCommand>DisplayBeep_(screen)</fullCommand>
    <parameters>(screen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitRequester_">
    <keyword>InitRequester_</keyword>
    <fullCommand>InitRequester_(requester)</fullCommand>
    <parameters>(requester)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MoveScreen_">
    <keyword>MoveScreen_</keyword>
    <fullCommand>MoveScreen_(screen,dx,dy)</fullCommand>
    <parameters>(screen,dx,dy)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MoveWindow_">
    <keyword>MoveWindow_</keyword>
    <fullCommand>MoveWindow_(window,dx,dy)</fullCommand>
    <parameters>(window,dx,dy)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OffGadget_">
    <keyword>OffGadget_</keyword>
    <fullCommand>OffGadget_(gadget,window,requester)</fullCommand>
    <parameters>(gadget,window,requester)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OnGadget_">
    <keyword>OnGadget_</keyword>
    <fullCommand>OnGadget_(gadget,window,requester)</fullCommand>
    <parameters>(gadget,window,requester)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenScreen_">
    <keyword>OpenScreen_</keyword>
    <fullCommand>OpenScreen_(newScreen)</fullCommand>
    <parameters>(newScreen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenWindow_">
    <keyword>OpenWindow_</keyword>
    <fullCommand>OpenWindow_(newWindow)</fullCommand>
    <parameters>(newWindow)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RefreshGadgets_">
    <keyword>RefreshGadgets_</keyword>
    <fullCommand>RefreshGadgets_(gadgets,window,requester)</fullCommand>
    <parameters>(gadgets,window,requester)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ScreenToBack_">
    <keyword>ScreenToBack_</keyword>
    <fullCommand>ScreenToBack_(screen)</fullCommand>
    <parameters>(screen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ScreenToFront_">
    <keyword>ScreenToFront_</keyword>
    <fullCommand>ScreenToFront_(screen)</fullCommand>
    <parameters>(screen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetWindowTitles_">
    <keyword>SetWindowTitles_</keyword>
    <fullCommand>SetWindowTitles_(window,windowTitle,screenTitle)</fullCommand>
    <parameters>(window,windowTitle,screenTitle)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SizeWindow_">
    <keyword>SizeWindow_</keyword>
    <fullCommand>SizeWindow_(window,dx,dy)</fullCommand>
    <parameters>(window,dx,dy)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ViewPortAddress_">
    <keyword>ViewPortAddress_</keyword>
    <fullCommand>ViewPortAddress_(window)</fullCommand>
    <parameters>(window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WindowToBack_">
    <keyword>WindowToBack_</keyword>
    <fullCommand>WindowToBack_(window)</fullCommand>
    <parameters>(window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WindowToFront_">
    <keyword>WindowToFront_</keyword>
    <fullCommand>WindowToFront_(window)</fullCommand>
    <parameters>(window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WindowLimits_">
    <keyword>WindowLimits_</keyword>
    <fullCommand>WindowLimits_(window,widthMin,heightMin,widthMax,heightMax)</fullCommand>
    <parameters>(window,widthMin,heightMin,widthMax,heightMax)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPrefs_">
    <keyword>SetPrefs_</keyword>
    <fullCommand>SetPrefs_(preferences,size,inform)</fullCommand>
    <parameters>(preferences,size,inform)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IntuiTextLength_">
    <keyword>IntuiTextLength_</keyword>
    <fullCommand>IntuiTextLength_(iText)</fullCommand>
    <parameters>(iText)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BeginRefresh_">
    <keyword>BeginRefresh_</keyword>
    <fullCommand>BeginRefresh_(window)</fullCommand>
    <parameters>(window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BuildSysRequest_">
    <keyword>BuildSysRequest_</keyword>
    <fullCommand>BuildSysRequest_(window,body,posText,negText,flags,width,height)</fullCommand>
    <parameters>(window,body,posText,negText,flags,width,height)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeSysRequest_">
    <keyword>FreeSysRequest_</keyword>
    <fullCommand>FreeSysRequest_(window)</fullCommand>
    <parameters>(window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MakeScreen_">
    <keyword>MakeScreen_</keyword>
    <fullCommand>MakeScreen_(screen)</fullCommand>
    <parameters>(screen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocRemember_">
    <keyword>AllocRemember_</keyword>
    <fullCommand>AllocRemember_(rememberKey,size,flags)</fullCommand>
    <parameters>(rememberKey,size,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AlohaWorkbench_">
    <keyword>AlohaWorkbench_</keyword>
    <fullCommand>AlohaWorkbench_(wbport)</fullCommand>
    <parameters>(wbport)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LockIBase_">
    <keyword>LockIBase_</keyword>
    <fullCommand>LockIBase_(dontknow)</fullCommand>
    <parameters>(dontknow)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnlockIBase_">
    <keyword>UnlockIBase_</keyword>
    <fullCommand>UnlockIBase_(ibLock)</fullCommand>
    <parameters>(ibLock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddGList_">
    <keyword>AddGList_</keyword>
    <fullCommand>AddGList_(window,gadget,position,numGad,requester)</fullCommand>
    <parameters>(window,gadget,position,numGad,requester)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemoveGList_">
    <keyword>RemoveGList_</keyword>
    <fullCommand>RemoveGList_(remPtr,gadget,numGad)</fullCommand>
    <parameters>(remPtr,gadget,numGad)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ActivateWindow_">
    <keyword>ActivateWindow_</keyword>
    <fullCommand>ActivateWindow_(window)</fullCommand>
    <parameters>(window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RefreshWindowFrame_">
    <keyword>RefreshWindowFrame_</keyword>
    <fullCommand>RefreshWindowFrame_(window)</fullCommand>
    <parameters>(window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ActivateGadget_">
    <keyword>ActivateGadget_</keyword>
    <fullCommand>ActivateGadget_(gadgets,window,requester)</fullCommand>
    <parameters>(gadgets,window,requester)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NewModifyProp_">
    <keyword>NewModifyProp_</keyword>
    <fullCommand>NewModifyProp_(gadget,window,requester,flags,horizPot,vertPot,horizBody,vertBody,numGad)</fullCommand>
    <parameters>(gadget,window,requester,flags,horizPot,vertPot,horizBody,vertBody,numGad)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="QueryOverscan_">
    <keyword>QueryOverscan_</keyword>
    <fullCommand>QueryOverscan_(displayID,rect,oScanType)</fullCommand>
    <parameters>(displayID,rect,oScanType)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChangeWindowBox_">
    <keyword>ChangeWindowBox_</keyword>
    <fullCommand>ChangeWindowBox_(window,left,top,width,height)</fullCommand>
    <parameters>(window,left,top,width,height)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetEditHook_">
    <keyword>SetEditHook_</keyword>
    <fullCommand>SetEditHook_(hook)</fullCommand>
    <parameters>(hook)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ZipWindow_">
    <keyword>ZipWindow_</keyword>
    <fullCommand>ZipWindow_(window)</fullCommand>
    <parameters>(window)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LockPubScreen_">
    <keyword>LockPubScreen_</keyword>
    <fullCommand>LockPubScreen_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetDefaultPubScreen_">
    <keyword>SetDefaultPubScreen_</keyword>
    <fullCommand>SetDefaultPubScreen_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPubScreenModes_">
    <keyword>SetPubScreenModes_</keyword>
    <fullCommand>SetPubScreenModes_(modes)</fullCommand>
    <parameters>(modes)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ObtainGIRPort_">
    <keyword>ObtainGIRPort_</keyword>
    <fullCommand>ObtainGIRPort_(gInfo)</fullCommand>
    <parameters>(gInfo)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReleaseGIRPort_">
    <keyword>ReleaseGIRPort_</keyword>
    <fullCommand>ReleaseGIRPort_(rp)</fullCommand>
    <parameters>(rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GadgetMouse_">
    <keyword>GadgetMouse_</keyword>
    <fullCommand>GadgetMouse_(gadget,gInfo,mousePoint)</fullCommand>
    <parameters>(gadget,gInfo,mousePoint)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDefaultPubScreen_">
    <keyword>GetDefaultPubScreen_</keyword>
    <fullCommand>GetDefaultPubScreen_(nameBuffer)</fullCommand>
    <parameters>(nameBuffer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SysReqHandler_">
    <keyword>SysReqHandler_</keyword>
    <fullCommand>SysReqHandler_(window,idcmpPtr,waitInput)</fullCommand>
    <parameters>(window,idcmpPtr,waitInput)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NewObjectA_">
    <keyword>NewObjectA_</keyword>
    <fullCommand>NewObjectA_(classPtr,classID,tagList)</fullCommand>
    <parameters>(classPtr,classID,tagList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DisposeObject_">
    <keyword>DisposeObject_</keyword>
    <fullCommand>DisposeObject_(object)</fullCommand>
    <parameters>(object)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetAttr_">
    <keyword>GetAttr_</keyword>
    <fullCommand>GetAttr_(attrID,object,storagePtr)</fullCommand>
    <parameters>(attrID,object,storagePtr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NextObject_">
    <keyword>NextObject_</keyword>
    <fullCommand>NextObject_(objectPtrPtr)</fullCommand>
    <parameters>(objectPtrPtr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MakeClass_">
    <keyword>MakeClass_</keyword>
    <fullCommand>MakeClass_(classID,superClassID,superClassPtr,instanceSize,flags)</fullCommand>
    <parameters>(classID,superClassID,superClassPtr,instanceSize,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddClass_">
    <keyword>AddClass_</keyword>
    <fullCommand>AddClass_(classPtr)</fullCommand>
    <parameters>(classPtr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetScreenDrawInfo_">
    <keyword>GetScreenDrawInfo_</keyword>
    <fullCommand>GetScreenDrawInfo_(screen)</fullCommand>
    <parameters>(screen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemoveClass_">
    <keyword>RemoveClass_</keyword>
    <fullCommand>RemoveClass_(classPtr)</fullCommand>
    <parameters>(classPtr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeClass_">
    <keyword>FreeClass_</keyword>
    <fullCommand>FreeClass_(classPtr)</fullCommand>
    <parameters>(classPtr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocScreenBuffer_">
    <keyword>AllocScreenBuffer_</keyword>
    <fullCommand>AllocScreenBuffer_(sc,bm,flags)</fullCommand>
    <parameters>(sc,bm,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ScreenDepth_">
    <keyword>ScreenDepth_</keyword>
    <fullCommand>ScreenDepth_(screen,flags,reserved)</fullCommand>
    <parameters>(screen,flags,reserved)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ScrollWindowRaster_">
    <keyword>ScrollWindowRaster_</keyword>
    <fullCommand>ScrollWindowRaster_(win,dx,dy,xMin,yMin,xMax,yMax)</fullCommand>
    <parameters>(win,dx,dy,xMin,yMin,xMax,yMax)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseIFF_">
    <keyword>CloseIFF_</keyword>
    <fullCommand>CloseIFF_(iff)</fullCommand>
    <parameters>(iff)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeIFF_">
    <keyword>FreeIFF_</keyword>
    <fullCommand>FreeIFF_(iff)</fullCommand>
    <parameters>(iff)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadChunkBytes_">
    <keyword>ReadChunkBytes_</keyword>
    <fullCommand>ReadChunkBytes_(iff,buf,numBytes)</fullCommand>
    <parameters>(iff,buf,numBytes)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WriteChunkBytes_">
    <keyword>WriteChunkBytes_</keyword>
    <fullCommand>WriteChunkBytes_(iff,buf,numBytes)</fullCommand>
    <parameters>(iff,buf,numBytes)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PopChunk_">
    <keyword>PopChunk_</keyword>
    <fullCommand>PopChunk_(iff)</fullCommand>
    <parameters>(iff)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PropChunk_">
    <keyword>PropChunk_</keyword>
    <fullCommand>PropChunk_(iff,type,id)</fullCommand>
    <parameters>(iff,type,id)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PropChunks_">
    <keyword>PropChunks_</keyword>
    <fullCommand>PropChunks_(iff,propArray,numPairs)</fullCommand>
    <parameters>(iff,propArray,numPairs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StopChunk_">
    <keyword>StopChunk_</keyword>
    <fullCommand>StopChunk_(iff,type,id)</fullCommand>
    <parameters>(iff,type,id)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StopChunks_">
    <keyword>StopChunks_</keyword>
    <fullCommand>StopChunks_(iff,propArray,numPairs)</fullCommand>
    <parameters>(iff,propArray,numPairs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CollectionChunk_">
    <keyword>CollectionChunk_</keyword>
    <fullCommand>CollectionChunk_(iff,type,id)</fullCommand>
    <parameters>(iff,type,id)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CollectionChunks_">
    <keyword>CollectionChunks_</keyword>
    <fullCommand>CollectionChunks_(iff,propArray,numPairs)</fullCommand>
    <parameters>(iff,propArray,numPairs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StopOnExit_">
    <keyword>StopOnExit_</keyword>
    <fullCommand>StopOnExit_(iff,type,id)</fullCommand>
    <parameters>(iff,type,id)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindProp_">
    <keyword>FindProp_</keyword>
    <fullCommand>FindProp_(iff,type,id)</fullCommand>
    <parameters>(iff,type,id)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindCollection_">
    <keyword>FindCollection_</keyword>
    <fullCommand>FindCollection_(iff,type,id)</fullCommand>
    <parameters>(iff,type,id)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindPropContext_">
    <keyword>FindPropContext_</keyword>
    <fullCommand>FindPropContext_(iff)</fullCommand>
    <parameters>(iff)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CurrentChunk_">
    <keyword>CurrentChunk_</keyword>
    <fullCommand>CurrentChunk_(iff)</fullCommand>
    <parameters>(iff)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ParentChunk_">
    <keyword>ParentChunk_</keyword>
    <fullCommand>ParentChunk_(contextNode)</fullCommand>
    <parameters>(contextNode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LocalItemData_">
    <keyword>LocalItemData_</keyword>
    <fullCommand>LocalItemData_(localItem)</fullCommand>
    <parameters>(localItem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeLocalItem_">
    <keyword>FreeLocalItem_</keyword>
    <fullCommand>FreeLocalItem_(localItem)</fullCommand>
    <parameters>(localItem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StoreLocalItem_">
    <keyword>StoreLocalItem_</keyword>
    <fullCommand>StoreLocalItem_(iff,localItem,position)</fullCommand>
    <parameters>(iff,localItem,position)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StoreItemInContext_">
    <keyword>StoreItemInContext_</keyword>
    <fullCommand>StoreItemInContext_(iff,localItem,contextNode)</fullCommand>
    <parameters>(iff,localItem,contextNode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitIFF_">
    <keyword>InitIFF_</keyword>
    <fullCommand>InitIFF_(iff,flags,streamHook)</fullCommand>
    <parameters>(iff,flags,streamHook)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitIFFasDOS_">
    <keyword>InitIFFasDOS_</keyword>
    <fullCommand>InitIFFasDOS_(iff)</fullCommand>
    <parameters>(iff)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitIFFasClip_">
    <keyword>InitIFFasClip_</keyword>
    <fullCommand>InitIFFasClip_(iff)</fullCommand>
    <parameters>(iff)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenClipboard_">
    <keyword>OpenClipboard_</keyword>
    <fullCommand>OpenClipboard_(unitNumber)</fullCommand>
    <parameters>(unitNumber)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseClipboard_">
    <keyword>CloseClipboard_</keyword>
    <fullCommand>CloseClipboard_(clipHandle)</fullCommand>
    <parameters>(clipHandle)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GoodID_">
    <keyword>GoodID_</keyword>
    <fullCommand>GoodID_(id)</fullCommand>
    <parameters>(id)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GoodType_">
    <keyword>GoodType_</keyword>
    <fullCommand>GoodType_(type)</fullCommand>
    <parameters>(type)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetIcon_">
    <keyword>GetIcon_</keyword>
    <fullCommand>GetIcon_(name,icon,freelist)</fullCommand>
    <parameters>(name,icon,freelist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeFreeList_">
    <keyword>FreeFreeList_</keyword>
    <fullCommand>FreeFreeList_(freelist)</fullCommand>
    <parameters>(freelist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddFreeList_">
    <keyword>AddFreeList_</keyword>
    <fullCommand>AddFreeList_(freelist,mem,size)</fullCommand>
    <parameters>(freelist,mem,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDiskObject_">
    <keyword>GetDiskObject_</keyword>
    <fullCommand>GetDiskObject_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeDiskObject_">
    <keyword>FreeDiskObject_</keyword>
    <fullCommand>FreeDiskObject_(diskobj)</fullCommand>
    <parameters>(diskobj)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDefDiskObject_">
    <keyword>GetDefDiskObject_</keyword>
    <fullCommand>GetDefDiskObject_(type)</fullCommand>
    <parameters>(type)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PutDefDiskObject_">
    <keyword>PutDefDiskObject_</keyword>
    <fullCommand>PutDefDiskObject_(diskObject)</fullCommand>
    <parameters>(diskObject)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDiskObjectNew_">
    <keyword>GetDiskObjectNew_</keyword>
    <fullCommand>GetDiskObjectNew_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeleteDiskObject_">
    <keyword>DeleteDiskObject_</keyword>
    <fullCommand>DeleteDiskObject_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EraseRect_">
    <keyword>EraseRect_</keyword>
    <fullCommand>EraseRect_(rp,xMin,yMin,xMax,yMax)</fullCommand>
    <parameters>(rp,xMin,yMin,xMax,yMax)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StripFont_">
    <keyword>StripFont_</keyword>
    <fullCommand>StripFont_(font)</fullCommand>
    <parameters>(font)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ObtainBestPenA_">
    <keyword>ObtainBestPenA_</keyword>
    <fullCommand>ObtainBestPenA_(cm,r,g,b,tags)</fullCommand>
    <parameters>(cm,r,g,b,tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetRGB32_">
    <keyword>SetRGB32_</keyword>
    <fullCommand>SetRGB32_(vp,n,r,g,b)</fullCommand>
    <parameters>(vp,n,r,g,b)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetAPen_">
    <keyword>GetAPen_</keyword>
    <fullCommand>GetAPen_(rp)</fullCommand>
    <parameters>(rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetBPen_">
    <keyword>GetBPen_</keyword>
    <fullCommand>GetBPen_(rp)</fullCommand>
    <parameters>(rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDrMd_">
    <keyword>GetDrMd_</keyword>
    <fullCommand>GetDrMd_(rp)</fullCommand>
    <parameters>(rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetOutlinePen_">
    <keyword>GetOutlinePen_</keyword>
    <fullCommand>GetOutlinePen_(rp)</fullCommand>
    <parameters>(rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetChipRev_">
    <keyword>SetChipRev_</keyword>
    <fullCommand>SetChipRev_(want)</fullCommand>
    <parameters>(want)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocBitMap_">
    <keyword>AllocBitMap_</keyword>
    <fullCommand>AllocBitMap_(sizex,sizey,depth,flags,friend_bitmap)</fullCommand>
    <parameters>(sizex,sizey,depth,flags,friend_bitmap)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeBitMap_">
    <keyword>FreeBitMap_</keyword>
    <fullCommand>FreeBitMap_(bm)</fullCommand>
    <parameters>(bm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CoerceMode_">
    <keyword>CoerceMode_</keyword>
    <fullCommand>CoerceMode_(vp,monitorid,flags)</fullCommand>
    <parameters>(vp,monitorid,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChangeVPBitMap_">
    <keyword>ChangeVPBitMap_</keyword>
    <fullCommand>ChangeVPBitMap_(vp,bm,db)</fullCommand>
    <parameters>(vp,bm,db)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocDBufInfo_">
    <keyword>AllocDBufInfo_</keyword>
    <fullCommand>AllocDBufInfo_(vp)</fullCommand>
    <parameters>(vp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeDBufInfo_">
    <keyword>FreeDBufInfo_</keyword>
    <fullCommand>FreeDBufInfo_(dbi)</fullCommand>
    <parameters>(dbi)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetRGB32CM_">
    <keyword>SetRGB32CM_</keyword>
    <fullCommand>SetRGB32CM_(cm,n,r,g,b)</fullCommand>
    <parameters>(cm,n,r,g,b)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ScrollRasterBF_">
    <keyword>ScrollRasterBF_</keyword>
    <fullCommand>ScrollRasterBF_(rp,dx,dy,xMin,yMin,xMax,yMax)</fullCommand>
    <parameters>(rp,dx,dy,xMin,yMin,xMax,yMax)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindColor_">
    <keyword>FindColor_</keyword>
    <fullCommand>FindColor_(cm,r,g,b,maxcolor)</fullCommand>
    <parameters>(cm,r,g,b,maxcolor)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeSpriteData_">
    <keyword>FreeSpriteData_</keyword>
    <fullCommand>FreeSpriteData_(sp)</fullCommand>
    <parameters>(sp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BestModeIDA_">
    <keyword>BestModeIDA_</keyword>
    <fullCommand>BestModeIDA_(tags)</fullCommand>
    <parameters>(tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BltBitMap_">
    <keyword>BltBitMap_</keyword>
    <fullCommand>BltBitMap_(srcBitMap,xSrc,ySrc,destBitMap,xDest,yDest,xSize,ySize,minterm,mask,tempA)</fullCommand>
    <parameters>(srcBitMap,xSrc,ySrc,destBitMap,xDest,yDest,xSize,ySize,minterm,mask,tempA)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClearEOL_">
    <keyword>ClearEOL_</keyword>
    <fullCommand>ClearEOL_(rp)</fullCommand>
    <parameters>(rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClearScreen_">
    <keyword>ClearScreen_</keyword>
    <fullCommand>ClearScreen_(rp)</fullCommand>
    <parameters>(rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TextLength_">
    <keyword>TextLength_</keyword>
    <fullCommand>TextLength_(rp,string,count)</fullCommand>
    <parameters>(rp,string,count)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Text_">
    <keyword>Text_</keyword>
    <fullCommand>Text_(rp,string,count)</fullCommand>
    <parameters>(rp,string,count)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenFont_">
    <keyword>OpenFont_</keyword>
    <fullCommand>OpenFont_(textAttr)</fullCommand>
    <parameters>(textAttr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseFont_">
    <keyword>CloseFont_</keyword>
    <fullCommand>CloseFont_(textFont)</fullCommand>
    <parameters>(textFont)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AskSoftStyle_">
    <keyword>AskSoftStyle_</keyword>
    <fullCommand>AskSoftStyle_(rp)</fullCommand>
    <parameters>(rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetSoftStyle_">
    <keyword>SetSoftStyle_</keyword>
    <fullCommand>SetSoftStyle_(rp,style,enable)</fullCommand>
    <parameters>(rp,style,enable)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DoCollision_">
    <keyword>DoCollision_</keyword>
    <fullCommand>DoCollision_(rp)</fullCommand>
    <parameters>(rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitGels_">
    <keyword>InitGels_</keyword>
    <fullCommand>InitGels_(head,tail,gelsInfo)</fullCommand>
    <parameters>(head,tail,gelsInfo)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitMasks_">
    <keyword>InitMasks_</keyword>
    <fullCommand>InitMasks_(vSprite)</fullCommand>
    <parameters>(vSprite)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemIBob_">
    <keyword>RemIBob_</keyword>
    <fullCommand>RemIBob_(bob,rp,vp)</fullCommand>
    <parameters>(bob,rp,vp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemVSprite_">
    <keyword>RemVSprite_</keyword>
    <fullCommand>RemVSprite_(vSprite)</fullCommand>
    <parameters>(vSprite)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetCollision_">
    <keyword>SetCollision_</keyword>
    <fullCommand>SetCollision_(num,routine,gelsInfo)</fullCommand>
    <parameters>(num,routine,gelsInfo)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SortGList_">
    <keyword>SortGList_</keyword>
    <fullCommand>SortGList_(rp)</fullCommand>
    <parameters>(rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddAnimOb_">
    <keyword>AddAnimOb_</keyword>
    <fullCommand>AddAnimOb_(anOb,anKey,rp)</fullCommand>
    <parameters>(anOb,anKey,rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetGBuffers_">
    <keyword>GetGBuffers_</keyword>
    <fullCommand>GetGBuffers_(anOb,rp,flag)</fullCommand>
    <parameters>(anOb,rp,flag)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitGMasks_">
    <keyword>InitGMasks_</keyword>
    <fullCommand>InitGMasks_(anOb)</fullCommand>
    <parameters>(anOb)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DrawEllipse_">
    <keyword>DrawEllipse_</keyword>
    <fullCommand>DrawEllipse_(rp,xCenter,yCenter,a,b)</fullCommand>
    <parameters>(rp,xCenter,yCenter,a,b)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AreaEllipse_">
    <keyword>AreaEllipse_</keyword>
    <fullCommand>AreaEllipse_(rp,xCenter,yCenter,a,b)</fullCommand>
    <parameters>(rp,xCenter,yCenter,a,b)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LoadRGB4_">
    <keyword>LoadRGB4_</keyword>
    <fullCommand>LoadRGB4_(vp,colors,count)</fullCommand>
    <parameters>(vp,colors,count)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitRastPort_">
    <keyword>InitRastPort_</keyword>
    <fullCommand>InitRastPort_(rp)</fullCommand>
    <parameters>(rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitVPort_">
    <keyword>InitVPort_</keyword>
    <fullCommand>InitVPort_(vp)</fullCommand>
    <parameters>(vp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MrgCop_">
    <keyword>MrgCop_</keyword>
    <fullCommand>MrgCop_(view)</fullCommand>
    <parameters>(view)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LoadView_">
    <keyword>LoadView_</keyword>
    <fullCommand>LoadView_(view)</fullCommand>
    <parameters>(view)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Move_">
    <keyword>Move_</keyword>
    <fullCommand>Move_(rp,x,y)</fullCommand>
    <parameters>(rp,x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Draw_">
    <keyword>Draw_</keyword>
    <fullCommand>Draw_(rp,x,y)</fullCommand>
    <parameters>(rp,x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AreaMove_">
    <keyword>AreaMove_</keyword>
    <fullCommand>AreaMove_(rp,x,y)</fullCommand>
    <parameters>(rp,x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AreaDraw_">
    <keyword>AreaDraw_</keyword>
    <fullCommand>AreaDraw_(rp,x,y)</fullCommand>
    <parameters>(rp,x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AreaEnd_">
    <keyword>AreaEnd_</keyword>
    <fullCommand>AreaEnd_(rp)</fullCommand>
    <parameters>(rp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="QBlit_">
    <keyword>QBlit_</keyword>
    <fullCommand>QBlit_(blit)</fullCommand>
    <parameters>(blit)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitArea_">
    <keyword>InitArea_</keyword>
    <fullCommand>InitArea_(areaInfo,vectorBuffer,maxVectors)</fullCommand>
    <parameters>(areaInfo,vectorBuffer,maxVectors)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetRGB4_">
    <keyword>SetRGB4_</keyword>
    <fullCommand>SetRGB4_(vp,index,red,green,blue)</fullCommand>
    <parameters>(vp,index,red,green,blue)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="QBSBlit_">
    <keyword>QBSBlit_</keyword>
    <fullCommand>QBSBlit_(blit)</fullCommand>
    <parameters>(blit)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BltClear_">
    <keyword>BltClear_</keyword>
    <fullCommand>BltClear_(memBlock,byteCount,flags)</fullCommand>
    <parameters>(memBlock,byteCount,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RectFill_">
    <keyword>RectFill_</keyword>
    <fullCommand>RectFill_(rp,xMin,yMin,xMax,yMax)</fullCommand>
    <parameters>(rp,xMin,yMin,xMax,yMax)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BltPattern_">
    <keyword>BltPattern_</keyword>
    <fullCommand>BltPattern_(rp,mask,xMin,yMin,xMax,yMax,maskBPR)</fullCommand>
    <parameters>(rp,mask,xMin,yMin,xMax,yMax,maskBPR)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadPixel_">
    <keyword>ReadPixel_</keyword>
    <fullCommand>ReadPixel_(rp,x,y)</fullCommand>
    <parameters>(rp,x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WritePixel_">
    <keyword>WritePixel_</keyword>
    <fullCommand>WritePixel_(rp,x,y)</fullCommand>
    <parameters>(rp,x,y)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PolyDraw_">
    <keyword>PolyDraw_</keyword>
    <fullCommand>PolyDraw_(rp,count,polyTable)</fullCommand>
    <parameters>(rp,count,polyTable)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitView_">
    <keyword>InitView_</keyword>
    <fullCommand>InitView_(view)</fullCommand>
    <parameters>(view)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CBump_">
    <keyword>CBump_</keyword>
    <fullCommand>CBump_(copList)</fullCommand>
    <parameters>(copList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CMove_">
    <keyword>CMove_</keyword>
    <fullCommand>CMove_(copList,destination,data)</fullCommand>
    <parameters>(copList,destination,data)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CWait_">
    <keyword>CWait_</keyword>
    <fullCommand>CWait_(copList,v,h)</fullCommand>
    <parameters>(copList,v,h)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ScrollRaster_">
    <keyword>ScrollRaster_</keyword>
    <fullCommand>ScrollRaster_(rp,dx,dy,xMin,yMin,xMax,yMax)</fullCommand>
    <parameters>(rp,dx,dy,xMin,yMin,xMax,yMax)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WaitBOVP_">
    <keyword>WaitBOVP_</keyword>
    <fullCommand>WaitBOVP_(vp)</fullCommand>
    <parameters>(vp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeSprite_">
    <keyword>FreeSprite_</keyword>
    <fullCommand>FreeSprite_(num)</fullCommand>
    <parameters>(num)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChangeSprite_">
    <keyword>ChangeSprite_</keyword>
    <fullCommand>ChangeSprite_(vp,sprite,newData)</fullCommand>
    <parameters>(vp,sprite,newData)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LockLayerRom_">
    <keyword>LockLayerRom_</keyword>
    <fullCommand>LockLayerRom_(layer)</fullCommand>
    <parameters>(layer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnlockLayerRom_">
    <keyword>UnlockLayerRom_</keyword>
    <fullCommand>UnlockLayerRom_(layer)</fullCommand>
    <parameters>(layer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SyncSBitMap_">
    <keyword>SyncSBitMap_</keyword>
    <fullCommand>SyncSBitMap_(layer)</fullCommand>
    <parameters>(layer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopySBitMap_">
    <keyword>CopySBitMap_</keyword>
    <fullCommand>CopySBitMap_(layer)</fullCommand>
    <parameters>(layer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitTmpRas_">
    <keyword>InitTmpRas_</keyword>
    <fullCommand>InitTmpRas_(tmpRas,buffer,size)</fullCommand>
    <parameters>(tmpRas,buffer,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddFont_">
    <keyword>AddFont_</keyword>
    <fullCommand>AddFont_(textFont)</fullCommand>
    <parameters>(textFont)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemFont_">
    <keyword>RemFont_</keyword>
    <fullCommand>RemFont_(textFont)</fullCommand>
    <parameters>(textFont)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeRaster_">
    <keyword>FreeRaster_</keyword>
    <fullCommand>FreeRaster_(p,width,height)</fullCommand>
    <parameters>(p,width,height)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClearRegion_">
    <keyword>ClearRegion_</keyword>
    <fullCommand>ClearRegion_(region)</fullCommand>
    <parameters>(region)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DisposeRegion_">
    <keyword>DisposeRegion_</keyword>
    <fullCommand>DisposeRegion_(region)</fullCommand>
    <parameters>(region)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeVPortCopLists_">
    <keyword>FreeVPortCopLists_</keyword>
    <fullCommand>FreeVPortCopLists_(vp)</fullCommand>
    <parameters>(vp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeCopList_">
    <keyword>FreeCopList_</keyword>
    <fullCommand>FreeCopList_(copList)</fullCommand>
    <parameters>(copList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClipBlit_">
    <keyword>ClipBlit_</keyword>
    <fullCommand>ClipBlit_(srcRP,xSrc,ySrc,destRP,xDest,yDest,xSize,ySize,minterm)</fullCommand>
    <parameters>(srcRP,xSrc,ySrc,destRP,xDest,yDest,xSize,ySize,minterm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeCprList_">
    <keyword>FreeCprList_</keyword>
    <fullCommand>FreeCprList_(cprList)</fullCommand>
    <parameters>(cprList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetColorMap_">
    <keyword>GetColorMap_</keyword>
    <fullCommand>GetColorMap_(entries)</fullCommand>
    <parameters>(entries)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeColorMap_">
    <keyword>FreeColorMap_</keyword>
    <fullCommand>FreeColorMap_(colorMap)</fullCommand>
    <parameters>(colorMap)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ScrollVPort_">
    <keyword>ScrollVPort_</keyword>
    <fullCommand>ScrollVPort_(vp)</fullCommand>
    <parameters>(vp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeGBuffers_">
    <keyword>FreeGBuffers_</keyword>
    <fullCommand>FreeGBuffers_(anOb,rp,flag)</fullCommand>
    <parameters>(anOb,rp,flag)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BltBitMapRastPort_">
    <keyword>BltBitMapRastPort_</keyword>
    <fullCommand>BltBitMapRastPort_(srcBitMap,xSrc,ySrc,destRP,xDest,yDest,xSize,ySize,minterm)</fullCommand>
    <parameters>(srcBitMap,xSrc,ySrc,destRP,xDest,yDest,xSize,ySize,minterm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetRGB4CM_">
    <keyword>SetRGB4CM_</keyword>
    <fullCommand>SetRGB4CM_(colorMap,index,red,green,blue)</fullCommand>
    <parameters>(colorMap,index,red,green,blue)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AttemptLockLayerRom_">
    <keyword>AttemptLockLayerRom_</keyword>
    <fullCommand>AttemptLockLayerRom_(layer)</fullCommand>
    <parameters>(layer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GfxNew_">
    <keyword>GfxNew_</keyword>
    <fullCommand>GfxNew_(gfxNodeType)</fullCommand>
    <parameters>(gfxNodeType)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GfxFree_">
    <keyword>GfxFree_</keyword>
    <fullCommand>GfxFree_(gfxNodePtr)</fullCommand>
    <parameters>(gfxNodePtr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BitMapScale_">
    <keyword>BitMapScale_</keyword>
    <fullCommand>BitMapScale_(bitScaleArgs)</fullCommand>
    <parameters>(bitScaleArgs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ScalerDiv_">
    <keyword>ScalerDiv_</keyword>
    <fullCommand>ScalerDiv_(factor,numerator,denominator)</fullCommand>
    <parameters>(factor,numerator,denominator)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GfxLookUp_">
    <keyword>GfxLookUp_</keyword>
    <fullCommand>GfxLookUp_(associateNode)</fullCommand>
    <parameters>(associateNode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseMonitor_">
    <keyword>CloseMonitor_</keyword>
    <fullCommand>CloseMonitor_(monitorSpec)</fullCommand>
    <parameters>(monitorSpec)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindDisplayInfo_">
    <keyword>FindDisplayInfo_</keyword>
    <fullCommand>FindDisplayInfo_(displayID)</fullCommand>
    <parameters>(displayID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NextDisplayInfo_">
    <keyword>NextDisplayInfo_</keyword>
    <fullCommand>NextDisplayInfo_(displayID)</fullCommand>
    <parameters>(displayID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDisplayInfoData_">
    <keyword>GetDisplayInfoData_</keyword>
    <fullCommand>GetDisplayInfoData_(handle,buf,size,tagID,displayID)</fullCommand>
    <parameters>(handle,buf,size,tagID,displayID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadPixelArray8_">
    <keyword>ReadPixelArray8_</keyword>
    <fullCommand>ReadPixelArray8_(rp,xstart,ystart,xstop,ystop,array,temprp)</fullCommand>
    <parameters>(rp,xstart,ystart,xstop,ystop,array,temprp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WritePixelArray8_">
    <keyword>WritePixelArray8_</keyword>
    <fullCommand>WritePixelArray8_(rp,xstart,ystart,xstop,ystop,array,temprp)</fullCommand>
    <parameters>(rp,xstart,ystart,xstop,ystop,array,temprp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetVPModeID_">
    <keyword>GetVPModeID_</keyword>
    <fullCommand>GetVPModeID_(vp)</fullCommand>
    <parameters>(vp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ModeNotAvailable_">
    <keyword>ModeNotAvailable_</keyword>
    <fullCommand>ModeNotAvailable_(modeID)</fullCommand>
    <parameters>(modeID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WeighTAMatch_">
    <keyword>WeighTAMatch_</keyword>
    <fullCommand>WeighTAMatch_(reqTextAttr,targetTextAttr,targetTags)</fullCommand>
    <parameters>(reqTextAttr,targetTextAttr,targetTags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeGadgets_">
    <keyword>FreeGadgets_</keyword>
    <fullCommand>FreeGadgets_(gad)</fullCommand>
    <parameters>(gad)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeMenus_">
    <keyword>FreeMenus_</keyword>
    <fullCommand>FreeMenus_(menu)</fullCommand>
    <parameters>(menu)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LayoutMenuItemsA_">
    <keyword>LayoutMenuItemsA_</keyword>
    <fullCommand>LayoutMenuItemsA_(firstitem,vi,taglist)</fullCommand>
    <parameters>(firstitem,vi,taglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LayoutMenusA_">
    <keyword>LayoutMenusA_</keyword>
    <fullCommand>LayoutMenusA_(firstmenu,vi,taglist)</fullCommand>
    <parameters>(firstmenu,vi,taglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GT_GetIMsg_">
    <keyword>GT_GetIMsg_</keyword>
    <fullCommand>GT_GetIMsg_(iport)</fullCommand>
    <parameters>(iport)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GT_ReplyIMsg_">
    <keyword>GT_ReplyIMsg_</keyword>
    <fullCommand>GT_ReplyIMsg_(imsg)</fullCommand>
    <parameters>(imsg)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GT_BeginRefresh_">
    <keyword>GT_BeginRefresh_</keyword>
    <fullCommand>GT_BeginRefresh_(win)</fullCommand>
    <parameters>(win)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GT_FilterIMsg_">
    <keyword>GT_FilterIMsg_</keyword>
    <fullCommand>GT_FilterIMsg_(imsg)</fullCommand>
    <parameters>(imsg)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GT_PostFilterIMsg_">
    <keyword>GT_PostFilterIMsg_</keyword>
    <fullCommand>GT_PostFilterIMsg_(imsg)</fullCommand>
    <parameters>(imsg)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateContext_">
    <keyword>CreateContext_</keyword>
    <fullCommand>CreateContext_(glistptr)</fullCommand>
    <parameters>(glistptr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeVisualInfo_">
    <keyword>FreeVisualInfo_</keyword>
    <fullCommand>FreeVisualInfo_(vi)</fullCommand>
    <parameters>(vi)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddConfigDev_">
    <keyword>AddConfigDev_</keyword>
    <fullCommand>AddConfigDev_(configDev)</fullCommand>
    <parameters>(configDev)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocBoardMem_">
    <keyword>AllocBoardMem_</keyword>
    <fullCommand>AllocBoardMem_(slotSpec)</fullCommand>
    <parameters>(slotSpec)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ConfigChain_">
    <keyword>ConfigChain_</keyword>
    <fullCommand>ConfigChain_(baseAddr)</fullCommand>
    <parameters>(baseAddr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindConfigDev_">
    <keyword>FindConfigDev_</keyword>
    <fullCommand>FindConfigDev_(oldConfigDev,manufacturer,product)</fullCommand>
    <parameters>(oldConfigDev,manufacturer,product)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeConfigDev_">
    <keyword>FreeConfigDev_</keyword>
    <fullCommand>FreeConfigDev_(configDev)</fullCommand>
    <parameters>(configDev)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemConfigDev_">
    <keyword>RemConfigDev_</keyword>
    <fullCommand>RemConfigDev_(configDev)</fullCommand>
    <parameters>(configDev)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WriteExpansionByte_">
    <keyword>WriteExpansionByte_</keyword>
    <fullCommand>WriteExpansionByte_(board,offset,byte)</fullCommand>
    <parameters>(board,offset,byte)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MakeDosNode_">
    <keyword>MakeDosNode_</keyword>
    <fullCommand>MakeDosNode_(parmPacket)</fullCommand>
    <parameters>(parmPacket)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddDosNode_">
    <keyword>AddDosNode_</keyword>
    <fullCommand>AddDosNode_(bootPri,flags,deviceNode)</fullCommand>
    <parameters>(bootPri,flags,deviceNode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Supervisor_">
    <keyword>Supervisor_</keyword>
    <fullCommand>Supervisor_(userFunction)</fullCommand>
    <parameters>(userFunction)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitStruct_">
    <keyword>InitStruct_</keyword>
    <fullCommand>InitStruct_(initTable,memory,size)</fullCommand>
    <parameters>(initTable,memory,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MakeLibrary_">
    <keyword>MakeLibrary_</keyword>
    <fullCommand>MakeLibrary_(funcInit,structInit,libInit,dataSize,segList)</fullCommand>
    <parameters>(funcInit,structInit,libInit,dataSize,segList)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MakeFunctions_">
    <keyword>MakeFunctions_</keyword>
    <fullCommand>MakeFunctions_(target,functionArray,funcDispBase)</fullCommand>
    <parameters>(target,functionArray,funcDispBase)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindResident_">
    <keyword>FindResident_</keyword>
    <fullCommand>FindResident_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Alert_">
    <keyword>Alert_</keyword>
    <fullCommand>Alert_(alertNum)</fullCommand>
    <parameters>(alertNum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Debug_">
    <keyword>Debug_</keyword>
    <fullCommand>Debug_(flags)</fullCommand>
    <parameters>(flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UserState_">
    <keyword>UserState_</keyword>
    <fullCommand>UserState_(sysStack)</fullCommand>
    <parameters>(sysStack)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Cause_">
    <keyword>Cause_</keyword>
    <fullCommand>Cause_(interrupt)</fullCommand>
    <parameters>(interrupt)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Deallocate_">
    <keyword>Deallocate_</keyword>
    <fullCommand>Deallocate_(freeList,memoryBlock,byteSize)</fullCommand>
    <parameters>(freeList,memoryBlock,byteSize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AvailMem_">
    <keyword>AvailMem_</keyword>
    <fullCommand>AvailMem_(requirements)</fullCommand>
    <parameters>(requirements)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocEntry_">
    <keyword>AllocEntry_</keyword>
    <fullCommand>AllocEntry_(entry)</fullCommand>
    <parameters>(entry)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeEntry_">
    <keyword>FreeEntry_</keyword>
    <fullCommand>FreeEntry_(entry)</fullCommand>
    <parameters>(entry)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Insert_">
    <keyword>Insert_</keyword>
    <fullCommand>Insert_(list,node,pred)</fullCommand>
    <parameters>(list,node,pred)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Remove_">
    <keyword>Remove_</keyword>
    <fullCommand>Remove_(node)</fullCommand>
    <parameters>(node)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemHead_">
    <keyword>RemHead_</keyword>
    <fullCommand>RemHead_(list)</fullCommand>
    <parameters>(list)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemTail_">
    <keyword>RemTail_</keyword>
    <fullCommand>RemTail_(list)</fullCommand>
    <parameters>(list)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddTask_">
    <keyword>AddTask_</keyword>
    <fullCommand>AddTask_(task,initPC,finalPC)</fullCommand>
    <parameters>(task,initPC,finalPC)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemTask_">
    <keyword>RemTask_</keyword>
    <fullCommand>RemTask_(task)</fullCommand>
    <parameters>(task)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindTask_">
    <keyword>FindTask_</keyword>
    <fullCommand>FindTask_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Wait_">
    <keyword>Wait_</keyword>
    <fullCommand>Wait_(signalSet)</fullCommand>
    <parameters>(signalSet)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocSignal_">
    <keyword>AllocSignal_</keyword>
    <fullCommand>AllocSignal_(signalNum)</fullCommand>
    <parameters>(signalNum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeSignal_">
    <keyword>FreeSignal_</keyword>
    <fullCommand>FreeSignal_(signalNum)</fullCommand>
    <parameters>(signalNum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocTrap_">
    <keyword>AllocTrap_</keyword>
    <fullCommand>AllocTrap_(trapNum)</fullCommand>
    <parameters>(trapNum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeTrap_">
    <keyword>FreeTrap_</keyword>
    <fullCommand>FreeTrap_(trapNum)</fullCommand>
    <parameters>(trapNum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddPort_">
    <keyword>AddPort_</keyword>
    <fullCommand>AddPort_(port)</fullCommand>
    <parameters>(port)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemPort_">
    <keyword>RemPort_</keyword>
    <fullCommand>RemPort_(port)</fullCommand>
    <parameters>(port)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetMsg_">
    <keyword>GetMsg_</keyword>
    <fullCommand>GetMsg_(port)</fullCommand>
    <parameters>(port)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReplyMsg_">
    <keyword>ReplyMsg_</keyword>
    <fullCommand>ReplyMsg_(message)</fullCommand>
    <parameters>(message)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WaitPort_">
    <keyword>WaitPort_</keyword>
    <fullCommand>WaitPort_(port)</fullCommand>
    <parameters>(port)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindPort_">
    <keyword>FindPort_</keyword>
    <fullCommand>FindPort_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddLibrary_">
    <keyword>AddLibrary_</keyword>
    <fullCommand>AddLibrary_(library)</fullCommand>
    <parameters>(library)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemLibrary_">
    <keyword>RemLibrary_</keyword>
    <fullCommand>RemLibrary_(library)</fullCommand>
    <parameters>(library)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OldOpenLibrary_">
    <keyword>OldOpenLibrary_</keyword>
    <fullCommand>OldOpenLibrary_(libName)</fullCommand>
    <parameters>(libName)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseLibrary_">
    <keyword>CloseLibrary_</keyword>
    <fullCommand>CloseLibrary_(library)</fullCommand>
    <parameters>(library)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetFunction_">
    <keyword>SetFunction_</keyword>
    <fullCommand>SetFunction_(library,funcOffset,newFunction)</fullCommand>
    <parameters>(library,funcOffset,newFunction)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SumLibrary_">
    <keyword>SumLibrary_</keyword>
    <fullCommand>SumLibrary_(library)</fullCommand>
    <parameters>(library)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddDevice_">
    <keyword>AddDevice_</keyword>
    <fullCommand>AddDevice_(device)</fullCommand>
    <parameters>(device)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemDevice_">
    <keyword>RemDevice_</keyword>
    <fullCommand>RemDevice_(device)</fullCommand>
    <parameters>(device)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseDevice_">
    <keyword>CloseDevice_</keyword>
    <fullCommand>CloseDevice_(ioRequest)</fullCommand>
    <parameters>(ioRequest)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DoIO_">
    <keyword>DoIO_</keyword>
    <fullCommand>DoIO_(ioRequest)</fullCommand>
    <parameters>(ioRequest)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SendIO_">
    <keyword>SendIO_</keyword>
    <fullCommand>SendIO_(ioRequest)</fullCommand>
    <parameters>(ioRequest)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CheckIO_">
    <keyword>CheckIO_</keyword>
    <fullCommand>CheckIO_(ioRequest)</fullCommand>
    <parameters>(ioRequest)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WaitIO_">
    <keyword>WaitIO_</keyword>
    <fullCommand>WaitIO_(ioRequest)</fullCommand>
    <parameters>(ioRequest)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AbortIO_">
    <keyword>AbortIO_</keyword>
    <fullCommand>AbortIO_(ioRequest)</fullCommand>
    <parameters>(ioRequest)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddResource_">
    <keyword>AddResource_</keyword>
    <fullCommand>AddResource_(resource)</fullCommand>
    <parameters>(resource)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemResource_">
    <keyword>RemResource_</keyword>
    <fullCommand>RemResource_(resource)</fullCommand>
    <parameters>(resource)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenResource_">
    <keyword>OpenResource_</keyword>
    <fullCommand>OpenResource_(resName)</fullCommand>
    <parameters>(resName)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TypeOfMem_">
    <keyword>TypeOfMem_</keyword>
    <fullCommand>TypeOfMem_(address)</fullCommand>
    <parameters>(address)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitSemaphore_">
    <keyword>InitSemaphore_</keyword>
    <fullCommand>InitSemaphore_(sigSem)</fullCommand>
    <parameters>(sigSem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ObtainSemaphore_">
    <keyword>ObtainSemaphore_</keyword>
    <fullCommand>ObtainSemaphore_(sigSem)</fullCommand>
    <parameters>(sigSem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReleaseSemaphore_">
    <keyword>ReleaseSemaphore_</keyword>
    <fullCommand>ReleaseSemaphore_(sigSem)</fullCommand>
    <parameters>(sigSem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AttemptSemaphore_">
    <keyword>AttemptSemaphore_</keyword>
    <fullCommand>AttemptSemaphore_(sigSem)</fullCommand>
    <parameters>(sigSem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ObtainSemaphoreList_">
    <keyword>ObtainSemaphoreList_</keyword>
    <fullCommand>ObtainSemaphoreList_(sigSem)</fullCommand>
    <parameters>(sigSem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReleaseSemaphoreList_">
    <keyword>ReleaseSemaphoreList_</keyword>
    <fullCommand>ReleaseSemaphoreList_(sigSem)</fullCommand>
    <parameters>(sigSem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindSemaphore_">
    <keyword>FindSemaphore_</keyword>
    <fullCommand>FindSemaphore_(sigSem)</fullCommand>
    <parameters>(sigSem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddSemaphore_">
    <keyword>AddSemaphore_</keyword>
    <fullCommand>AddSemaphore_(sigSem)</fullCommand>
    <parameters>(sigSem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemSemaphore_">
    <keyword>RemSemaphore_</keyword>
    <fullCommand>RemSemaphore_(sigSem)</fullCommand>
    <parameters>(sigSem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddMemList_">
    <keyword>AddMemList_</keyword>
    <fullCommand>AddMemList_(size,attributes,pri,base,name)</fullCommand>
    <parameters>(size,attributes,pri,base,name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopyMem_">
    <keyword>CopyMem_</keyword>
    <fullCommand>CopyMem_(source,dest,size)</fullCommand>
    <parameters>(source,dest,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopyMemQuick_">
    <keyword>CopyMemQuick_</keyword>
    <fullCommand>CopyMemQuick_(source,dest,size)</fullCommand>
    <parameters>(source,dest,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CacheClearE_">
    <keyword>CacheClearE_</keyword>
    <fullCommand>CacheClearE_(address,length,caches)</fullCommand>
    <parameters>(address,length,caches)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeleteIORequest_">
    <keyword>DeleteIORequest_</keyword>
    <fullCommand>DeleteIORequest_(iorequest)</fullCommand>
    <parameters>(iorequest)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeleteMsgPort_">
    <keyword>DeleteMsgPort_</keyword>
    <fullCommand>DeleteMsgPort_(port)</fullCommand>
    <parameters>(port)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ObtainSemaphoreShared_">
    <keyword>ObtainSemaphoreShared_</keyword>
    <fullCommand>ObtainSemaphoreShared_(sigSem)</fullCommand>
    <parameters>(sigSem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeVec_">
    <keyword>FreeVec_</keyword>
    <fullCommand>FreeVec_(memoryBlock)</fullCommand>
    <parameters>(memoryBlock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreatePool_">
    <keyword>CreatePool_</keyword>
    <fullCommand>CreatePool_(requirements,puddleSize,threshSize)</fullCommand>
    <parameters>(requirements,puddleSize,threshSize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeletePool_">
    <keyword>DeletePool_</keyword>
    <fullCommand>DeletePool_(poolHeader)</fullCommand>
    <parameters>(poolHeader)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreePooled_">
    <keyword>FreePooled_</keyword>
    <fullCommand>FreePooled_(poolHeader,memory,memSize)</fullCommand>
    <parameters>(poolHeader,memory,memSize)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AttemptSemaphoreShared_">
    <keyword>AttemptSemaphoreShared_</keyword>
    <fullCommand>AttemptSemaphoreShared_(sigSem)</fullCommand>
    <parameters>(sigSem)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StackSwap_">
    <keyword>StackSwap_</keyword>
    <fullCommand>StackSwap_(newStack)</fullCommand>
    <parameters>(newStack)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChildFree_">
    <keyword>ChildFree_</keyword>
    <fullCommand>ChildFree_(tid)</fullCommand>
    <parameters>(tid)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChildOrphan_">
    <keyword>ChildOrphan_</keyword>
    <fullCommand>ChildOrphan_(tid)</fullCommand>
    <parameters>(tid)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChildStatus_">
    <keyword>ChildStatus_</keyword>
    <fullCommand>ChildStatus_(tid)</fullCommand>
    <parameters>(tid)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChildWait_">
    <keyword>ChildWait_</keyword>
    <fullCommand>ChildWait_(tid)</fullCommand>
    <parameters>(tid)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CachePreDMA_">
    <keyword>CachePreDMA_</keyword>
    <fullCommand>CachePreDMA_(address,length,flags)</fullCommand>
    <parameters>(address,length,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CachePostDMA_">
    <keyword>CachePostDMA_</keyword>
    <fullCommand>CachePostDMA_(address,length,flags)</fullCommand>
    <parameters>(address,length,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddMemHandler_">
    <keyword>AddMemHandler_</keyword>
    <fullCommand>AddMemHandler_(memhand)</fullCommand>
    <parameters>(memhand)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemMemHandler_">
    <keyword>RemMemHandler_</keyword>
    <fullCommand>RemMemHandler_(memhand)</fullCommand>
    <parameters>(memhand)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadItem_">
    <keyword>ReadItem_</keyword>
    <fullCommand>ReadItem_(name,maxchars,cSource)</fullCommand>
    <parameters>(name,maxchars,cSource)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MatchNext_">
    <keyword>MatchNext_</keyword>
    <fullCommand>MatchNext_(anchor)</fullCommand>
    <parameters>(anchor)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MatchEnd_">
    <keyword>MatchEnd_</keyword>
    <fullCommand>MatchEnd_(anchor)</fullCommand>
    <parameters>(anchor)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ParsePattern_">
    <keyword>ParsePattern_</keyword>
    <fullCommand>ParsePattern_(pat,buf,buflen)</fullCommand>
    <parameters>(pat,buf,buflen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeArgs_">
    <keyword>FreeArgs_</keyword>
    <fullCommand>FreeArgs_(args)</fullCommand>
    <parameters>(args)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FilePart_">
    <keyword>FilePart_</keyword>
    <fullCommand>FilePart_(path)</fullCommand>
    <parameters>(path)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PathPart_">
    <keyword>PathPart_</keyword>
    <fullCommand>PathPart_(path)</fullCommand>
    <parameters>(path)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddPart_">
    <keyword>AddPart_</keyword>
    <fullCommand>AddPart_(dirname,filename,size)</fullCommand>
    <parameters>(dirname,filename,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StartNotify_">
    <keyword>StartNotify_</keyword>
    <fullCommand>StartNotify_(notify)</fullCommand>
    <parameters>(notify)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EndNotify_">
    <keyword>EndNotify_</keyword>
    <fullCommand>EndNotify_(notify)</fullCommand>
    <parameters>(notify)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CliInitNewcli_">
    <keyword>CliInitNewcli_</keyword>
    <fullCommand>CliInitNewcli_(dp)</fullCommand>
    <parameters>(dp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CliInitRun_">
    <keyword>CliInitRun_</keyword>
    <fullCommand>CliInitRun_(dp)</fullCommand>
    <parameters>(dp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PutStr_">
    <keyword>PutStr_</keyword>
    <fullCommand>PutStr_(str)</fullCommand>
    <parameters>(str)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ParsePatternNoCase_">
    <keyword>ParsePatternNoCase_</keyword>
    <fullCommand>ParsePatternNoCase_(pat,buf,buflen)</fullCommand>
    <parameters>(pat,buf,buflen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExAllEnd_">
    <keyword>ExAllEnd_</keyword>
    <fullCommand>ExAllEnd_(lock,buffer,size,data,control)</fullCommand>
    <parameters>(lock,buffer,size,data,control)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Close_">
    <keyword>Close_</keyword>
    <fullCommand>Close_(file)</fullCommand>
    <parameters>(file)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Read_">
    <keyword>Read_</keyword>
    <fullCommand>Read_(file,buffer,length)</fullCommand>
    <parameters>(file,buffer,length)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Write_">
    <keyword>Write_</keyword>
    <fullCommand>Write_(file,buffer,length)</fullCommand>
    <parameters>(file,buffer,length)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Seek_">
    <keyword>Seek_</keyword>
    <fullCommand>Seek_(file,position,offset)</fullCommand>
    <parameters>(file,position,offset)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeleteFile_">
    <keyword>DeleteFile_</keyword>
    <fullCommand>DeleteFile_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnLock_">
    <keyword>UnLock_</keyword>
    <fullCommand>UnLock_(lock)</fullCommand>
    <parameters>(lock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DupLock_">
    <keyword>DupLock_</keyword>
    <fullCommand>DupLock_(lock)</fullCommand>
    <parameters>(lock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateDir_">
    <keyword>CreateDir_</keyword>
    <fullCommand>CreateDir_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CurrentDir_">
    <keyword>CurrentDir_</keyword>
    <fullCommand>CurrentDir_(lock)</fullCommand>
    <parameters>(lock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Exit_">
    <keyword>Exit_</keyword>
    <fullCommand>Exit_(returnCode)</fullCommand>
    <parameters>(returnCode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LoadSeg_">
    <keyword>LoadSeg_</keyword>
    <fullCommand>LoadSeg_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnLoadSeg_">
    <keyword>UnLoadSeg_</keyword>
    <fullCommand>UnLoadSeg_(seglist)</fullCommand>
    <parameters>(seglist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeviceProc_">
    <keyword>DeviceProc_</keyword>
    <fullCommand>DeviceProc_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DateStamp_">
    <keyword>DateStamp_</keyword>
    <fullCommand>DateStamp_(date)</fullCommand>
    <parameters>(date)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Delay_">
    <keyword>Delay_</keyword>
    <fullCommand>Delay_(timeout)</fullCommand>
    <parameters>(timeout)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ParentDir_">
    <keyword>ParentDir_</keyword>
    <fullCommand>ParentDir_(lock)</fullCommand>
    <parameters>(lock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsInteractive_">
    <keyword>IsInteractive_</keyword>
    <fullCommand>IsInteractive_(file)</fullCommand>
    <parameters>(file)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Execute_">
    <keyword>Execute_</keyword>
    <fullCommand>Execute_(string,file,file2)</fullCommand>
    <parameters>(string,file,file2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DoPkt_">
    <keyword>DoPkt_</keyword>
    <fullCommand>DoPkt_(port,action,arg1,arg2,arg3,arg4,arg5)</fullCommand>
    <parameters>(port,action,arg1,arg2,arg3,arg4,arg5)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SendPkt_">
    <keyword>SendPkt_</keyword>
    <fullCommand>SendPkt_(dp,port,replyport)</fullCommand>
    <parameters>(dp,port,replyport)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReplyPkt_">
    <keyword>ReplyPkt_</keyword>
    <fullCommand>ReplyPkt_(dp,res1,res2)</fullCommand>
    <parameters>(dp,res1,res2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LockRecord_">
    <keyword>LockRecord_</keyword>
    <fullCommand>LockRecord_(fh,offset,length,mode,timeout)</fullCommand>
    <parameters>(fh,offset,length,mode,timeout)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnLockRecord_">
    <keyword>UnLockRecord_</keyword>
    <fullCommand>UnLockRecord_(fh,offset,length)</fullCommand>
    <parameters>(fh,offset,length)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnLockRecords_">
    <keyword>UnLockRecords_</keyword>
    <fullCommand>UnLockRecords_(recArray)</fullCommand>
    <parameters>(recArray)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SelectInput_">
    <keyword>SelectInput_</keyword>
    <fullCommand>SelectInput_(fh)</fullCommand>
    <parameters>(fh)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SelectOutput_">
    <keyword>SelectOutput_</keyword>
    <fullCommand>SelectOutput_(fh)</fullCommand>
    <parameters>(fh)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FGetC_">
    <keyword>FGetC_</keyword>
    <fullCommand>FGetC_(fh)</fullCommand>
    <parameters>(fh)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FGets_">
    <keyword>FGets_</keyword>
    <fullCommand>FGets_(fh,buf,buflen)</fullCommand>
    <parameters>(fh,buf,buflen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="VFWritef_">
    <keyword>VFWritef_</keyword>
    <fullCommand>VFWritef_(fh,format,argarray)</fullCommand>
    <parameters>(fh,format,argarray)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="VFPrintf_">
    <keyword>VFPrintf_</keyword>
    <fullCommand>VFPrintf_(fh,format,argarray)</fullCommand>
    <parameters>(fh,format,argarray)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Flush_">
    <keyword>Flush_</keyword>
    <fullCommand>Flush_(fh)</fullCommand>
    <parameters>(fh)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DupLockFromFH_">
    <keyword>DupLockFromFH_</keyword>
    <fullCommand>DupLockFromFH_(fh)</fullCommand>
    <parameters>(fh)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenFromLock_">
    <keyword>OpenFromLock_</keyword>
    <fullCommand>OpenFromLock_(lock)</fullCommand>
    <parameters>(lock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ParentOfFH_">
    <keyword>ParentOfFH_</keyword>
    <fullCommand>ParentOfFH_(fh)</fullCommand>
    <parameters>(fh)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NameFromLock_">
    <keyword>NameFromLock_</keyword>
    <fullCommand>NameFromLock_(lock,buffer,len)</fullCommand>
    <parameters>(lock,buffer,len)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NameFromFH_">
    <keyword>NameFromFH_</keyword>
    <fullCommand>NameFromFH_(fh,buffer,len)</fullCommand>
    <parameters>(fh,buffer,len)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SplitName_">
    <keyword>SplitName_</keyword>
    <fullCommand>SplitName_(name,seperator,buf,oldpos,size)</fullCommand>
    <parameters>(name,seperator,buf,oldpos,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ExAll_">
    <keyword>ExAll_</keyword>
    <fullCommand>ExAll_(lock,buffer,size,data,control)</fullCommand>
    <parameters>(lock,buffer,size,data,control)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadLink_">
    <keyword>ReadLink_</keyword>
    <fullCommand>ReadLink_(port,lock,path,buffer,size)</fullCommand>
    <parameters>(port,lock,path,buffer,size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MakeLink_">
    <keyword>MakeLink_</keyword>
    <fullCommand>MakeLink_(name,dest,soft)</fullCommand>
    <parameters>(name,dest,soft)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChangeMode_">
    <keyword>ChangeMode_</keyword>
    <fullCommand>ChangeMode_(type,fh,newmode)</fullCommand>
    <parameters>(type,fh,newmode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetFileSize_">
    <keyword>SetFileSize_</keyword>
    <fullCommand>SetFileSize_(fh,pos,mode)</fullCommand>
    <parameters>(fh,pos,mode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetIoErr_">
    <keyword>SetIoErr_</keyword>
    <fullCommand>SetIoErr_(result)</fullCommand>
    <parameters>(result)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateNewProc_">
    <keyword>CreateNewProc_</keyword>
    <fullCommand>CreateNewProc_(tags)</fullCommand>
    <parameters>(tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetConsoleTask_">
    <keyword>SetConsoleTask_</keyword>
    <fullCommand>SetConsoleTask_(task)</fullCommand>
    <parameters>(task)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetFileSysTask_">
    <keyword>SetFileSysTask_</keyword>
    <fullCommand>SetFileSysTask_(task)</fullCommand>
    <parameters>(task)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetArgStr_">
    <keyword>SetArgStr_</keyword>
    <fullCommand>SetArgStr_(string)</fullCommand>
    <parameters>(string)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindCliProc_">
    <keyword>FindCliProc_</keyword>
    <fullCommand>FindCliProc_(num)</fullCommand>
    <parameters>(num)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetCurrentDirName_">
    <keyword>SetCurrentDirName_</keyword>
    <fullCommand>SetCurrentDirName_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetProgramName_">
    <keyword>SetProgramName_</keyword>
    <fullCommand>SetProgramName_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPrompt_">
    <keyword>SetPrompt_</keyword>
    <fullCommand>SetPrompt_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetProgramDir_">
    <keyword>SetProgramDir_</keyword>
    <fullCommand>SetProgramDir_(lock)</fullCommand>
    <parameters>(lock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeDeviceProc_">
    <keyword>FreeDeviceProc_</keyword>
    <fullCommand>FreeDeviceProc_(dp)</fullCommand>
    <parameters>(dp)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LockDosList_">
    <keyword>LockDosList_</keyword>
    <fullCommand>LockDosList_(flags)</fullCommand>
    <parameters>(flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnLockDosList_">
    <keyword>UnLockDosList_</keyword>
    <fullCommand>UnLockDosList_(flags)</fullCommand>
    <parameters>(flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AttemptLockDosList_">
    <keyword>AttemptLockDosList_</keyword>
    <fullCommand>AttemptLockDosList_(flags)</fullCommand>
    <parameters>(flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemDosEntry_">
    <keyword>RemDosEntry_</keyword>
    <fullCommand>RemDosEntry_(dlist)</fullCommand>
    <parameters>(dlist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddDosEntry_">
    <keyword>AddDosEntry_</keyword>
    <fullCommand>AddDosEntry_(dlist)</fullCommand>
    <parameters>(dlist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindDosEntry_">
    <keyword>FindDosEntry_</keyword>
    <fullCommand>FindDosEntry_(dlist,name,flags)</fullCommand>
    <parameters>(dlist,name,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeDosEntry_">
    <keyword>FreeDosEntry_</keyword>
    <fullCommand>FreeDosEntry_(dlist)</fullCommand>
    <parameters>(dlist)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IsFileSystem_">
    <keyword>IsFileSystem_</keyword>
    <fullCommand>IsFileSystem_(name)</fullCommand>
    <parameters>(name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Format_">
    <keyword>Format_</keyword>
    <fullCommand>Format_(filesystem,volumename,dostype)</fullCommand>
    <parameters>(filesystem,volumename,dostype)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DateToStr_">
    <keyword>DateToStr_</keyword>
    <fullCommand>DateToStr_(datetime)</fullCommand>
    <parameters>(datetime)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrToDate_">
    <keyword>StrToDate_</keyword>
    <fullCommand>StrToDate_(datetime)</fullCommand>
    <parameters>(datetime)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddSegment_">
    <keyword>AddSegment_</keyword>
    <fullCommand>AddSegment_(name,seg,system)</fullCommand>
    <parameters>(name,seg,system)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindSegment_">
    <keyword>FindSegment_</keyword>
    <fullCommand>FindSegment_(name,seg,system)</fullCommand>
    <parameters>(name,seg,system)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemSegment_">
    <keyword>RemSegment_</keyword>
    <fullCommand>RemSegment_(seg)</fullCommand>
    <parameters>(seg)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CheckSignal_">
    <keyword>CheckSignal_</keyword>
    <fullCommand>CheckSignal_(mask)</fullCommand>
    <parameters>(mask)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadArgs_">
    <keyword>ReadArgs_</keyword>
    <fullCommand>ReadArgs_(template,array,args)</fullCommand>
    <parameters>(template,array,args)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenDiskFont_">
    <keyword>OpenDiskFont_</keyword>
    <fullCommand>OpenDiskFont_(textAttr)</fullCommand>
    <parameters>(textAttr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AvailFonts_">
    <keyword>AvailFonts_</keyword>
    <fullCommand>AvailFonts_(buffer,bufBytes,flags)</fullCommand>
    <parameters>(buffer,bufBytes,flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DisposeFontContents_">
    <keyword>DisposeFontContents_</keyword>
    <fullCommand>DisposeFontContents_(fontContentsHeader)</fullCommand>
    <parameters>(fontContentsHeader)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AllocUnit_">
    <keyword>AllocUnit_</keyword>
    <fullCommand>AllocUnit_(unitNum)</fullCommand>
    <parameters>(unitNum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeUnit_">
    <keyword>FreeUnit_</keyword>
    <fullCommand>FreeUnit_(unitNum)</fullCommand>
    <parameters>(unitNum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetUnit_">
    <keyword>GetUnit_</keyword>
    <fullCommand>GetUnit_(unitPointer)</fullCommand>
    <parameters>(unitPointer)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetUnitID_">
    <keyword>GetUnitID_</keyword>
    <fullCommand>GetUnitID_(unitNum)</fullCommand>
    <parameters>(unitNum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadUnitID_">
    <keyword>ReadUnitID_</keyword>
    <fullCommand>ReadUnitID_(unitNum)</fullCommand>
    <parameters>(unitNum)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ObtainDataTypeA_">
    <keyword>ObtainDataTypeA_</keyword>
    <fullCommand>ObtainDataTypeA_(type,handle,attrs)</fullCommand>
    <parameters>(type,handle,attrs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReleaseDataType_">
    <keyword>ReleaseDataType_</keyword>
    <fullCommand>ReleaseDataType_(dt)</fullCommand>
    <parameters>(dt)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DisposeDTObject_">
    <keyword>DisposeDTObject_</keyword>
    <fullCommand>DisposeDTObject_(o)</fullCommand>
    <parameters>(o)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDTMethods_">
    <keyword>GetDTMethods_</keyword>
    <fullCommand>GetDTMethods_(object)</fullCommand>
    <parameters>(object)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDTTriggerMethods_">
    <keyword>GetDTTriggerMethods_</keyword>
    <fullCommand>GetDTTriggerMethods_(object)</fullCommand>
    <parameters>(object)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetDTString_">
    <keyword>GetDTString_</keyword>
    <fullCommand>GetDTString_(id)</fullCommand>
    <parameters>(id)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CreateCxObj_">
    <keyword>CreateCxObj_</keyword>
    <fullCommand>CreateCxObj_(type,arg1,arg2)</fullCommand>
    <parameters>(type,arg1,arg2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeleteCxObj_">
    <keyword>DeleteCxObj_</keyword>
    <fullCommand>DeleteCxObj_(co)</fullCommand>
    <parameters>(co)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DeleteCxObjAll_">
    <keyword>DeleteCxObjAll_</keyword>
    <fullCommand>DeleteCxObjAll_(co)</fullCommand>
    <parameters>(co)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxObjType_">
    <keyword>CxObjType_</keyword>
    <fullCommand>CxObjType_(co)</fullCommand>
    <parameters>(co)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxObjError_">
    <keyword>CxObjError_</keyword>
    <fullCommand>CxObjError_(co)</fullCommand>
    <parameters>(co)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClearCxObjError_">
    <keyword>ClearCxObjError_</keyword>
    <fullCommand>ClearCxObjError_(co)</fullCommand>
    <parameters>(co)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InsertCxObj_">
    <keyword>InsertCxObj_</keyword>
    <fullCommand>InsertCxObj_(headObj,co,pred)</fullCommand>
    <parameters>(headObj,co,pred)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemoveCxObj_">
    <keyword>RemoveCxObj_</keyword>
    <fullCommand>RemoveCxObj_(co)</fullCommand>
    <parameters>(co)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxMsgType_">
    <keyword>CxMsgType_</keyword>
    <fullCommand>CxMsgType_(cxm)</fullCommand>
    <parameters>(cxm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxMsgData_">
    <keyword>CxMsgData_</keyword>
    <fullCommand>CxMsgData_(cxm)</fullCommand>
    <parameters>(cxm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CxMsgID_">
    <keyword>CxMsgID_</keyword>
    <fullCommand>CxMsgID_(cxm)</fullCommand>
    <parameters>(cxm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DivertCxMsg_">
    <keyword>DivertCxMsg_</keyword>
    <fullCommand>DivertCxMsg_(cxm,headObj,returnObj)</fullCommand>
    <parameters>(cxm,headObj,returnObj)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DisposeCxMsg_">
    <keyword>DisposeCxMsg_</keyword>
    <fullCommand>DisposeCxMsg_(cxm)</fullCommand>
    <parameters>(cxm)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InvertKeyMap_">
    <keyword>InvertKeyMap_</keyword>
    <fullCommand>InvertKeyMap_(ansiCode,event,km)</fullCommand>
    <parameters>(ansiCode,event,km)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddIEvents_">
    <keyword>AddIEvents_</keyword>
    <fullCommand>AddIEvents_(events)</fullCommand>
    <parameters>(events)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddICRVector_b">
    <keyword>AddICRVector_b</keyword>
    <fullCommand>AddICRVector_b(resource,iCRBit,interrupt)</fullCommand>
    <parameters>(resource,iCRBit,interrupt)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemICRVector_b">
    <keyword>RemICRVector_b</keyword>
    <fullCommand>RemICRVector_b(resource,iCRBit,interrupt)</fullCommand>
    <parameters>(resource,iCRBit,interrupt)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddICRVector_a">
    <keyword>AddICRVector_a</keyword>
    <fullCommand>AddICRVector_a(resource,iCRBit,interrupt)</fullCommand>
    <parameters>(resource,iCRBit,interrupt)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemICRVector_a">
    <keyword>RemICRVector_a</keyword>
    <fullCommand>RemICRVector_a(resource,iCRBit,interrupt)</fullCommand>
    <parameters>(resource,iCRBit,interrupt)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OwnCard_">
    <keyword>OwnCard_</keyword>
    <fullCommand>OwnCard_(handle)</fullCommand>
    <parameters>(handle)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BeginCardAccess_">
    <keyword>BeginCardAccess_</keyword>
    <fullCommand>BeginCardAccess_(handle)</fullCommand>
    <parameters>(handle)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="EndCardAccess_">
    <keyword>EndCardAccess_</keyword>
    <fullCommand>EndCardAccess_(handle)</fullCommand>
    <parameters>(handle)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CardResetCard_">
    <keyword>CardResetCard_</keyword>
    <fullCommand>CardResetCard_(handle)</fullCommand>
    <parameters>(handle)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="IfAmigaXIP_">
    <keyword>IfAmigaXIP_</keyword>
    <fullCommand>IfAmigaXIP_(handle)</fullCommand>
    <parameters>(handle)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseEngine_">
    <keyword>CloseEngine_</keyword>
    <fullCommand>CloseEngine_(glyphEngine)</fullCommand>
    <parameters>(glyphEngine)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReadBattMem_">
    <keyword>ReadBattMem_</keyword>
    <fullCommand>ReadBattMem_(buffer,offset,length)</fullCommand>
    <parameters>(buffer,offset,length)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WriteBattMem_">
    <keyword>WriteBattMem_</keyword>
    <fullCommand>WriteBattMem_(buffer,offset,length)</fullCommand>
    <parameters>(buffer,offset,length)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WriteBattClock_">
    <keyword>WriteBattClock_</keyword>
    <fullCommand>WriteBattClock_(time)</fullCommand>
    <parameters>(time)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeFileRequest_">
    <keyword>FreeFileRequest_</keyword>
    <fullCommand>FreeFileRequest_(fileReq)</fullCommand>
    <parameters>(fileReq)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RequestFile_">
    <keyword>RequestFile_</keyword>
    <fullCommand>RequestFile_(fileReq)</fullCommand>
    <parameters>(fileReq)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeAslRequest_">
    <keyword>FreeAslRequest_</keyword>
    <fullCommand>FreeAslRequest_(requester)</fullCommand>
    <parameters>(requester)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LockAmigaGuideBase_">
    <keyword>LockAmigaGuideBase_</keyword>
    <fullCommand>LockAmigaGuideBase_(handle)</fullCommand>
    <parameters>(handle)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnlockAmigaGuideBase_">
    <keyword>UnlockAmigaGuideBase_</keyword>
    <fullCommand>UnlockAmigaGuideBase_(key)</fullCommand>
    <parameters>(key)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseAmigaGuide_">
    <keyword>CloseAmigaGuide_</keyword>
    <fullCommand>CloseAmigaGuide_(cl)</fullCommand>
    <parameters>(cl)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AmigaGuideSignal_">
    <keyword>AmigaGuideSignal_</keyword>
    <fullCommand>AmigaGuideSignal_(cl)</fullCommand>
    <parameters>(cl)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetAmigaGuideMsg_">
    <keyword>GetAmigaGuideMsg_</keyword>
    <fullCommand>GetAmigaGuideMsg_(cl)</fullCommand>
    <parameters>(cl)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ReplyAmigaGuideMsg_">
    <keyword>ReplyAmigaGuideMsg_</keyword>
    <fullCommand>ReplyAmigaGuideMsg_(amsg)</fullCommand>
    <parameters>(amsg)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetAmigaGuideContextA_">
    <keyword>SetAmigaGuideContextA_</keyword>
    <fullCommand>SetAmigaGuideContextA_(cl,id,attrs)</fullCommand>
    <parameters>(cl,id,attrs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SendAmigaGuideCmdA_">
    <keyword>SendAmigaGuideCmdA_</keyword>
    <fullCommand>SendAmigaGuideCmdA_(cl,cmd,attrs)</fullCommand>
    <parameters>(cl,cmd,attrs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetAmigaGuideAttr_">
    <keyword>GetAmigaGuideAttr_</keyword>
    <fullCommand>GetAmigaGuideAttr_(tag,cl,storage)</fullCommand>
    <parameters>(tag,cl,storage)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddAmigaGuideHostA_">
    <keyword>AddAmigaGuideHostA_</keyword>
    <fullCommand>AddAmigaGuideHostA_(h,name,attrs)</fullCommand>
    <parameters>(h,name,attrs)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetAmigaGuideString_">
    <keyword>GetAmigaGuideString_</keyword>
    <fullCommand>GetAmigaGuideString_(id)</fullCommand>
    <parameters>(id)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TEDSetLabelList_">
    <keyword>TEDSetLabelList_</keyword>
    <fullCommand>TEDSetLabelList_(&amp;mouselist) (a0)-30</fullCommand>
    <parameters>(&amp;mouselist) (a0)-30</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TEDSetLabelCount_">
    <keyword>TEDSetLabelCount_</keyword>
    <fullCommand>TEDSetLabelCount_(&amp;mousecount) (a0)-36</fullCommand>
    <parameters>(&amp;mousecount) (a0)-36</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TEDError_">
    <keyword>TEDError_</keyword>
    <fullCommand>TEDError_(bodytext) (a0)-66</fullCommand>
    <parameters>(bodytext) (a0)-66</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TEDSetFirstLine_">
    <keyword>TEDSetFirstLine_</keyword>
    <fullCommand>TEDSetFirstLine_(&amp;firstline) (a0)-72</fullCommand>
    <parameters>(&amp;firstline) (a0)-72</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TEDSetCurrentLine_">
    <keyword>TEDSetCurrentLine_</keyword>
    <fullCommand>TEDSetCurrentLine_(&amp;currentline) (a0)-78</fullCommand>
    <parameters>(&amp;currentline) (a0)-78</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TEDDetoke_">
    <keyword>TEDDetoke_</keyword>
    <fullCommand>TEDDetoke_(sourceline) (a0)-96</fullCommand>
    <parameters>(sourceline) (a0)-96</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TagList">
    <keyword>TagList</keyword>
    <fullCommand>TagList [#TagList]</fullCommand>
    <parameters>[#TagList]</parameters>
    <shortDescription>returns location of TagList, 0 if not in use.</shortDescription>
    <longDescription />
  </command>
  <command name="InitTagList">
    <keyword>InitTagList</keyword>
    <fullCommand>InitTagList TagList#,NoTags.l</fullCommand>
    <parameters>TagList#,NoTags.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="AddTags">
    <keyword>AddTags</keyword>
    <fullCommand>AddTags [#TagList] [[,Tag.l,Data.l]]</fullCommand>
    <parameters>[#TagList] [[,Tag.l,Data.l]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NoTagsLeft">
    <keyword>NoTagsLeft</keyword>
    <fullCommand>NoTagsLeft [#TagList]</fullCommand>
    <parameters>[#TagList]</parameters>
    <shortDescription>returns the number of tags left in the taglist.</shortDescription>
    <longDescription />
  </command>
  <command name="LED_On">
    <keyword>LED_On</keyword>
    <fullCommand>LED_On turn Power-LED on.</fullCommand>
    <parameters>turn Power-LED on.</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LED_Off">
    <keyword>LED_Off</keyword>
    <fullCommand>LED_Off turn Power-LED off.</fullCommand>
    <parameters>turn Power-LED off.</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LED_Toggle">
    <keyword>LED_Toggle</keyword>
    <fullCommand>LED_Toggle toggle PowerLED.</fullCommand>
    <parameters>toggle PowerLED.</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LED_Status">
    <keyword>LED_Status</keyword>
    <fullCommand>LED_Status 0=off, -1=on</fullCommand>
    <parameters>0=off, -1=on</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PotGo">
    <keyword>PotGo</keyword>
    <fullCommand>PotGo</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>starts up ADs (need 300ms to run).</shortDescription>
    <longDescription />
  </command>
  <command name="ReadPot">
    <keyword>ReadPot</keyword>
    <fullCommand>ReadPot(AD)</fullCommand>
    <parameters>(AD)</parameters>
    <shortDescription>0=P0-X, 1=P0-Y, 2=P1-X, 3=P1-Y.</shortDescription>
    <longDescription />
  </command>
  <command name="AKey">
    <keyword>AKey</keyword>
    <fullCommand>AKey</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>n.b=AKey, Code of !ALL! Keys.</shortDescription>
    <longDescription />
  </command>
  <command name="LMBD">
    <keyword>LMBD</keyword>
    <fullCommand>LMBD</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>wait until Left-Mouse-Button-Down.</shortDescription>
    <longDescription />
  </command>
  <command name="RMBD">
    <keyword>RMBD</keyword>
    <fullCommand>RMBD</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>wait until Right-Mouse-Button-Down.</shortDescription>
    <longDescription />
  </command>
  <command name="LMBU">
    <keyword>LMBU</keyword>
    <fullCommand>LMBU</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>wait until Left-Mouse-Button-Up.</shortDescription>
    <longDescription />
  </command>
  <command name="RMBU">
    <keyword>RMBU</keyword>
    <fullCommand>RMBU</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>wait until Right-Mouse-Button-Up.</shortDescription>
    <longDescription />
  </command>
  <command name="ReadParPort">
    <keyword>ReadParPort</keyword>
    <fullCommand>ReadParPort</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>n.b=ReadParPort.</shortDescription>
    <longDescription />
  </command>
  <command name="WriteParPort">
    <keyword>WriteParPort</keyword>
    <fullCommand>WriteParPort BitSet</fullCommand>
    <parameters>BitSet</parameters>
    <shortDescription>0-255.</shortDescription>
    <longDescription />
  </command>
  <command name="SetParDDR">
    <keyword>SetParDDR</keyword>
    <fullCommand>SetParDDR BitSet</fullCommand>
    <parameters>BitSet</parameters>
    <shortDescription>0-255.</shortDescription>
    <longDescription />
  </command>
  <command name="GetParDDR">
    <keyword>GetParDDR</keyword>
    <fullCommand>GetParDDR</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>n.b=GetParDDR.</shortDescription>
    <longDescription />
  </command>
  <command name="TCPSock">
    <keyword>TCPSock</keyword>
    <fullCommand>TCPSock A sockit object.</fullCommand>
    <parameters>A sockit object.</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPClose">
    <keyword>TCPClose</keyword>
    <fullCommand>TCPClose</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPAvail">
    <keyword>TCPAvail</keyword>
    <fullCommand>TCPAvail</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDSocket">
    <keyword>BSDSocket</keyword>
    <fullCommand>BSDSocket(Domain,Type,Protocol)</fullCommand>
    <parameters>(Domain,Type,Protocol)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDBind">
    <keyword>BSDBind</keyword>
    <fullCommand>BSDBind([s]ock,*Name,NameLen)</fullCommand>
    <parameters>([s]ock,*Name,NameLen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDListen">
    <keyword>BSDListen</keyword>
    <fullCommand>BSDListen([s]ock,BackLog)</fullCommand>
    <parameters>([s]ock,BackLog)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDAccept">
    <keyword>BSDAccept</keyword>
    <fullCommand>BSDAccept([s]ock,*Addr,*AddrLen)</fullCommand>
    <parameters>([s]ock,*Addr,*AddrLen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDConnect">
    <keyword>BSDConnect</keyword>
    <fullCommand>BSDConnect([s]ock,*Name,*NameLen)</fullCommand>
    <parameters>([s]ock,*Name,*NameLen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDSendTo">
    <keyword>BSDSendTo</keyword>
    <fullCommand>BSDSendTo([s]ock,*Buf,Len,Flags,*To,ToLen)</fullCommand>
    <parameters>([s]ock,*Buf,Len,Flags,*To,ToLen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDSend">
    <keyword>BSDSend</keyword>
    <fullCommand>BSDSend([s]ock,*Buf,Len,Flags)</fullCommand>
    <parameters>([s]ock,*Buf,Len,Flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDRecvFrom">
    <keyword>BSDRecvFrom</keyword>
    <fullCommand>BSDRecvFrom([s]ock,*Buf,Len,Flags,*Addr,*AddrLen)</fullCommand>
    <parameters>([s]ock,*Buf,Len,Flags,*Addr,*AddrLen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDRecv">
    <keyword>BSDRecv</keyword>
    <fullCommand>BSDRecv([s]ock,*Buf,Len,Flags)</fullCommand>
    <parameters>([s]ock,*Buf,Len,Flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDShutDown">
    <keyword>BSDShutDown</keyword>
    <fullCommand>BSDShutDown([s]ock,How)</fullCommand>
    <parameters>([s]ock,How)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDSetSockOpt">
    <keyword>BSDSetSockOpt</keyword>
    <fullCommand>BSDSetSockOpt([s]ock,Level,OptName,*OptVal,OptLen)</fullCommand>
    <parameters>([s]ock,Level,OptName,*OptVal,OptLen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetSockOpt">
    <keyword>BSDGetSockOpt</keyword>
    <fullCommand>BSDGetSockOpt([s]ock,Level,OptName,*OptVal,*OptLen)</fullCommand>
    <parameters>([s]ock,Level,OptName,*OptVal,*OptLen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetSockName">
    <keyword>BSDGetSockName</keyword>
    <fullCommand>BSDGetSockName([s]ock,*Name,*NameLen)</fullCommand>
    <parameters>([s]ock,*Name,*NameLen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetPeerName">
    <keyword>BSDGetPeerName</keyword>
    <fullCommand>BSDGetPeerName([s]ock,*Name,*NameLen)</fullCommand>
    <parameters>([s]ock,*Name,*NameLen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDIoctlSocket">
    <keyword>BSDIoctlSocket</keyword>
    <fullCommand>BSDIoctlSocket([s]ock,Req,*ArgP)</fullCommand>
    <parameters>([s]ock,Req,*ArgP)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDCloseSocket">
    <keyword>BSDCloseSocket</keyword>
    <fullCommand>BSDCloseSocket([s]ock)</fullCommand>
    <parameters>([s]ock)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDWaitSelect">
    <keyword>BSDWaitSelect</keyword>
    <fullCommand>BSDWaitSelect(nFDS,*ReadFDS,*WriteFDS,*ExceptFDS,*TimeOut,*Signal)</fullCommand>
    <parameters>(nFDS,*ReadFDS,*WriteFDS,*ExceptFDS,*TimeOut,*Signal)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDSetSocketSignals">
    <keyword>BSDSetSocketSignals</keyword>
    <fullCommand>BSDSetSocketSignals(IntMask,IOMask,UrgentMask)</fullCommand>
    <parameters>(IntMask,IOMask,UrgentMask)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetDTableSize">
    <keyword>BSDGetDTableSize</keyword>
    <fullCommand>BSDGetDTableSize</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDObtainSocket">
    <keyword>BSDObtainSocket</keyword>
    <fullCommand>BSDObtainSocket(ID,Domain,Type,Protocol)</fullCommand>
    <parameters>(ID,Domain,Type,Protocol)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDReleaseSocket">
    <keyword>BSDReleaseSocket</keyword>
    <fullCommand>BSDReleaseSocket([s]ock,ID)</fullCommand>
    <parameters>([s]ock,ID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDReleaseCopyOfSocket">
    <keyword>BSDReleaseCopyOfSocket</keyword>
    <fullCommand>BSDReleaseCopyOfSocket([s]ock,ID)</fullCommand>
    <parameters>([s]ock,ID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDErrNo">
    <keyword>BSDErrNo</keyword>
    <fullCommand>BSDErrNo</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDSetErrnoPtr">
    <keyword>BSDSetErrnoPtr</keyword>
    <fullCommand>BSDSetErrnoPtr(*ErrNoP,Size)</fullCommand>
    <parameters>(*ErrNoP,Size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDINet_NToA">
    <keyword>BSDINet_NToA</keyword>
    <fullCommand>BSDINet_NToA(IP)</fullCommand>
    <parameters>(IP)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDINet_Addr">
    <keyword>BSDINet_Addr</keyword>
    <fullCommand>BSDINet_Addr(*CP)</fullCommand>
    <parameters>(*CP)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDINet_LnaOf">
    <keyword>BSDINet_LnaOf</keyword>
    <fullCommand>BSDINet_LnaOf(,In)</fullCommand>
    <parameters>(,In)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDINet_NetOf">
    <keyword>BSDINet_NetOf</keyword>
    <fullCommand>BSDINet_NetOf(In)</fullCommand>
    <parameters>(In)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDINet_MakeAddr">
    <keyword>BSDINet_MakeAddr</keyword>
    <fullCommand>BSDINet_MakeAddr(Net,Host)</fullCommand>
    <parameters>(Net,Host)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDINet_Network">
    <keyword>BSDINet_Network</keyword>
    <fullCommand>BSDINet_Network(*CP)</fullCommand>
    <parameters>(*CP)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetHostByAddr">
    <keyword>BSDGetHostByAddr</keyword>
    <fullCommand>BSDGetHostByAddr(*Addr,Len,Type)</fullCommand>
    <parameters>(*Addr,Len,Type)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetNetByName">
    <keyword>BSDGetNetByName</keyword>
    <fullCommand>BSDGetNetByName(*Name)</fullCommand>
    <parameters>(*Name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetNetByAddr">
    <keyword>BSDGetNetByAddr</keyword>
    <fullCommand>BSDGetNetByAddr(Net,Type)</fullCommand>
    <parameters>(Net,Type)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetServByName">
    <keyword>BSDGetServByName</keyword>
    <fullCommand>BSDGetServByName(*Name,*Proto)</fullCommand>
    <parameters>(*Name,*Proto)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetServByPort">
    <keyword>BSDGetServByPort</keyword>
    <fullCommand>BSDGetServByPort(Port,*Proto)</fullCommand>
    <parameters>(Port,*Proto)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetProtoByName">
    <keyword>BSDGetProtoByName</keyword>
    <fullCommand>BSDGetProtoByName(*Name)</fullCommand>
    <parameters>(*Name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetProtoByNumber">
    <keyword>BSDGetProtoByNumber</keyword>
    <fullCommand>BSDGetProtoByNumber(ID)</fullCommand>
    <parameters>(ID)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDVSysLog">
    <keyword>BSDVSysLog</keyword>
    <fullCommand>BSDVSysLog(Pri,*Msg,Args)</fullCommand>
    <parameters>(Pri,*Msg,Args)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDDup2Socket">
    <keyword>BSDDup2Socket</keyword>
    <fullCommand>BSDDup2Socket(Olds,News)</fullCommand>
    <parameters>(Olds,News)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDSendMsg">
    <keyword>BSDSendMsg</keyword>
    <fullCommand>BSDSendMsg([s]ock,*Msg,Flags)</fullCommand>
    <parameters>([s]ock,*Msg,Flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDRecvMsg">
    <keyword>BSDRecvMsg</keyword>
    <fullCommand>BSDRecvMsg([s]ock,*Msg,Flags)</fullCommand>
    <parameters>([s]ock,*Msg,Flags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetHostName">
    <keyword>BSDGetHostName</keyword>
    <fullCommand>BSDGetHostName(*Name,NameLen)</fullCommand>
    <parameters>(*Name,NameLen)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetHostID">
    <keyword>BSDGetHostID</keyword>
    <fullCommand>BSDGetHostID</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDSocketBaseTagList">
    <keyword>BSDSocketBaseTagList</keyword>
    <fullCommand>BSDSocketBaseTagList(*Tags)</fullCommand>
    <parameters>(*Tags)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetSocketEvents">
    <keyword>BSDGetSocketEvents</keyword>
    <fullCommand>BSDGetSocketEvents(*EventSP)</fullCommand>
    <parameters>(*EventSP)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BSDGetHostByName">
    <keyword>BSDGetHostByName</keyword>
    <fullCommand>BSDGetHostByName(*Name)</fullCommand>
    <parameters>(*Name)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPFillMemB">
    <keyword>TCPFillMemB</keyword>
    <fullCommand>TCPFillMemB *Address,FillByte,Length</fullCommand>
    <parameters>*Address,FillByte,Length</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPOpen">
    <keyword>TCPOpen</keyword>
    <fullCommand>TCPOpen</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPFillMemL">
    <keyword>TCPFillMemL</keyword>
    <fullCommand>TCPFillMemL *Address,FillLong,Length</fullCommand>
    <parameters>*Address,FillLong,Length</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPFDSet">
    <keyword>TCPFDSet</keyword>
    <fullCommand>TCPFDSet SockBit,*FDAddress</fullCommand>
    <parameters>SockBit,*FDAddress</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPFDClear">
    <keyword>TCPFDClear</keyword>
    <fullCommand>TCPFDClear SockBit,*FDAddress</fullCommand>
    <parameters>SockBit,*FDAddress</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPCreateSocket">
    <keyword>TCPCreateSocket</keyword>
    <fullCommand>TCPCreateSocket(TCPSock#,BlockingOnOff,SocketRW,TSecs,TMicros)</fullCommand>
    <parameters>(TCPSock#,BlockingOnOff,SocketRW,TSecs,TMicros)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPRemoveSocket">
    <keyword>TCPRemoveSocket</keyword>
    <fullCommand>TCPRemoveSocket(TCPSock#)</fullCommand>
    <parameters>(TCPSock#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPFDIsSet">
    <keyword>TCPFDIsSet</keyword>
    <fullCommand>TCPFDIsSet(SockBit,*FDAddress)</fullCommand>
    <parameters>(SockBit,*FDAddress)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPFDWriteLoc">
    <keyword>TCPFDWriteLoc</keyword>
    <fullCommand>TCPFDWriteLoc</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPFDReadLoc">
    <keyword>TCPFDReadLoc</keyword>
    <fullCommand>TCPFDReadLoc</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPConnectSocket">
    <keyword>TCPConnectSocket</keyword>
    <fullCommand>TCPConnectSocket(TCPSock#,Host$,Port)</fullCommand>
    <parameters>(TCPSock#,Host$,Port)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPEvent">
    <keyword>TCPEvent</keyword>
    <fullCommand>TCPEvent</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPShutSocket">
    <keyword>TCPShutSocket</keyword>
    <fullCommand>TCPShutSocket(TCPSock#,How)</fullCommand>
    <parameters>(TCPSock#,How)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPFDIntHighLoc">
    <keyword>TCPFDIntHighLoc</keyword>
    <fullCommand>TCPFDIntHighLoc</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPHighest">
    <keyword>TCPHighest</keyword>
    <fullCommand>TCPHighest</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPRescanHighest">
    <keyword>TCPRescanHighest</keyword>
    <fullCommand>TCPRescanHighest</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPSetStates">
    <keyword>TCPSetStates</keyword>
    <fullCommand>TCPSetStates(TCPSock#,States)</fullCommand>
    <parameters>(TCPSock#,States)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPWrite">
    <keyword>TCPWrite</keyword>
    <fullCommand>TCPWrite TCPSock#,*DataAddress,DataLength</fullCommand>
    <parameters>TCPSock#,*DataAddress,DataLength</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPPrint">
    <keyword>TCPPrint</keyword>
    <fullCommand>TCPPrint TCPSock#,Data$</fullCommand>
    <parameters>TCPSock#,Data$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPNPrint">
    <keyword>TCPNPrint</keyword>
    <fullCommand>TCPNPrint TCPSock#,Data$</fullCommand>
    <parameters>TCPSock#,Data$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPSetReceiveBuffer">
    <keyword>TCPSetReceiveBuffer</keyword>
    <fullCommand>TCPSetReceiveBuffer(Size)</fullCommand>
    <parameters>(Size)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPReadSocket$">
    <keyword>TCPReadSocket$</keyword>
    <fullCommand>TCPReadSocket$(TCPSock#)</fullCommand>
    <parameters>(TCPSock#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPIsReadEvent">
    <keyword>TCPIsReadEvent</keyword>
    <fullCommand>TCPIsReadEvent(TCPSock#)</fullCommand>
    <parameters>(TCPSock#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPIsWriteEvent">
    <keyword>TCPIsWriteEvent</keyword>
    <fullCommand>TCPIsWriteEvent(TCPSock#)</fullCommand>
    <parameters>(TCPSock#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPFreeReceiveBuffer">
    <keyword>TCPFreeReceiveBuffer</keyword>
    <fullCommand>TCPFreeReceiveBuffer</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPBufferAddress">
    <keyword>TCPBufferAddress</keyword>
    <fullCommand>TCPBufferAddress</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPFDTempWriteLoc">
    <keyword>TCPFDTempWriteLoc</keyword>
    <fullCommand>TCPFDTempWriteLoc</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPFDTempReadLoc">
    <keyword>TCPFDTempReadLoc</keyword>
    <fullCommand>TCPFDTempReadLoc</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPLastReadSize">
    <keyword>TCPLastReadSize</keyword>
    <fullCommand>TCPLastReadSize</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPSocketNumber">
    <keyword>TCPSocketNumber</keyword>
    <fullCommand>TCPSocketNumber(TCPSock#)</fullCommand>
    <parameters>(TCPSock#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPSocketError">
    <keyword>TCPSocketError</keyword>
    <fullCommand>TCPSocketError(TCPSock#)</fullCommand>
    <parameters>(TCPSock#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPErrorString$">
    <keyword>TCPErrorString$</keyword>
    <fullCommand>TCPErrorString$</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPListenSocket">
    <keyword>TCPListenSocket</keyword>
    <fullCommand>TCPListenSocket(TCPSock#,QueueBacklog)</fullCommand>
    <parameters>(TCPSock#,QueueBacklog)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPGetOwnHostName$">
    <keyword>TCPGetOwnHostName$</keyword>
    <fullCommand>TCPGetOwnHostName$(MaxLength)</fullCommand>
    <parameters>(MaxLength)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPGetIPStr$">
    <keyword>TCPGetIPStr$</keyword>
    <fullCommand>TCPGetIPStr$(IPAddress.l)</fullCommand>
    <parameters>(IPAddress.l)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPGetIPClass">
    <keyword>TCPGetIPClass</keyword>
    <fullCommand>TCPGetIPClass(IPAddress.l,Class)</fullCommand>
    <parameters>(IPAddress.l,Class)</parameters>
    <shortDescription>Class: 0-3.</shortDescription>
    <longDescription />
  </command>
  <command name="TCPExamineHostEntry">
    <keyword>TCPExamineHostEntry</keyword>
    <fullCommand>TCPExamineHostEntry(Host$)</fullCommand>
    <parameters>(Host$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPHostIPStr$">
    <keyword>TCPHostIPStr$</keyword>
    <fullCommand>TCPHostIPStr$(Entry)</fullCommand>
    <parameters>(Entry)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPHostIP">
    <keyword>TCPHostIP</keyword>
    <fullCommand>TCPHostIP(Entry)</fullCommand>
    <parameters>(Entry)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPExamineAddrEntry">
    <keyword>TCPExamineAddrEntry</keyword>
    <fullCommand>TCPExamineAddrEntry(IPAddress.l)</fullCommand>
    <parameters>(IPAddress.l)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPCanonicalName$">
    <keyword>TCPCanonicalName$</keyword>
    <fullCommand>TCPCanonicalName$</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPSlapSocketIn">
    <keyword>TCPSlapSocketIn</keyword>
    <fullCommand>TCPSlapSocketIn(Socket,TCPSock#)</fullCommand>
    <parameters>(Socket,TCPSock#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPPullSocketOut">
    <keyword>TCPPullSocketOut</keyword>
    <fullCommand>TCPPullSocketOut(TCPSock#)</fullCommand>
    <parameters>(TCPSock#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="TCPGetOwnHostIP">
    <keyword>TCPGetOwnHostIP</keyword>
    <fullCommand>TCPGetOwnHostIP</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UPeek">
    <keyword>UPeek</keyword>
    <fullCommand>UPeek(ad.l)</fullCommand>
    <parameters>(ad.l)</parameters>
    <shortDescription>returns a word equal to unsigned value of byte at ad.</shortDescription>
    <longDescription />
  </command>
  <command name="DotProduct">
    <keyword>DotProduct</keyword>
    <fullCommand>DotProduct &amp;N.Vector_Type,&amp;L.Vector_Type</fullCommand>
    <parameters>&amp;N.Vector_Type,&amp;L.Vector_Type</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ApplyMatrix">
    <keyword>ApplyMatrix</keyword>
    <fullCommand>ApplyMatrix &amp;M.Matrix_Type,&amp;V.Vector_Type,&amp;R.Vector_Type</fullCommand>
    <parameters>&amp;M.Matrix_Type,&amp;V.Vector_Type,&amp;R.Vector_Type</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="VectorMagnitude">
    <keyword>VectorMagnitude</keyword>
    <fullCommand>VectorMagnitude(&amp;V.Vector_Type) returns quick</fullCommand>
    <parameters>(&amp;V.Vector_Type) returns quick</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="VectorAngle">
    <keyword>VectorAngle</keyword>
    <fullCommand>VectorAngle(&amp;N.Vector_Type,&amp;L.Vector_Type), returns quick</fullCommand>
    <parameters>(&amp;N.Vector_Type,&amp;L.Vector_Type), returns quick</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="UnitVector">
    <keyword>UnitVector</keyword>
    <fullCommand>UnitVector &amp;N.Vector_Type</fullCommand>
    <parameters>&amp;N.Vector_Type</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CrossProduct">
    <keyword>CrossProduct</keyword>
    <fullCommand>CrossProduct &amp;N.Vector_Type,&amp;L.Vector_Type,&amp;Result.Vector_Type</fullCommand>
    <parameters>&amp;N.Vector_Type,&amp;L.Vector_Type,&amp;Result.Vector_Type</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SubtractVectors">
    <keyword>SubtractVectors</keyword>
    <fullCommand>SubtractVectors &amp;N.Vector_Type,&amp;L.Vector_Type,&amp;Result.Vector_Type</fullCommand>
    <parameters>&amp;N.Vector_Type,&amp;L.Vector_Type,&amp;Result.Vector_Type</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MakeVector">
    <keyword>MakeVector</keyword>
    <fullCommand>MakeVector x.w,y.w,z.w,&amp;V.Vector_Type</fullCommand>
    <parameters>x.w,y.w,z.w,&amp;V.Vector_Type</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DepthSort">
    <keyword>DepthSort</keyword>
    <fullCommand>DepthSort &amp;Index.q,&amp;Assoc1.l,&amp;Assoc2.l,items.l</fullCommand>
    <parameters>&amp;Index.q,&amp;Assoc1.l,&amp;Assoc2.l,items.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ShellSort">
    <keyword>ShellSort</keyword>
    <fullCommand>ShellSort &amp;array.l,items.l</fullCommand>
    <parameters>&amp;array.l,items.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="QMULS">
    <keyword>QMULS</keyword>
    <fullCommand>QMULS(v1.q,v2.q) Fast 020 quick multiply</fullCommand>
    <parameters>(v1.q,v2.q) Fast 020 quick multiply</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FastApply">
    <keyword>FastApply</keyword>
    <fullCommand>FastApply &amp;M.Matrix_Type,&amp;V.Vector_Type,&amp;R.Vector_Type</fullCommand>
    <parameters>&amp;M.Matrix_Type,&amp;V.Vector_Type,&amp;R.Vector_Type</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FastVectorAngle">
    <keyword>FastVectorAngle</keyword>
    <fullCommand>FastVectorAngle(&amp;N.Vector_Type,&amp;L.Vector_Type), returns quick</fullCommand>
    <parameters>(&amp;N.Vector_Type,&amp;L.Vector_Type), returns quick</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FastUnitVector">
    <keyword>FastUnitVector</keyword>
    <fullCommand>FastUnitVector &amp;N.Vector_Type</fullCommand>
    <parameters>&amp;N.Vector_Type</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ShellDepthSort">
    <keyword>ShellDepthSort</keyword>
    <fullCommand>ShellDepthSort &amp;array.l,items.l</fullCommand>
    <parameters>&amp;array.l,items.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CInitDraw">
    <keyword>CInitDraw</keyword>
    <fullCommand>CInitDraw Addr Chunky Object.l</fullCommand>
    <parameters>Addr Chunky Object.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CHLine">
    <keyword>CHLine</keyword>
    <fullCommand>CHLine x1,x2,y,c.b</fullCommand>
    <parameters>x1,x2,y,c.b</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CDrawDone">
    <keyword>CDrawDone</keyword>
    <fullCommand>CDrawDone</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CLine">
    <keyword>CLine</keyword>
    <fullCommand>CLine x1,y1,x2,y2,c</fullCommand>
    <parameters>x1,y1,x2,y2,c</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CCls">
    <keyword>CCls</keyword>
    <fullCommand>CCls colour mask</fullCommand>
    <parameters>colour mask</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CVirtualBuffers">
    <keyword>CVirtualBuffers</keyword>
    <fullCommand>CVirtualBuffers RWE PRIVATE</fullCommand>
    <parameters>RWE PRIVATE</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CTriangle">
    <keyword>CTriangle</keyword>
    <fullCommand>CTriangle &amp;pointlist,color.b</fullCommand>
    <parameters>&amp;pointlist,color.b</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CTrianglef">
    <keyword>CTrianglef</keyword>
    <fullCommand>CTrianglef &amp;pointlist,color.b</fullCommand>
    <parameters>&amp;pointlist,color.b</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RetrieveCallHook">
    <keyword>RetrieveCallHook</keyword>
    <fullCommand>RetrieveCallHook</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="QAdd">
    <keyword>QAdd</keyword>
    <fullCommand>QAdd(First,Second)</fullCommand>
    <parameters>(First,Second)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="QSub">
    <keyword>QSub</keyword>
    <fullCommand>QSub(First,Second)</fullCommand>
    <parameters>(First,Second)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="QMul020">
    <keyword>QMul020</keyword>
    <fullCommand>QMul020(First,Second)</fullCommand>
    <parameters>(First,Second)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="QDiv020">
    <keyword>QDiv020</keyword>
    <fullCommand>QDiv020(First,Second)</fullCommand>
    <parameters>(First,Second)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WWrap">
    <keyword>WWrap</keyword>
    <fullCommand>WWrap(Word,Low,High)</fullCommand>
    <parameters>(Word,Low,High)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WLimit">
    <keyword>WLimit</keyword>
    <fullCommand>WLimit(Word,Low,High)</fullCommand>
    <parameters>(Word,Low,High)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="QPlot">
    <keyword>QPlot</keyword>
    <fullCommand>QPlot Bitmap#,X,Y,Plane</fullCommand>
    <parameters>Bitmap#,X,Y,Plane</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChunkyBuffer">
    <keyword>ChunkyBuffer</keyword>
    <fullCommand>ChunkyBuffer(ChunkyBuffer#)</fullCommand>
    <parameters>(ChunkyBuffer#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChunkyBufferSize">
    <keyword>ChunkyBufferSize</keyword>
    <fullCommand>ChunkyBufferSize(ChunkyBuffer#)</fullCommand>
    <parameters>(ChunkyBuffer#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitChunkyBuffer">
    <keyword>InitChunkyBuffer</keyword>
    <fullCommand>InitChunkyBuffer ChunkyBuffer#,Bitmap#</fullCommand>
    <parameters>ChunkyBuffer#,Bitmap#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ChunkyToPlanar">
    <keyword>ChunkyToPlanar</keyword>
    <fullCommand>ChunkyToPlanar ChunkyBuffer#</fullCommand>
    <parameters>ChunkyBuffer#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ClearChunkyBuffer">
    <keyword>ClearChunkyBuffer</keyword>
    <fullCommand>ClearChunkyBuffer ChunkyBuffer#</fullCommand>
    <parameters>ChunkyBuffer#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeChunkyBuffer">
    <keyword>FreeChunkyBuffer</keyword>
    <fullCommand>FreeChunkyBuffer ChunkyBuffer#</fullCommand>
    <parameters>ChunkyBuffer#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="QCos">
    <keyword>QCos</keyword>
    <fullCommand>QCos(angle.w)</fullCommand>
    <parameters>(angle.w)</parameters>
    <shortDescription>angle(0..255)  (c) 1996 by Oliver Michel.</shortDescription>
    <longDescription />
  </command>
  <command name="QSin">
    <keyword>QSin</keyword>
    <fullCommand>QSin(angle.w)</fullCommand>
    <parameters>(angle.w)</parameters>
    <shortDescription>angle(0..255)  (c) 1996 by Oliver Michel.</shortDescription>
    <longDescription />
  </command>
  <command name="QTan">
    <keyword>QTan</keyword>
    <fullCommand>QTan(angle.w)</fullCommand>
    <parameters>(angle.w)</parameters>
    <shortDescription>angle(0..255)  (c) 1996 by Oliver Michel.</shortDescription>
    <longDescription />
  </command>
  <command name="OMc2p">
    <keyword>OMc2p</keyword>
    <fullCommand>OMc2p width.w,height.w,bplmod.w,linemod.w,chunky.l,planar.l</fullCommand>
    <parameters>width.w,height.w,bplmod.w,linemod.w,chunky.l,planar.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OMcolumn">
    <keyword>OMcolumn</keyword>
    <fullCommand>OMcolumn texture.l(64x64 v),chunky.l,scal.l</fullCommand>
    <parameters>texture.l(64x64 v),chunky.l,scal.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUI_NewObject">
    <keyword>MUI_NewObject</keyword>
    <fullCommand>MUI_NewObject(Class$,Tag[,Tag...])</fullCommand>
    <parameters>(Class$,Tag[,Tag...])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUI_MakeObject">
    <keyword>MUI_MakeObject</keyword>
    <fullCommand>MUI_MakeObject(Type,Tag[,Tag...])</fullCommand>
    <parameters>(Type,Tag[,Tag...])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUI_TRUE">
    <keyword>MUI_TRUE</keyword>
    <fullCommand>MUI_TRUE</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the TRUE value for MUI.</shortDescription>
    <longDescription />
  </command>
  <command name="MUI_Base">
    <keyword>MUI_Base</keyword>
    <fullCommand>MUI_Base</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return the Base of MUIMaster.</shortDescription>
    <longDescription />
  </command>
  <command name="HCenter">
    <keyword>HCenter</keyword>
    <fullCommand>HCenter(obj)</fullCommand>
    <parameters>(obj)</parameters>
    <shortDescription>MUI HCenter.</shortDescription>
    <longDescription />
  </command>
  <command name="VCenter">
    <keyword>VCenter</keyword>
    <fullCommand>VCenter(obj)</fullCommand>
    <parameters>(obj)</parameters>
    <shortDescription>MUI VCenter.</shortDescription>
    <longDescription />
  </command>
  <command name="MUIString">
    <keyword>MUIString</keyword>
    <fullCommand>MUIString MUIObject#,Contents$,MaxLen</fullCommand>
    <parameters>MUIObject#,Contents$,MaxLen</parameters>
    <shortDescription>MUI String.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyString">
    <keyword>KeyString</keyword>
    <fullCommand>KeyString(contents$,maxlen,controlchar$)</fullCommand>
    <parameters>(contents$,maxlen,controlchar$)</parameters>
    <shortDescription>MUI KeyString.</shortDescription>
    <longDescription />
  </command>
  <command name="CheckMark">
    <keyword>CheckMark</keyword>
    <fullCommand>CheckMark(selected)</fullCommand>
    <parameters>(selected)</parameters>
    <shortDescription>MUI CheckMark.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyCheckMark">
    <keyword>KeyCheckMark</keyword>
    <fullCommand>KeyCheckMark(selected,control$)</fullCommand>
    <parameters>(selected,control$)</parameters>
    <shortDescription>MUI KeyCheckMark.</shortDescription>
    <longDescription />
  </command>
  <command name="SimpleButton">
    <keyword>SimpleButton</keyword>
    <fullCommand>SimpleButton(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI SimpleButton.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyButton">
    <keyword>KeyButton</keyword>
    <fullCommand>KeyButton(name$,key$)</fullCommand>
    <parameters>(name$,key$)</parameters>
    <shortDescription>MUI KeyButton.</shortDescription>
    <longDescription />
  </command>
  <command name="MUI_Cycle">
    <keyword>MUI_Cycle</keyword>
    <fullCommand>MUI_Cycle(&amp;*entries(0))</fullCommand>
    <parameters>(&amp;*entries(0))</parameters>
    <shortDescription>MUI Cycle.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyCycle">
    <keyword>KeyCycle</keyword>
    <fullCommand>KeyCycle(&amp;*entries(0),key$)</fullCommand>
    <parameters>(&amp;*entries(0),key$)</parameters>
    <shortDescription>MUI KeyCycle.</shortDescription>
    <longDescription />
  </command>
  <command name="Radio">
    <keyword>Radio</keyword>
    <fullCommand>Radio(name$,&amp;*array(0))</fullCommand>
    <parameters>(name$,&amp;*array(0))</parameters>
    <shortDescription>MUI Radio.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyRadio">
    <keyword>KeyRadio</keyword>
    <fullCommand>KeyRadio(name$,&amp;*array(0),key$)</fullCommand>
    <parameters>(name$,&amp;*array(0),key$)</parameters>
    <shortDescription>MUI KeyRadio.</shortDescription>
    <longDescription />
  </command>
  <command name="Slider">
    <keyword>Slider</keyword>
    <fullCommand>Slider(min,max,level)</fullCommand>
    <parameters>(min,max,level)</parameters>
    <shortDescription>MUI Slider.</shortDescription>
    <longDescription />
  </command>
  <command name="KeySlider">
    <keyword>KeySlider</keyword>
    <fullCommand>KeySlider(min,max,level,key$)</fullCommand>
    <parameters>(min,max,level,key$)</parameters>
    <shortDescription>MUI KeySlider.</shortDescription>
    <longDescription />
  </command>
  <command name="PopButton">
    <keyword>PopButton</keyword>
    <fullCommand>PopButton(img)</fullCommand>
    <parameters>(img)</parameters>
    <shortDescription>MUI PopButton.</shortDescription>
    <longDescription />
  </command>
  <command name="Label">
    <keyword>Label</keyword>
    <fullCommand>Label(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI Label.</shortDescription>
    <longDescription />
  </command>
  <command name="LabelI">
    <keyword>LabelI</keyword>
    <fullCommand>LabelI(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI LabelI.</shortDescription>
    <longDescription />
  </command>
  <command name="LabelII">
    <keyword>LabelII</keyword>
    <fullCommand>LabelII(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI LabelII.</shortDescription>
    <longDescription />
  </command>
  <command name="LLabel">
    <keyword>LLabel</keyword>
    <fullCommand>LLabel(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI LLabel.</shortDescription>
    <longDescription />
  </command>
  <command name="LLabelI">
    <keyword>LLabelI</keyword>
    <fullCommand>LLabelI(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI LLabelI.</shortDescription>
    <longDescription />
  </command>
  <command name="LLabelII">
    <keyword>LLabelII</keyword>
    <fullCommand>LLabelII(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI LLabelII.</shortDescription>
    <longDescription />
  </command>
  <command name="CLabel">
    <keyword>CLabel</keyword>
    <fullCommand>CLabel(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI CLabel.</shortDescription>
    <longDescription />
  </command>
  <command name="CLabelI">
    <keyword>CLabelI</keyword>
    <fullCommand>CLabelI(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI CLabelI.</shortDescription>
    <longDescription />
  </command>
  <command name="CLabelII">
    <keyword>CLabelII</keyword>
    <fullCommand>CLabelII(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI CLabelII.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeLabel">
    <keyword>FreeLabel</keyword>
    <fullCommand>FreeLabel(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI FreeLabel.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeLabelI">
    <keyword>FreeLabelI</keyword>
    <fullCommand>FreeLabelI(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI FreeLabelI.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeLabelII">
    <keyword>FreeLabelII</keyword>
    <fullCommand>FreeLabelII(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI FreeLabelII.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeLLabel">
    <keyword>FreeLLabel</keyword>
    <fullCommand>FreeLLabel(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI FreeLLabel.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeLLabelI">
    <keyword>FreeLLabelI</keyword>
    <fullCommand>FreeLLabelI(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI FreeLLabelI.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeLLabelII">
    <keyword>FreeLLabelII</keyword>
    <fullCommand>FreeLLabelII(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI FreeLLabelII.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeCLabel">
    <keyword>FreeCLabel</keyword>
    <fullCommand>FreeCLabel(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI FreeCLabel.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeCLabelI">
    <keyword>FreeCLabelI</keyword>
    <fullCommand>FreeCLabelI(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI FreeCLabelI.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeCLabelII">
    <keyword>FreeCLabelII</keyword>
    <fullCommand>FreeCLabelII(label$)</fullCommand>
    <parameters>(label$)</parameters>
    <shortDescription>MUI FreeCLabelII.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyLabel">
    <keyword>KeyLabel</keyword>
    <fullCommand>KeyLabel(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI KeyLabel.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyLabelI">
    <keyword>KeyLabelI</keyword>
    <fullCommand>KeyLabelI(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI KeyLabelI.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyLabelII">
    <keyword>KeyLabelII</keyword>
    <fullCommand>KeyLabelII(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI KeyLabelII.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyLLabel">
    <keyword>KeyLLabel</keyword>
    <fullCommand>KeyLLabel(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI KeyLLabel.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyLLabelI">
    <keyword>KeyLLabelI</keyword>
    <fullCommand>KeyLLabelI(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI KeyLLabelI.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyLLabelII">
    <keyword>KeyLLabelII</keyword>
    <fullCommand>KeyLLabelII(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI KeyLLabelII.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyCLabel">
    <keyword>KeyCLabel</keyword>
    <fullCommand>KeyCLabel(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI KeyCLabel.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyCLabelI">
    <keyword>KeyCLabelI</keyword>
    <fullCommand>KeyCLabelI(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI KeyCLabelI.</shortDescription>
    <longDescription />
  </command>
  <command name="KeyCLabelII">
    <keyword>KeyCLabelII</keyword>
    <fullCommand>KeyCLabelII(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI KeyCLabelII.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeKeyLabel">
    <keyword>FreeKeyLabel</keyword>
    <fullCommand>FreeKeyLabel(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI FreeKeyLabel.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeKeyLabelI">
    <keyword>FreeKeyLabelI</keyword>
    <fullCommand>FreeKeyLabelI(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI FreeKeyLabelI.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeKeyLabelII">
    <keyword>FreeKeyLabelII</keyword>
    <fullCommand>FreeKeyLabelII(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI FreeKeyLabelII.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeKeyLLabel">
    <keyword>FreeKeyLLabel</keyword>
    <fullCommand>FreeKeyLLabel(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI FreeKeyLLabel.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeKeyLLabelI">
    <keyword>FreeKeyLLabelI</keyword>
    <fullCommand>FreeKeyLLabelI(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI FreeKeyLLabelI.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeKeyLLabelII">
    <keyword>FreeKeyLLabelII</keyword>
    <fullCommand>FreeKeyLLabelII(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI FreeKeyLLabelII.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeKeyCLabel">
    <keyword>FreeKeyCLabel</keyword>
    <fullCommand>FreeKeyCLabel(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI FreeKeyCLabel.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeKeyCLabelI">
    <keyword>FreeKeyCLabelI</keyword>
    <fullCommand>FreeKeyCLabelI(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI FreeKeyCLabelI.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeKeyCLabelII">
    <keyword>FreeKeyCLabelII</keyword>
    <fullCommand>FreeKeyCLabelII(label$,key$)</fullCommand>
    <parameters>(label$,key$)</parameters>
    <shortDescription>MUI FreeKeyCLabelII.</shortDescription>
    <longDescription />
  </command>
  <command name="MUI_get">
    <keyword>MUI_get</keyword>
    <fullCommand>MUI_get obj,attr,store</fullCommand>
    <parameters>obj,attr,store</parameters>
    <shortDescription>MUI get.</shortDescription>
    <longDescription />
  </command>
  <command name="MUI_set">
    <keyword>MUI_set</keyword>
    <fullCommand>MUI_set obj,attr,value</fullCommand>
    <parameters>obj,attr,value</parameters>
    <shortDescription>MUI set.</shortDescription>
    <longDescription />
  </command>
  <command name="nnset">
    <keyword>nnset</keyword>
    <fullCommand>nnset obj,attr,value</fullCommand>
    <parameters>obj,attr,value</parameters>
    <shortDescription>MUI nnset.</shortDescription>
    <longDescription />
  </command>
  <command name="setmutex">
    <keyword>setmutex</keyword>
    <fullCommand>setmutex obj,n</fullCommand>
    <parameters>obj,n</parameters>
    <shortDescription>MUI setmutex.</shortDescription>
    <longDescription />
  </command>
  <command name="setcycle">
    <keyword>setcycle</keyword>
    <fullCommand>setcycle obj,n</fullCommand>
    <parameters>obj,n</parameters>
    <shortDescription>MUI setcycle.</shortDescription>
    <longDescription />
  </command>
  <command name="setstring">
    <keyword>setstring</keyword>
    <fullCommand>setstring obj,s</fullCommand>
    <parameters>obj,s</parameters>
    <shortDescription>MUI setstring.</shortDescription>
    <longDescription />
  </command>
  <command name="setcheckmark">
    <keyword>setcheckmark</keyword>
    <fullCommand>setcheckmark obj,b</fullCommand>
    <parameters>obj,b</parameters>
    <shortDescription>MUI setcheckmark.</shortDescription>
    <longDescription />
  </command>
  <command name="setslider">
    <keyword>setslider</keyword>
    <fullCommand>setslider obj,l</fullCommand>
    <parameters>obj,l</parameters>
    <shortDescription>MUI setslider.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDPrefs">
    <keyword>MSDPrefs</keyword>
    <fullCommand>MSDPrefs</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Encrypted prefs file object.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDLoadPrefs">
    <keyword>MSDLoadPrefs</keyword>
    <fullCommand>MSDLoadPrefs(PrefsFile#,FileNAME$,HeaderC$[,alterarray.w])</fullCommand>
    <parameters>(PrefsFile#,FileNAME$,HeaderC$[,alterarray.w])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDSavePrefs">
    <keyword>MSDSavePrefs</keyword>
    <fullCommand>MSDSavePrefs(PrefsFile#,FileNAME$,HeaderC$)</fullCommand>
    <parameters>(PrefsFile#,FileNAME$,HeaderC$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDPushPrefs">
    <keyword>MSDPushPrefs</keyword>
    <fullCommand>MSDPushPrefs PrefsFile#,PrefsEntry.w,String$</fullCommand>
    <parameters>PrefsFile#,PrefsEntry.w,String$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDPopPrefs">
    <keyword>MSDPopPrefs</keyword>
    <fullCommand>MSDPopPrefs(PrefsFile#,PrefsEntry.w)</fullCommand>
    <parameters>(PrefsFile#,PrefsEntry.w)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDClearPrefs">
    <keyword>MSDClearPrefs</keyword>
    <fullCommand>MSDClearPrefs PrefsFile#[,onlystrings.w]</fullCommand>
    <parameters>PrefsFile#[,onlystrings.w]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDInitPrefs">
    <keyword>MSDInitPrefs</keyword>
    <fullCommand>MSDInitPrefs(PrefsFile#,Lines.w)</fullCommand>
    <parameters>(PrefsFile#,Lines.w)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDStandardHead$">
    <keyword>MSDStandardHead$</keyword>
    <fullCommand>MSDStandardHead$</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDMenuPrefHead$">
    <keyword>MSDMenuPrefHead$</keyword>
    <fullCommand>MSDMenuPrefHead$</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDMenuScriptHead$">
    <keyword>MSDMenuScriptHead$</keyword>
    <fullCommand>MSDMenuScriptHead$</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDDecodePrefs">
    <keyword>MSDDecodePrefs</keyword>
    <fullCommand>MSDDecodePrefs(PrefsFile#,Address.l,BlockLength.l,HeaderC$[,alterarray.w])</fullCommand>
    <parameters>(PrefsFile#,Address.l,BlockLength.l,HeaderC$[,alterarray.w])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDTimer">
    <keyword>MSDTimer</keyword>
    <fullCommand>MSDTimer A MultiTimer Object</fullCommand>
    <parameters>A MultiTimer Object</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDPoint">
    <keyword>MSDPoint</keyword>
    <fullCommand>MSDPoint(x.w,y.w)</fullCommand>
    <parameters>(x.w,y.w)</parameters>
    <shortDescription>Returns colour of pixel at x,y.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDPixel">
    <keyword>MSDPixel</keyword>
    <fullCommand>MSDPixel(x.w,y.w)</fullCommand>
    <parameters>(x.w,y.w)</parameters>
    <shortDescription>Returns &lt;&gt;0 if non-zero pixel at x,y.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDEraseBlit">
    <keyword>MSDEraseBlit</keyword>
    <fullCommand>MSDEraseBlit Shape#,x.w,y.w</fullCommand>
    <parameters>Shape#,x.w,y.w</parameters>
    <shortDescription>Erase an area of graphics the same shape as the shape.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDPlot">
    <keyword>MSDPlot</keyword>
    <fullCommand>MSDPlot x.w,y.w,colour.w</fullCommand>
    <parameters>x.w,y.w,colour.w</parameters>
    <shortDescription>Draw pixel of colour at x,y.</shortDescription>
    <longDescription />
  </command>
  <command name="InterleaveShape">
    <keyword>InterleaveShape</keyword>
    <fullCommand>InterleaveShape oldshape.w,newshape.w</fullCommand>
    <parameters>oldshape.w,newshape.w</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDPlotTable">
    <keyword>MSDPlotTable</keyword>
    <fullCommand>MSDPlotTable *table</fullCommand>
    <parameters>*table</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDPeekLen$">
    <keyword>MSDPeekLen$</keyword>
    <fullCommand>MSDPeekLen$(Address.l,Length.l)</fullCommand>
    <parameters>(Address.l,Length.l)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDRoundDown">
    <keyword>MSDRoundDown</keyword>
    <fullCommand>MSDRoundDown(Number.w,Closest.w)</fullCommand>
    <parameters>(Number.w,Closest.w)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDRound">
    <keyword>MSDRound</keyword>
    <fullCommand>MSDRound(Number.w,Closest.w)</fullCommand>
    <parameters>(Number.w,Closest.w)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDRoundUp">
    <keyword>MSDRoundUp</keyword>
    <fullCommand>MSDRoundUp(Number.w,Closest.w)</fullCommand>
    <parameters>(Number.w,Closest.w)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InterleaveBitMap">
    <keyword>InterleaveBitMap</keyword>
    <fullCommand>InterleaveBitMap oldbitmap.w,newbitmap.w</fullCommand>
    <parameters>oldbitmap.w,newbitmap.w</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSD32BitCipher">
    <keyword>MSD32BitCipher</keyword>
    <fullCommand>MSD32BitCipher *StartAddress,ByteSize</fullCommand>
    <parameters>*StartAddress,ByteSize</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSD32BitCipherOLD">
    <keyword>MSD32BitCipherOLD</keyword>
    <fullCommand>MSD32BitCipherOLD *StartAddress,ByteSize</fullCommand>
    <parameters>*StartAddress,ByteSize</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDKeyBase">
    <keyword>MSDKeyBase</keyword>
    <fullCommand>MSDKeyBase</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDResetKeys">
    <keyword>MSDResetKeys</keyword>
    <fullCommand>MSDResetKeys</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDSet32BitKey">
    <keyword>MSDSet32BitKey</keyword>
    <fullCommand>MSDSet32BitKey Key,Value</fullCommand>
    <parameters>Key,Value</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDGenerateKeys">
    <keyword>MSDGenerateKeys</keyword>
    <fullCommand>MSDGenerateKeys Key,Key,Key,Key</fullCommand>
    <parameters>Key,Key,Key,Key</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDSaveKey">
    <keyword>MSDSaveKey</keyword>
    <fullCommand>MSDSaveKey FileName$</fullCommand>
    <parameters>FileName$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDLoadKey">
    <keyword>MSDLoadKey</keyword>
    <fullCommand>MSDLoadKey FileName$</fullCommand>
    <parameters>FileName$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDRandomize">
    <keyword>MSDRandomize</keyword>
    <fullCommand>MSDRandomize Seed,Seed</fullCommand>
    <parameters>Seed,Seed</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDLongWrap">
    <keyword>MSDLongWrap</keyword>
    <fullCommand>MSDLongWrap(Number,Low,High)</fullCommand>
    <parameters>(Number,Low,High)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDRnd">
    <keyword>MSDRnd</keyword>
    <fullCommand>MSDRnd(Low,High)</fullCommand>
    <parameters>(Low,High)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDQModulus">
    <keyword>MSDQModulus</keyword>
    <fullCommand>MSDQModulus(Numerator.q,Denominator)</fullCommand>
    <parameters>(Numerator.q,Denominator)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDTimerReset">
    <keyword>MSDTimerReset</keyword>
    <fullCommand>MSDTimerReset MSDTimerEvent#</fullCommand>
    <parameters>MSDTimerEvent#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDTimerTicks">
    <keyword>MSDTimerTicks</keyword>
    <fullCommand>MSDTimerTicks(MSDTimerEvent#)</fullCommand>
    <parameters>(MSDTimerEvent#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDTimerSecs">
    <keyword>MSDTimerSecs</keyword>
    <fullCommand>MSDTimerSecs(MSDTimerEvent#,Rate)</fullCommand>
    <parameters>(MSDTimerEvent#,Rate)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDGetTimer">
    <keyword>MSDGetTimer</keyword>
    <fullCommand>MSDGetTimer(MSDTimerEvent#)</fullCommand>
    <parameters>(MSDTimerEvent#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDSetTimer">
    <keyword>MSDSetTimer</keyword>
    <fullCommand>MSDSetTimer MSDTimerEvent#,Value</fullCommand>
    <parameters>MSDTimerEvent#,Value</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDFindTimer">
    <keyword>MSDFindTimer</keyword>
    <fullCommand>MSDFindTimer</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDInitTimer">
    <keyword>MSDInitTimer</keyword>
    <fullCommand>MSDInitTimer</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ILCludgeBitMap">
    <keyword>ILCludgeBitMap</keyword>
    <fullCommand>ILCludgeBitMap BitMap#,Width.w,Height.w,Depth.w,Memory.l</fullCommand>
    <parameters>BitMap#,Width.w,Height.w,Depth.w,Memory.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDQuickWrap">
    <keyword>MSDQuickWrap</keyword>
    <fullCommand>MSDQuickWrap(Number.q,Low.q,High.q)</fullCommand>
    <parameters>(Number.q,Low.q,High.q)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDQRoundDown">
    <keyword>MSDQRoundDown</keyword>
    <fullCommand>MSDQRoundDown(Number.q,Closest.q)</fullCommand>
    <parameters>(Number.q,Closest.q)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDQRound">
    <keyword>MSDQRound</keyword>
    <fullCommand>MSDQRound(Number.q,Closest.q)</fullCommand>
    <parameters>(Number.q,Closest.q)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDQRoundUp">
    <keyword>MSDQRoundUp</keyword>
    <fullCommand>MSDQRoundUp(Number.q,Closest.q)</fullCommand>
    <parameters>(Number.q,Closest.q)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDReadMice">
    <keyword>MSDReadMice</keyword>
    <fullCommand>MSDReadMice</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDReadMouse">
    <keyword>MSDReadMouse</keyword>
    <fullCommand>MSDReadMouse [Port.w]</fullCommand>
    <parameters>[Port.w]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDMouse">
    <keyword>MSDMouse</keyword>
    <fullCommand>MSDMouse OnOff.b[,Port.w]</fullCommand>
    <parameters>OnOff.b[,Port.w]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDMouseArea">
    <keyword>MSDMouseArea</keyword>
    <fullCommand>MSDMouseArea MinX.w,MinY.w,MaxX.w,MaxY.w[Port.w]</fullCommand>
    <parameters>MinX.w,MinY.w,MaxX.w,MaxY.w[Port.w]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDMouseX">
    <keyword>MSDMouseX</keyword>
    <fullCommand>MSDMouseX [(Port.w)]</fullCommand>
    <parameters>[(Port.w)]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDMouseXSpeed">
    <keyword>MSDMouseXSpeed</keyword>
    <fullCommand>MSDMouseXSpeed [(Port.w)]</fullCommand>
    <parameters>[(Port.w)]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDMouseY">
    <keyword>MSDMouseY</keyword>
    <fullCommand>MSDMouseY [(Port.w)]</fullCommand>
    <parameters>[(Port.w)]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDMouseYSpeed">
    <keyword>MSDMouseYSpeed</keyword>
    <fullCommand>MSDMouseYSpeed [(Port.w)]</fullCommand>
    <parameters>[(Port.w)]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDJoyB">
    <keyword>MSDJoyB</keyword>
    <fullCommand>MSDJoyB(Port.w)</fullCommand>
    <parameters>(Port.w)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MSDCreateBuffers">
    <keyword>MSDCreateBuffers</keyword>
    <fullCommand>MSDCreateBuffers(NumBuffers.w)</fullCommand>
    <parameters>(NumBuffers.w)</parameters>
    <shortDescription>Allocate array to store buffer info.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDBuffer">
    <keyword>MSDBuffer</keyword>
    <fullCommand>MSDBuffer(buffer.w,NumPlots.w)</fullCommand>
    <parameters>(buffer.w,NumPlots.w)</parameters>
    <shortDescription>Create space in buffer for number of plots.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDBPlot">
    <keyword>MSDBPlot</keyword>
    <fullCommand>MSDBPlot buffer.w,x.w,y.w,color.w</fullCommand>
    <parameters>buffer.w,x.w,y.w,color.w</parameters>
    <shortDescription>Buffered plot to current bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDUnbuffer">
    <keyword>MSDUnbuffer</keyword>
    <fullCommand>MSDUnbuffer buffer.w</fullCommand>
    <parameters>buffer.w</parameters>
    <shortDescription>Replace previous pixels under BPlotted pixels.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDFlushBuffer">
    <keyword>MSDFlushBuffer</keyword>
    <fullCommand>MSDFlushBuffer buffer.w</fullCommand>
    <parameters>buffer.w</parameters>
    <shortDescription>Discards all pixels in specified buffer.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDFreeBuffers">
    <keyword>MSDFreeBuffers</keyword>
    <fullCommand>MSDFreeBuffers [buffer.w]</fullCommand>
    <parameters>[buffer.w]</parameters>
    <shortDescription>Free all buffers and base array or specified buffer.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDBufferSpace">
    <keyword>MSDBufferSpace</keyword>
    <fullCommand>MSDBufferSpace(buffer.w)</fullCommand>
    <parameters>(buffer.w)</parameters>
    <shortDescription>returns how many more BPlots can be done on this buffer.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDHLine">
    <keyword>MSDHLine</keyword>
    <fullCommand>MSDHLine x.w,y.w,width.w,color.w</fullCommand>
    <parameters>x.w,y.w,width.w,color.w</parameters>
    <shortDescription>draw horizontal line.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDBoxF">
    <keyword>MSDBoxF</keyword>
    <fullCommand>MSDBoxF x.w,y.w,width.w,height.w,color.w</fullCommand>
    <parameters>x.w,y.w,width.w,height.w,color.w</parameters>
    <shortDescription>draw a filled box.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDVLine">
    <keyword>MSDVLine</keyword>
    <fullCommand>MSDVLine x.w,y.w,height.w,color.w</fullCommand>
    <parameters>x.w,y.w,height.w,color.w</parameters>
    <shortDescription>draw vertical line.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDZeroBlit">
    <keyword>MSDZeroBlit</keyword>
    <fullCommand>MSDZeroBlit shape#,x.w,y.w</fullCommand>
    <parameters>shape#,x.w,y.w</parameters>
    <shortDescription>blit shape onto color 0 only.</shortDescription>
    <longDescription />
  </command>
  <command name="QMult">
    <keyword>QMult</keyword>
    <fullCommand>QMult(num1.q, num2.q)</fullCommand>
    <parameters>(num1.q, num2.q)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="QDiv">
    <keyword>QDiv</keyword>
    <fullCommand>QDiv(num.q,den.q)</fullCommand>
    <parameters>(num.q,den.q)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BBlitInit">
    <keyword>BBlitInit</keyword>
    <fullCommand>BBlitInit(NumBuffers.w)</fullCommand>
    <parameters>(NumBuffers.w)</parameters>
    <shortDescription>Allocate array to store buffer info.</shortDescription>
    <longDescription />
  </command>
  <command name="BBlitBuffer">
    <keyword>BBlitBuffer</keyword>
    <fullCommand>BBlitBuffer(buffer.w,MemSize.l)</fullCommand>
    <parameters>(buffer.w,MemSize.l)</parameters>
    <shortDescription>Create space in buffer for bblits.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDBBlit">
    <keyword>MSDBBlit</keyword>
    <fullCommand>MSDBBlit buffer.w,Shape#,x.w,y.w</fullCommand>
    <parameters>buffer.w,Shape#,x.w,y.w</parameters>
    <shortDescription>Buffered blit to current bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="BBlitUnbuffer">
    <keyword>BBlitUnbuffer</keyword>
    <fullCommand>BBlitUnbuffer buffer.w</fullCommand>
    <parameters>buffer.w</parameters>
    <shortDescription>Replace previous graphics under MSDBBlit'ted shapes.</shortDescription>
    <longDescription />
  </command>
  <command name="BBlitFlush">
    <keyword>BBlitFlush</keyword>
    <fullCommand>BBlitFlush buffer.w</fullCommand>
    <parameters>buffer.w</parameters>
    <shortDescription>Discards all data in specified buffer.</shortDescription>
    <longDescription />
  </command>
  <command name="BBlitFree">
    <keyword>BBlitFree</keyword>
    <fullCommand>BBlitFree [buffer.w]</fullCommand>
    <parameters>[buffer.w]</parameters>
    <shortDescription>Free all buffers and base array/specified buffer.</shortDescription>
    <longDescription />
  </command>
  <command name="BBlitSpace">
    <keyword>BBlitSpace</keyword>
    <fullCommand>BBlitSpace(buffer.w)</fullCommand>
    <parameters>(buffer.w)</parameters>
    <shortDescription>returns how much free memory is in this buffer.</shortDescription>
    <longDescription />
  </command>
  <command name="MSDBlit">
    <keyword>MSDBlit</keyword>
    <fullCommand>MSDBlit Shape#,x.w,y.w</fullCommand>
    <parameters>Shape#,x.w,y.w</parameters>
    <shortDescription>Blit shape to current bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2pRowLacing">
    <keyword>MMc2pRowLacing</keyword>
    <fullCommand>MMc2pRowLacing State.b</fullCommand>
    <parameters>State.b</parameters>
    <shortDescription>Toggle row-lacing in c2p On/Off. NonZero=On.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2pColumnLacing">
    <keyword>MMc2pColumnLacing</keyword>
    <fullCommand>MMc2pColumnLacing State.b</fullCommand>
    <parameters>State.b</parameters>
    <shortDescription>Toggle column-lacing in c2p On/Off.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2pRowToggle">
    <keyword>MMc2pRowToggle</keyword>
    <fullCommand>MMc2pRowToggle</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Toggle c2p row lacing between Even/Odd rows.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2pColumnToggle">
    <keyword>MMc2pColumnToggle</keyword>
    <fullCommand>MMc2pColumnToggle</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Toggle c2p column lacing between Even/Odd columns.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2pToggleSingle">
    <keyword>MMc2pToggleSingle</keyword>
    <fullCommand>MMc2pToggleSingle</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Toggle c2p lacing for single-buffered display.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2pToggleDouble">
    <keyword>MMc2pToggleDouble</keyword>
    <fullCommand>MMc2pToggleDouble Buf.b</fullCommand>
    <parameters>Buf.b</parameters>
    <shortDescription>0 or 1. Toggle c2p lacing for double-buffered display.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2pToggleTriple">
    <keyword>MMc2pToggleTriple</keyword>
    <fullCommand>MMc2pToggleTriple Buf.b</fullCommand>
    <parameters>Buf.b</parameters>
    <shortDescription>0, 1 or 2. Toggle c2p lacing for triple-buffered display.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2pToggle">
    <keyword>MMc2pToggle</keyword>
    <fullCommand>MMc2pToggle Buffers.b,Buf.b</fullCommand>
    <parameters>Buffers.b,Buf.b</parameters>
    <shortDescription>1, 2 or 3, and 0, 1 or 2. Toggle c2p lacing.</shortDescription>
    <longDescription />
  </command>
  <command name="MM040c2pUsage">
    <keyword>MM040c2pUsage</keyword>
    <fullCommand>MM040c2pUsage Status.b</fullCommand>
    <parameters>Status.b</parameters>
    <shortDescription>On/Off - Availability of 040 c2p. Overrides Mc2pCPUmode.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2pCPUmode">
    <keyword>MMc2pCPUmode</keyword>
    <fullCommand>MMc2pCPUmode CPU.b</fullCommand>
    <parameters>CPU.b</parameters>
    <shortDescription>Set cpu c2p uses. Use Blitz's `Processor'. &lt;4=030-, 4=040+.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2pWindow">
    <keyword>MMc2pWindow</keyword>
    <fullCommand>MMc2pWindow c2pWindow#.w,OpWidth.w,OpHeight.w[,SourceBWidth.w[,Processor.b],PlanarWidth.w,PlanarHeight.w]</fullCommand>
    <parameters>c2pWindow#.w,OpWidth.w,OpHeight.w[,SourceBWidth.w[,Processor.b],PlanarWidth.w,PlanarHeight.w]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MMc2pWindowWidth">
    <keyword>MMc2pWindowWidth</keyword>
    <fullCommand>MMc2pWindowWidth(c2pWindowNumber.w)</fullCommand>
    <parameters>(c2pWindowNumber.w)</parameters>
    <shortDescription>Returns width of c2pWindow.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2pWindowHeight">
    <keyword>MMc2pWindowHeight</keyword>
    <fullCommand>MMc2pWindowHeight(c2pWindowNumber.w)</fullCommand>
    <parameters>(c2pWindowNumber.w)</parameters>
    <shortDescription>Returns height of c2pWindow.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2pWindowNewHeight">
    <keyword>MMc2pWindowNewHeight</keyword>
    <fullCommand>MMc2pWindowNewHeight c2pWindow#.w,NewHeight.w</fullCommand>
    <parameters>c2pWindow#.w,NewHeight.w</parameters>
    <shortDescription>Change height of already defined c2p object.</shortDescription>
    <longDescription />
  </command>
  <command name="MMc2p">
    <keyword>MMc2p</keyword>
    <fullCommand>MMc2p c2pWindow#.w,Chunky.l,Planar.l</fullCommand>
    <parameters>c2pWindow#.w,Chunky.l,Planar.l</parameters>
    <shortDescription>Convert chunky to planar (Use Mc2pWindow first).</shortDescription>
    <longDescription />
  </command>
  <command name="MMReservec2pWindows">
    <keyword>MMReservec2pWindows</keyword>
    <fullCommand>MMReservec2pWindows [(]NumberOfWindows.w[)]</fullCommand>
    <parameters>[(]NumberOfWindows.w[)]</parameters>
    <shortDescription>Reserve structure-memory for c2pWindows.</shortDescription>
    <longDescription />
  </command>
  <command name="MMFreec2pWindows">
    <keyword>MMFreec2pWindows</keyword>
    <fullCommand>MMFreec2pWindows [Firstc2pWindow.w,Lastc2pWindow.w]</fullCommand>
    <parameters>[Firstc2pWindow.w,Lastc2pWindow.w]</parameters>
    <shortDescription>Free/delete all/range of c2pwindows.</shortDescription>
    <longDescription />
  </command>
  <command name="MMFreec2pWindow">
    <keyword>MMFreec2pWindow</keyword>
    <fullCommand>MMFreec2pWindow Free/delete a pre-existing c2pWindow</fullCommand>
    <parameters>Free/delete a pre-existing c2pWindow</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MMAddrc2pWindow">
    <keyword>MMAddrc2pWindow</keyword>
    <fullCommand>MMAddrc2pWindow(c2pWindowNumer.w}</fullCommand>
    <parameters>(c2pWindowNumer.w}</parameters>
    <shortDescription>Returns address of c2pWindow structure.</shortDescription>
    <longDescription />
  </command>
  <command name="MMUsec2pWindows">
    <keyword>MMUsec2pWindows</keyword>
    <fullCommand>MMUsec2pWindows Mainc2pWindowNum.w[,Secondc2pWindowNum.w[,Thirdc2pWindowNum.w]]</fullCommand>
    <parameters>Mainc2pWindowNum.w[,Secondc2pWindowNum.w[,Thirdc2pWindowNum.w]]</parameters>
    <shortDescription>Current to use.</shortDescription>
    <longDescription />
  </command>
  <command name="MMUsec2pWindow">
    <keyword>MMUsec2pWindow</keyword>
    <fullCommand>MMUsec2pWindow c2pWindowNumber.w</fullCommand>
    <parameters>c2pWindowNumber.w</parameters>
    <shortDescription>Current to use.</shortDescription>
    <longDescription />
  </command>
  <command name="MMUsedc2pWindow">
    <keyword>MMUsedc2pWindow</keyword>
    <fullCommand>MMUsedc2pWindow</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns currently used c2pWindow.</shortDescription>
    <longDescription />
  </command>
  <command name="MMAutoUsec2pWindows">
    <keyword>MMAutoUsec2pWindows</keyword>
    <fullCommand>MMAutoUsec2pWindows True/False</fullCommand>
    <parameters>True/False</parameters>
    <shortDescription>Automatically `use' new c2pWindows. &lt;&gt;0=True.</shortDescription>
    <longDescription />
  </command>
  <command name="MMCopyc2pWindow">
    <keyword>MMCopyc2pWindow</keyword>
    <fullCommand>MMCopyc2pWindow Sourcec2pWindow.w,Destc2pWindow.w</fullCommand>
    <parameters>Sourcec2pWindow.w,Destc2pWindow.w</parameters>
    <shortDescription>Copy definition-data only.</shortDescription>
    <longDescription />
  </command>
  <command name="MMGenericPtr">
    <keyword>MMGenericPtr</keyword>
    <fullCommand>MMGenericPtr Xpos.w,Ypos.w,BaseAddress.l,RowWidth.w</fullCommand>
    <parameters>Xpos.w,Ypos.w,BaseAddress.l,RowWidth.w</parameters>
    <shortDescription>Calculate and return address based on inputs.</shortDescription>
    <longDescription />
  </command>
  <command name="MWrapXParticles">
    <keyword>MWrapXParticles</keyword>
    <fullCommand>MWrapXParticles CoordinateList.l,NumPoints.l</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l</parameters>
    <shortDescription>Bring particles in from left/right edges (Not Ptr.l).</shortDescription>
    <longDescription />
  </command>
  <command name="MWrapYParticles">
    <keyword>MWrapYParticles</keyword>
    <fullCommand>MWrapYParticles CoordinateList.l,NumPoints.l</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l</parameters>
    <shortDescription>Bring particles in from top/bottom edges.</shortDescription>
    <longDescription />
  </command>
  <command name="MAddToXParticles">
    <keyword>MAddToXParticles</keyword>
    <fullCommand>MAddToXParticles CoordinateList.l,NumPoints.l,IncA.l[,IncB.l]</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l,IncA.l[,IncB.l]</parameters>
    <shortDescription>Add X components of [two sets of] increments.</shortDescription>
    <longDescription />
  </command>
  <command name="MAddToYParticles">
    <keyword>MAddToYParticles</keyword>
    <fullCommand>MAddToYParticles CoordinateList.l,NumPoints.l,IncA.l[,IncB.l]</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l,IncA.l[,IncB.l]</parameters>
    <shortDescription>Add Y components of [two sets of] increments.</shortDescription>
    <longDescription />
  </command>
  <command name="MAddMode">
    <keyword>MAddMode</keyword>
    <fullCommand>MAddMode</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns value 7 which represents `add' mode in the blit modes.</shortDescription>
    <longDescription />
  </command>
  <command name="Mc2pCPUmode">
    <keyword>Mc2pCPUmode</keyword>
    <fullCommand>Mc2pCPUmode CPU.b</fullCommand>
    <parameters>CPU.b</parameters>
    <shortDescription>Set cpu c2p uses. Use `MProcessor' or `Processor'. &lt;4=030-, &gt;3=040+.</shortDescription>
    <longDescription />
  </command>
  <command name="Mc2pWindow">
    <keyword>Mc2pWindow</keyword>
    <fullCommand>Mc2pWindow c2pWindow#.w,OpWidth.w,OpHeight.w[,SourceBWidth.w[,Processor.b],PlanarWidth.w,PlanarHeight.w]</fullCommand>
    <parameters>c2pWindow#.w,OpWidth.w,OpHeight.w[,SourceBWidth.w[,Processor.b],PlanarWidth.w,PlanarHeight.w]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Mc2pWindowWidth">
    <keyword>Mc2pWindowWidth</keyword>
    <fullCommand>Mc2pWindowWidth [(c2pWindowNumber.w)]</fullCommand>
    <parameters>[(c2pWindowNumber.w)]</parameters>
    <shortDescription>Returns width of c2pWindow.</shortDescription>
    <longDescription />
  </command>
  <command name="Mc2pWindowHeight">
    <keyword>Mc2pWindowHeight</keyword>
    <fullCommand>Mc2pWindowHeight [(c2pWindowNumber.w)]</fullCommand>
    <parameters>[(c2pWindowNumber.w)]</parameters>
    <shortDescription>Returns height of c2pWindow.</shortDescription>
    <longDescription />
  </command>
  <command name="Mc2pWindowNewHeight">
    <keyword>Mc2pWindowNewHeight</keyword>
    <fullCommand>Mc2pWindowNewHeight c2pWindow#.w,NewHeight.w</fullCommand>
    <parameters>c2pWindow#.w,NewHeight.w</parameters>
    <shortDescription>Change height of already defined c2p object.</shortDescription>
    <longDescription />
  </command>
  <command name="Mc2p">
    <keyword>Mc2p</keyword>
    <fullCommand>Mc2p [[c2pWindow#.w],Chunky.l],Planar.l</fullCommand>
    <parameters>[[c2pWindow#.w],Chunky.l],Planar.l</parameters>
    <shortDescription>Convert chunky to planar (Use Mc2pWindow first).</shortDescription>
    <longDescription />
  </command>
  <command name="MReservec2pWindows">
    <keyword>MReservec2pWindows</keyword>
    <fullCommand>MReservec2pWindows [(]NumberOfWindows.w[)]</fullCommand>
    <parameters>[(]NumberOfWindows.w[)]</parameters>
    <shortDescription>Reserve structure-memory for c2pWindows.</shortDescription>
    <longDescription />
  </command>
  <command name="MReserveShapes">
    <keyword>MReserveShapes</keyword>
    <fullCommand>MReserveShapes [(]NumberOfShapes.w[,ShapeBankToUse.w][)]</fullCommand>
    <parameters>[(]NumberOfShapes.w[,ShapeBankToUse.w][)]</parameters>
    <shortDescription>Reserve structure-memory for Shapes.</shortDescription>
    <longDescription />
  </command>
  <command name="MReserveBitmaps">
    <keyword>MReserveBitmaps</keyword>
    <fullCommand>MReserveBitmaps [(]NumberOfBitmaps.w[)]</fullCommand>
    <parameters>[(]NumberOfBitmaps.w[)]</parameters>
    <shortDescription>Reserve structure-memory for Bitmaps.</shortDescription>
    <longDescription />
  </command>
  <command name="MShape">
    <keyword>MShape</keyword>
    <fullCommand>MShape [(]ShapeNumber.w,Width.w,Height.w[)]</fullCommand>
    <parameters>[(]ShapeNumber.w,Width.w,Height.w[)]</parameters>
    <shortDescription>Allocmem for shape data.</shortDescription>
    <longDescription />
  </command>
  <command name="MBitmap">
    <keyword>MBitmap</keyword>
    <fullCommand>MBitmap [(]BitmapNumber.w,Width.w,Height.w[)]</fullCommand>
    <parameters>[(]BitmapNumber.w,Width.w,Height.w[)]</parameters>
    <shortDescription>Allocmem for bitmap data.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoCookie">
    <keyword>MAutoCookie</keyword>
    <fullCommand>MAutoCookie On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>Autocreation of ByteForByte cookies.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoStencil">
    <keyword>MAutoStencil</keyword>
    <fullCommand>MAutoStencil On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>Autocreation of ByteForByte stencils.</shortDescription>
    <longDescription />
  </command>
  <command name="MFreec2pWindow">
    <keyword>MFreec2pWindow</keyword>
    <fullCommand>MFreec2pWindow [Firstc2pWindow.w[,Lastc2pWindow.w]]</fullCommand>
    <parameters>[Firstc2pWindow.w[,Lastc2pWindow.w]]</parameters>
    <shortDescription>Free a c2pWindow, range of c2pWindows or all c2pWindows.</shortDescription>
    <longDescription />
  </command>
  <command name="MFreeShape">
    <keyword>MFreeShape</keyword>
    <fullCommand>MFreeShape [FirstShape.w[,LastShape.w]]</fullCommand>
    <parameters>[FirstShape.w[,LastShape.w]]</parameters>
    <shortDescription>Free a Shape, range of shapes, or all shapes.</shortDescription>
    <longDescription />
  </command>
  <command name="MFreeBitmap">
    <keyword>MFreeBitmap</keyword>
    <fullCommand>MFreeBitmap [FirstBitmap.w[,LastBitmap.w]]</fullCommand>
    <parameters>[FirstBitmap.w[,LastBitmap.w]]</parameters>
    <shortDescription>Free a Bitmap, range of bitmaps, or all bitmaps.</shortDescription>
    <longDescription />
  </command>
  <command name="MShapeWidth">
    <keyword>MShapeWidth</keyword>
    <fullCommand>MShapeWidth [(ShapeNumber.w)]</fullCommand>
    <parameters>[(ShapeNumber.w)]</parameters>
    <shortDescription>Returns width of Shape.</shortDescription>
    <longDescription />
  </command>
  <command name="MBitmapWidth">
    <keyword>MBitmapWidth</keyword>
    <fullCommand>MBitmapWidth [(BitmapNumber.w)]</fullCommand>
    <parameters>[(BitmapNumber.w)]</parameters>
    <shortDescription>Returns width of Bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MShapeHeight">
    <keyword>MShapeHeight</keyword>
    <fullCommand>MShapeHeight [(ShapeNumber.w)]</fullCommand>
    <parameters>[(ShapeNumber.w)]</parameters>
    <shortDescription>Returns height of Shape.</shortDescription>
    <longDescription />
  </command>
  <command name="MBitmapHeight">
    <keyword>MBitmapHeight</keyword>
    <fullCommand>MBitmapHeight [(BitmapNumber.w)]</fullCommand>
    <parameters>[(BitmapNumber.w)]</parameters>
    <shortDescription>Returns height of Bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MAddrc2pWindow">
    <keyword>MAddrc2pWindow</keyword>
    <fullCommand>MAddrc2pWindow [(c2pWindowNumer.w)]</fullCommand>
    <parameters>[(c2pWindowNumer.w)]</parameters>
    <shortDescription>Returns address of c2pWindow structure.</shortDescription>
    <longDescription />
  </command>
  <command name="MAddrShape">
    <keyword>MAddrShape</keyword>
    <fullCommand>MAddrShape [(ShapeNumber.w)]</fullCommand>
    <parameters>[(ShapeNumber.w)]</parameters>
    <shortDescription>Returns address of Shape structure.</shortDescription>
    <longDescription />
  </command>
  <command name="MAddrBitmap">
    <keyword>MAddrBitmap</keyword>
    <fullCommand>MAddrBitmap [(BitmapNumber.w)]</fullCommand>
    <parameters>[(BitmapNumber.w)]</parameters>
    <shortDescription>Returns address of Bitmap structure.</shortDescription>
    <longDescription />
  </command>
  <command name="MHandle">
    <keyword>MHandle</keyword>
    <fullCommand>MHandle ShapeNumber.w,XOffset.w,YOffset.w</fullCommand>
    <parameters>ShapeNumber.w,XOffset.w,YOffset.w</parameters>
    <shortDescription>Set handle of Shape.</shortDescription>
    <longDescription />
  </command>
  <command name="MBitmapOrigin">
    <keyword>MBitmapOrigin</keyword>
    <fullCommand>MBitmapOrigin BitmapNumber.w,XOffset.w,YOffset.w</fullCommand>
    <parameters>BitmapNumber.w,XOffset.w,YOffset.w</parameters>
    <shortDescription>Set origin of Bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MUsec2pWindow">
    <keyword>MUsec2pWindow</keyword>
    <fullCommand>MUsec2pWindow Mainc2pWindowNum.w[,Secondc2pWindowNum.w[,Thirdc2pWindowNum.w]]</fullCommand>
    <parameters>Mainc2pWindowNum.w[,Secondc2pWindowNum.w[,Thirdc2pWindowNum.w]]</parameters>
    <shortDescription>Current to use.</shortDescription>
    <longDescription />
  </command>
  <command name="MUseShape">
    <keyword>MUseShape</keyword>
    <fullCommand>MUseShape MainShapeNum.w[,SecondShapeNum.w[,ThirdShapeNum.w]]</fullCommand>
    <parameters>MainShapeNum.w[,SecondShapeNum.w[,ThirdShapeNum.w]]</parameters>
    <shortDescription>Current Shape(s) to use.</shortDescription>
    <longDescription />
  </command>
  <command name="MUseBitmap">
    <keyword>MUseBitmap</keyword>
    <fullCommand>MUseBitmap MainBitmapNum.w[,SecondBitmapNum.w[,ThirdBitmapNum.w]]</fullCommand>
    <parameters>MainBitmapNum.w[,SecondBitmapNum.w[,ThirdBitmapNum.w]]</parameters>
    <shortDescription>Current Bitmap(s) to use.</shortDescription>
    <longDescription />
  </command>
  <command name="MUsedc2pWindow">
    <keyword>MUsedc2pWindow</keyword>
    <fullCommand>MUsedc2pWindow</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns currently used c2pWindow.</shortDescription>
    <longDescription />
  </command>
  <command name="MUsedShape">
    <keyword>MUsedShape</keyword>
    <fullCommand>MUsedShape</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns currently used Shape.</shortDescription>
    <longDescription />
  </command>
  <command name="MUsedBitmap">
    <keyword>MUsedBitmap</keyword>
    <fullCommand>MUsedBitmap</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns currently used Bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MCludgeShape">
    <keyword>MCludgeShape</keyword>
    <fullCommand>MCludgeShape ShapeNumber.w,Width.w,Height.w,Memory.l</fullCommand>
    <parameters>ShapeNumber.w,Width.w,Height.w,Memory.l</parameters>
    <shortDescription>Cludge shape from existing mem.</shortDescription>
    <longDescription />
  </command>
  <command name="MCludgeBitmap">
    <keyword>MCludgeBitmap</keyword>
    <fullCommand>MCludgeBitmap BitmapNumber.w,Width.w,Height.w,Memory.l</fullCommand>
    <parameters>BitmapNumber.w,Width.w,Height.w,Memory.l</parameters>
    <shortDescription>Cludge bitmap from existing mem.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoUsec2pWindows">
    <keyword>MAutoUsec2pWindows</keyword>
    <fullCommand>MAutoUsec2pWindows True/False</fullCommand>
    <parameters>True/False</parameters>
    <shortDescription>Automatically `use' new c2pWindows. &lt;&gt;0=True.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoUseShapes">
    <keyword>MAutoUseShapes</keyword>
    <fullCommand>MAutoUseShapes True/False</fullCommand>
    <parameters>True/False</parameters>
    <shortDescription>Automatically `use' new shapes. &lt;&gt;0=True.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoUseBitmaps">
    <keyword>MAutoUseBitmaps</keyword>
    <fullCommand>MAutoUseBitmaps True/False</fullCommand>
    <parameters>True/False</parameters>
    <shortDescription>Automatically `use' new bitmaps. &lt;&gt;0=True.</shortDescription>
    <longDescription />
  </command>
  <command name="MMakeCookie">
    <keyword>MMakeCookie</keyword>
    <fullCommand>MMakeCookie [FirstShape.w[,LastShape.w]]</fullCommand>
    <parameters>[FirstShape.w[,LastShape.w]]</parameters>
    <shortDescription>Make a cookie for a shape, range of shapes, or all shapes.</shortDescription>
    <longDescription />
  </command>
  <command name="MMakeStencil">
    <keyword>MMakeStencil</keyword>
    <fullCommand>MMakeStencil [FirstBitmap.w[,LastBitmap.w]]</fullCommand>
    <parameters>[FirstBitmap.w[,LastBitmap.w]]</parameters>
    <shortDescription>Make a stencil for a bitmap, range of bitmaps, or all bitmaps.</shortDescription>
    <longDescription />
  </command>
  <command name="MFreeCookie">
    <keyword>MFreeCookie</keyword>
    <fullCommand>MFreeCookie [FirstShape.w[,LastShape.w]]</fullCommand>
    <parameters>[FirstShape.w[,LastShape.w]]</parameters>
    <shortDescription>Free a Shape's cookie, a range of Shape's cookies, or all cookies.</shortDescription>
    <longDescription />
  </command>
  <command name="MFreeStencil">
    <keyword>MFreeStencil</keyword>
    <fullCommand>MFreeStencil [FirstBitmap.w[,LastBitmap.w]]</fullCommand>
    <parameters>[FirstBitmap.w[,LastBitmap.w]]</parameters>
    <shortDescription>Free's a Bitmap's stencil, a range of stencils or all stencils.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoShapeWrap">
    <keyword>MAutoShapeWrap</keyword>
    <fullCommand>MAutoShapeWrap On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>Auto X&amp;Y Handle-wrapping for Shapes.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoBitmapWrap">
    <keyword>MAutoBitmapWrap</keyword>
    <fullCommand>MAutoBitmapWrap On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>Auto X&amp;Y Handle-Wrapingp for Bitmaps.</shortDescription>
    <longDescription />
  </command>
  <command name="MShapeWrap">
    <keyword>MShapeWrap</keyword>
    <fullCommand>MShapeWrap ShapeNumber.w,On/Off</fullCommand>
    <parameters>ShapeNumber.w,On/Off</parameters>
    <shortDescription>De/Activate X&amp;Y Handle-Wrap for Shape.</shortDescription>
    <longDescription />
  </command>
  <command name="MBitmapWrap">
    <keyword>MBitmapWrap</keyword>
    <fullCommand>MBitmapWrap BitmapNumber.w,On/Off</fullCommand>
    <parameters>BitmapNumber.w,On/Off</parameters>
    <shortDescription>De/Activate X&amp;Y Handle-Wrap for Bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MCludgeShapeStruct">
    <keyword>MCludgeShapeStruct</keyword>
    <fullCommand>MCludgeShapeStruct [(]SourceShape.w,DestShape.w[)]</fullCommand>
    <parameters>[(]SourceShape.w,DestShape.w[)]</parameters>
    <shortDescription>Copy definition-data only.</shortDescription>
    <longDescription />
  </command>
  <command name="MCludgeBitmapStruct">
    <keyword>MCludgeBitmapStruct</keyword>
    <fullCommand>MCludgeBitmapStruct [(]SourceBitmap.w,DestBitmap.w[)]</fullCommand>
    <parameters>[(]SourceBitmap.w,DestBitmap.w[)]</parameters>
    <shortDescription>Copy definition-data only.</shortDescription>
    <longDescription />
  </command>
  <command name="MCopyc2pWindow">
    <keyword>MCopyc2pWindow</keyword>
    <fullCommand>MCopyc2pWindow Sourcec2pWindow.w,Destc2pWindow.w</fullCommand>
    <parameters>Sourcec2pWindow.w,Destc2pWindow.w</parameters>
    <shortDescription>Copy definition-data only.</shortDescription>
    <longDescription />
  </command>
  <command name="MShapeWindow">
    <keyword>MShapeWindow</keyword>
    <fullCommand>MShapeWindow [(]SourceShape.w,DestShape.w,X.w,Y.w,Width.w,Height.w[)]</fullCommand>
    <parameters>[(]SourceShape.w,DestShape.w,X.w,Y.w,Width.w,Height.w[)]</parameters>
    <shortDescription>Cludge Shape within a Shape.</shortDescription>
    <longDescription />
  </command>
  <command name="MBitmapWindow">
    <keyword>MBitmapWindow</keyword>
    <fullCommand>MBitmapWindow [(]SourceBitmap.w,DestBitmap.w,X.w,Y.w,Width.w,Height.w[)]</fullCommand>
    <parameters>[(]SourceBitmap.w,DestBitmap.w,X.w,Y.w,Width.w,Height.w[)]</parameters>
    <shortDescription>Cludge Bitmap within a Bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MBitmapShape">
    <keyword>MBitmapShape</keyword>
    <fullCommand>MBitmapShape [(]SourceBitmap.w,DestShape.w[)]</fullCommand>
    <parameters>[(]SourceBitmap.w,DestShape.w[)]</parameters>
    <shortDescription>Copy definition-data only.</shortDescription>
    <longDescription />
  </command>
  <command name="MShapesBitmap">
    <keyword>MShapesBitmap</keyword>
    <fullCommand>MShapesBitmap [(]SourceShape.w,DestBitmap.w[)]</fullCommand>
    <parameters>[(]SourceShape.w,DestBitmap.w[)]</parameters>
    <shortDescription>Copy definition-data only.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoCookieXFlip">
    <keyword>MAutoCookieXFlip</keyword>
    <fullCommand>MAutoCookieXFlip On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>Auto X-Flip for Shape's cookie.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoCookieYFlip">
    <keyword>MAutoCookieYFlip</keyword>
    <fullCommand>MAutoCookieYFlip On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>Auto Y-Flip for Shape's cookie.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoStencilXFlip">
    <keyword>MAutoStencilXFlip</keyword>
    <fullCommand>MAutoStencilXFlip On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>Auto X-Flip for Bitmap's stencil.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoStencilYFlip">
    <keyword>MAutoStencilYFlip</keyword>
    <fullCommand>MAutoStencilYFlip On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>Auto Y-Flip for Bitmap's stencil.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoCookieFlip">
    <keyword>MAutoCookieFlip</keyword>
    <fullCommand>MAutoCookieFlip On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>Auto X&amp;Y Cookie-Flip for Shapes.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoStencilFlip">
    <keyword>MAutoStencilFlip</keyword>
    <fullCommand>MAutoStencilFlip On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>Auto X&amp;Y Stencil-Flip for Bitmaps.</shortDescription>
    <longDescription />
  </command>
  <command name="MShapeXFlip">
    <keyword>MShapeXFlip</keyword>
    <fullCommand>MShapeXFlip ShapeNumber.w</fullCommand>
    <parameters>ShapeNumber.w</parameters>
    <shortDescription>Horizontally flip a Shape (see MAutoCookieFlip).</shortDescription>
    <longDescription />
  </command>
  <command name="MShapeYFlip">
    <keyword>MShapeYFlip</keyword>
    <fullCommand>MShapeYFlip ShapeNumber.w</fullCommand>
    <parameters>ShapeNumber.w</parameters>
    <shortDescription>Vertically flip a Shape (see MAutoCookieFlip).</shortDescription>
    <longDescription />
  </command>
  <command name="MBitmapXFlip">
    <keyword>MBitmapXFlip</keyword>
    <fullCommand>MBitmapXFlip BitmapNumber.w</fullCommand>
    <parameters>BitmapNumber.w</parameters>
    <shortDescription>Horizontally flip a Bitmap (see MAutoStencilFlip).</shortDescription>
    <longDescription />
  </command>
  <command name="MBitmapYFlip">
    <keyword>MBitmapYFlip</keyword>
    <fullCommand>MBitmapYFlip BitmapNumber.w</fullCommand>
    <parameters>BitmapNumber.w</parameters>
    <shortDescription>Vertically flip a Bitmap (see MAutoStencilFlip).</shortDescription>
    <longDescription />
  </command>
  <command name="MCookieXFlip">
    <keyword>MCookieXFlip</keyword>
    <fullCommand>MCookieXFlip ShapeNumber.w</fullCommand>
    <parameters>ShapeNumber.w</parameters>
    <shortDescription>Horizontally flip a Shape's cookie.</shortDescription>
    <longDescription />
  </command>
  <command name="MCookieYFlip">
    <keyword>MCookieYFlip</keyword>
    <fullCommand>MCookieYFlip ShapeNumber.w</fullCommand>
    <parameters>ShapeNumber.w</parameters>
    <shortDescription>Vertically flip a Shape's cookie.</shortDescription>
    <longDescription />
  </command>
  <command name="MStencilXFlip">
    <keyword>MStencilXFlip</keyword>
    <fullCommand>MStencilXFlip BitmapNumber.w</fullCommand>
    <parameters>BitmapNumber.w</parameters>
    <shortDescription>Horizontally flip a Bitmap's stencil.</shortDescription>
    <longDescription />
  </command>
  <command name="MStencilYFlip">
    <keyword>MStencilYFlip</keyword>
    <fullCommand>MStencilYFlip BitmapNumber.w</fullCommand>
    <parameters>BitmapNumber.w</parameters>
    <shortDescription>Vertically flip a Bitmap's stencil.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoShapeClip">
    <keyword>MAutoShapeClip</keyword>
    <fullCommand>MAutoShapeClip Status.b</fullCommand>
    <parameters>Status.b</parameters>
    <shortDescription>Auto-clip new Shapes. On/Off.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoBitmapClip">
    <keyword>MAutoBitmapClip</keyword>
    <fullCommand>MAutoBitmapClip Status.b</fullCommand>
    <parameters>Status.b</parameters>
    <shortDescription>Auto-clip new Bitmaps. On/Off.</shortDescription>
    <longDescription />
  </command>
  <command name="MShapeClip">
    <keyword>MShapeClip</keyword>
    <fullCommand>MShapeClip ShapeNumber.w[,X.w,Y.w,Width.w,Height.w][,Active]</fullCommand>
    <parameters>ShapeNumber.w[,X.w,Y.w,Width.w,Height.w][,Active]</parameters>
    <shortDescription>Active=On/Off. Define Shape's clip window.</shortDescription>
    <longDescription />
  </command>
  <command name="MBitmapClip">
    <keyword>MBitmapClip</keyword>
    <fullCommand>MBitmapClip BitmapNumber.w[,X.w,Y.w,Width.w,Height.w][,Active]</fullCommand>
    <parameters>BitmapNumber.w[,X.w,Y.w,Width.w,Height.w][,Active]</parameters>
    <shortDescription>Active=On/Off. Define Bitmap's clip window.</shortDescription>
    <longDescription />
  </command>
  <command name="MGetaShape">
    <keyword>MGetaShape</keyword>
    <fullCommand>MGetaShape ShapeNumber.w,X.w,Y.w,Width.w,Height.w[,Block?,StencilIsCookie?]</fullCommand>
    <parameters>ShapeNumber.w,X.w,Y.w,Width.w,Height.w[,Block?,StencilIsCookie?]</parameters>
    <shortDescription>Grab shape from bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MGetaBitmap">
    <keyword>MGetaBitmap</keyword>
    <fullCommand>MGetaBitmap BitmapNumber.w,X.w,Y.w,Width.w,Height.w[,Block?,CookieIsStencil?]</fullCommand>
    <parameters>BitmapNumber.w,X.w,Y.w,Width.w,Height.w[,Block?,CookieIsStencil?]</parameters>
    <shortDescription>Grab bitmap from shape.</shortDescription>
    <longDescription />
  </command>
  <command name="MScroll">
    <keyword>MScroll</keyword>
    <fullCommand>MScroll X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]</parameters>
    <shortDescription>Copy graphic.</shortDescription>
    <longDescription />
  </command>
  <command name="MScrollShape">
    <keyword>MScrollShape</keyword>
    <fullCommand>MScrollShape X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]</parameters>
    <shortDescription>Copy graphic.</shortDescription>
    <longDescription />
  </command>
  <command name="MScrollStencil">
    <keyword>MScrollStencil</keyword>
    <fullCommand>MScrollStencil X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]</parameters>
    <shortDescription>Copy sten to sten.</shortDescription>
    <longDescription />
  </command>
  <command name="MScrollCookie">
    <keyword>MScrollCookie</keyword>
    <fullCommand>MScrollCookie X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]</parameters>
    <shortDescription>Copy cook to cook.</shortDescription>
    <longDescription />
  </command>
  <command name="MMaskScroll">
    <keyword>MMaskScroll</keyword>
    <fullCommand>MMaskScroll X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</parameters>
    <shortDescription>Copy bitmap graphic with stencil-cut.</shortDescription>
    <longDescription />
  </command>
  <command name="MMaskScrollShape">
    <keyword>MMaskScrollShape</keyword>
    <fullCommand>MMaskScrollShape X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</parameters>
    <shortDescription>Copy shape graphic with cookie-cut.</shortDescription>
    <longDescription />
  </command>
  <command name="MMaskScrollStencil">
    <keyword>MMaskScrollStencil</keyword>
    <fullCommand>MMaskScrollStencil X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</parameters>
    <shortDescription>Copy stencil2stencil &amp; stencil-cut.</shortDescription>
    <longDescription />
  </command>
  <command name="MMaskScrollCookie">
    <keyword>MMaskScrollCookie</keyword>
    <fullCommand>MMaskScrollCookie X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</parameters>
    <shortDescription>Copy cookie to cookie &amp; cookie-cut.</shortDescription>
    <longDescription />
  </command>
  <command name="MScrollBitmapToShape">
    <keyword>MScrollBitmapToShape</keyword>
    <fullCommand>MScrollBitmapToShape X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]</parameters>
    <shortDescription>bitmap 2 shape.</shortDescription>
    <longDescription />
  </command>
  <command name="MScrollShapeToBitmap">
    <keyword>MScrollShapeToBitmap</keyword>
    <fullCommand>MScrollShapeToBitmap X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]</parameters>
    <shortDescription>shape 2 bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MScrollStencilToCookie">
    <keyword>MScrollStencilToCookie</keyword>
    <fullCommand>MScrollStencilToCookie X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]</parameters>
    <shortDescription>sten2cookie.</shortDescription>
    <longDescription />
  </command>
  <command name="MScrollCookieToStencil">
    <keyword>MScrollCookieToStencil</keyword>
    <fullCommand>MScrollCookieToStencil X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]</parameters>
    <shortDescription>cookie2sten.</shortDescription>
    <longDescription />
  </command>
  <command name="MMaskScrollBitmapToShape">
    <keyword>MMaskScrollBitmapToShape</keyword>
    <fullCommand>MMaskScrollBitmapToShape X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</parameters>
    <shortDescription>Copy bitmap to shape &amp; cut.</shortDescription>
    <longDescription />
  </command>
  <command name="MMaskScrollShapeToBitmap">
    <keyword>MMaskScrollShapeToBitmap</keyword>
    <fullCommand>MMaskScrollShapeToBitmap X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</parameters>
    <shortDescription>Copy shape to bitmap &amp; cut.</shortDescription>
    <longDescription />
  </command>
  <command name="MMaskScrollStencilToCookie">
    <keyword>MMaskScrollStencilToCookie</keyword>
    <fullCommand>MMaskScrollStencilToCookie X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</parameters>
    <shortDescription>Copy stencil2cookie &amp; cut.</shortDescription>
    <longDescription />
  </command>
  <command name="MMaskScrollCookieToStencil">
    <keyword>MMaskScrollCookieToStencil</keyword>
    <fullCommand>MMaskScrollCookieToStencil X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</parameters>
    <shortDescription>Copy cookie2stencil &amp; cut.</shortDescription>
    <longDescription />
  </command>
  <command name="MBlockScroll">
    <keyword>MBlockScroll</keyword>
    <fullCommand>MBlockScroll X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</parameters>
    <shortDescription>BlockCopy graphic.</shortDescription>
    <longDescription />
  </command>
  <command name="MBlockScrollShape">
    <keyword>MBlockScrollShape</keyword>
    <fullCommand>MBlockScrollShape X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</parameters>
    <shortDescription>BlockCopy graphic.</shortDescription>
    <longDescription />
  </command>
  <command name="MBlockScrollStencil">
    <keyword>MBlockScrollStencil</keyword>
    <fullCommand>MBlockScrollStencil X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</parameters>
    <shortDescription>BlockCopy stencil to stencil.</shortDescription>
    <longDescription />
  </command>
  <command name="MBlockScrollCookie">
    <keyword>MBlockScrollCookie</keyword>
    <fullCommand>MBlockScrollCookie X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</parameters>
    <shortDescription>BlockCopy cookie to cookie.</shortDescription>
    <longDescription />
  </command>
  <command name="MBlockScrollBitmapToShape">
    <keyword>MBlockScrollBitmapToShape</keyword>
    <fullCommand>MBlockScrollBitmapToShape X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</parameters>
    <shortDescription>BlockCopy bitmap to shape.</shortDescription>
    <longDescription />
  </command>
  <command name="MBlockScrollShapeToBitmap">
    <keyword>MBlockScrollShapeToBitmap</keyword>
    <fullCommand>MBlockScrollShapeToBitmap X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</parameters>
    <shortDescription>BlockCopy shape to bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MBlockScrollStencilToCookie">
    <keyword>MBlockScrollStencilToCookie</keyword>
    <fullCommand>MBlockScrollStencilToCookie X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</parameters>
    <shortDescription>BlockCopy stencil2cookie.</shortDescription>
    <longDescription />
  </command>
  <command name="MBlockScrollCookieToStencil">
    <keyword>MBlockScrollCookieToStencil</keyword>
    <fullCommand>MBlockScrollCookieToStencil X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</parameters>
    <shortDescription>BlockCopy cookie2stencil.</shortDescription>
    <longDescription />
  </command>
  <command name="MCPU">
    <keyword>MCPU</keyword>
    <fullCommand>MCPU Processor.b</fullCommand>
    <parameters>Processor.b</parameters>
    <shortDescription>Set cpu routines allowed to use. CAREFUL!! Try using `MProcessor' or `Processor'.</shortDescription>
    <longDescription />
  </command>
  <command name="MCls">
    <keyword>MCls</keyword>
    <fullCommand>MCls [Colour] Clear a bitmap to colour 0 or the specified colour (in DrawingMode)</fullCommand>
    <parameters>[Colour] Clear a bitmap to colour 0 or the specified colour (in DrawingMode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MClsShape">
    <keyword>MClsShape</keyword>
    <fullCommand>MClsShape [Colour] Clear a shape to colour 0 or the specified colour (in DrawingMode)</fullCommand>
    <parameters>[Colour] Clear a shape to colour 0 or the specified colour (in DrawingMode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MClsStencil">
    <keyword>MClsStencil</keyword>
    <fullCommand>MClsStencil [Colour] Clear a stencil to colour 0 or the specified colour (in DrawingMode)</fullCommand>
    <parameters>[Colour] Clear a stencil to colour 0 or the specified colour (in DrawingMode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MClsCookie">
    <keyword>MClsCookie</keyword>
    <fullCommand>MClsCookie [Colour] Clear a cookie to colour 0 or the specified colour (in DrawingMode)</fullCommand>
    <parameters>[Colour] Clear a cookie to colour 0 or the specified colour (in DrawingMode)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MPlot">
    <keyword>MPlot</keyword>
    <fullCommand>MPlot Xpos.w,Ypos.w[,Colour]</fullCommand>
    <parameters>Xpos.w,Ypos.w[,Colour]</parameters>
    <shortDescription>Plot a single pixel in the bitmap in DrawingMode.</shortDescription>
    <longDescription />
  </command>
  <command name="MPlotShape">
    <keyword>MPlotShape</keyword>
    <fullCommand>MPlotShape Xpos.w,Ypos.w[,Colour]</fullCommand>
    <parameters>Xpos.w,Ypos.w[,Colour]</parameters>
    <shortDescription>Plot a single pixel in the shape in DrawingMode.</shortDescription>
    <longDescription />
  </command>
  <command name="MPlotStencil">
    <keyword>MPlotStencil</keyword>
    <fullCommand>MPlotStencil Xpos.w,Ypos.w[,Colour]</fullCommand>
    <parameters>Xpos.w,Ypos.w[,Colour]</parameters>
    <shortDescription>Plot a single pixel in the stencil to *represent* DrawingMode.</shortDescription>
    <longDescription />
  </command>
  <command name="MPlotCookie">
    <keyword>MPlotCookie</keyword>
    <fullCommand>MPlotCookie Xpos.w,Ypos.w[,Colour]</fullCommand>
    <parameters>Xpos.w,Ypos.w[,Colour]</parameters>
    <shortDescription>Plot a single pixel in the cookie to *represent* DrawingMode.</shortDescription>
    <longDescription />
  </command>
  <command name="MPoint">
    <keyword>MPoint</keyword>
    <fullCommand>MPoint(Xpos.w,Ypos.w[,BitmapToRead.w])</fullCommand>
    <parameters>(Xpos.w,Ypos.w[,BitmapToRead.w])</parameters>
    <shortDescription>Return the colour of a single pixel in a bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MPointShape">
    <keyword>MPointShape</keyword>
    <fullCommand>MPointShape(Xpos.w,Ypos.w[,ShapeToRead.w])</fullCommand>
    <parameters>(Xpos.w,Ypos.w[,ShapeToRead.w])</parameters>
    <shortDescription>Return the colour of a single pixel in a shape.</shortDescription>
    <longDescription />
  </command>
  <command name="MPointStencil">
    <keyword>MPointStencil</keyword>
    <fullCommand>MPointStencil(Xpos.w,Ypos.w[,BitmapToRead.w])</fullCommand>
    <parameters>(Xpos.w,Ypos.w[,BitmapToRead.w])</parameters>
    <shortDescription>Return the status of a pixel in stencil. -1=Data, 0=Background.</shortDescription>
    <longDescription />
  </command>
  <command name="MPointCookie">
    <keyword>MPointCookie</keyword>
    <fullCommand>MPointCookie(Xpos.w,Ypos.w[,ShapeToRead.w])</fullCommand>
    <parameters>(Xpos.w,Ypos.w[,ShapeToRead.w])</parameters>
    <shortDescription>Return the status of a pixel in cookie. -1=Data, 0=Background.</shortDescription>
    <longDescription />
  </command>
  <command name="MSScroll">
    <keyword>MSScroll</keyword>
    <fullCommand>MSScroll X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]</parameters>
    <shortDescription>Copy bm 2 bm and st 2 st.</shortDescription>
    <longDescription />
  </command>
  <command name="MSScrollShape">
    <keyword>MSScrollShape</keyword>
    <fullCommand>MSScrollShape X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]</parameters>
    <shortDescription>Copy sh2sh and ck2ck.</shortDescription>
    <longDescription />
  </command>
  <command name="MSScrollBitmapToShape">
    <keyword>MSScrollBitmapToShape</keyword>
    <fullCommand>MSScrollBitmapToShape X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]</parameters>
    <shortDescription>bm2shandst2ck.</shortDescription>
    <longDescription />
  </command>
  <command name="MSScrollShapeToBitmap">
    <keyword>MSScrollShapeToBitmap</keyword>
    <fullCommand>MSScrollShapeToBitmap X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]</parameters>
    <shortDescription>sh2bmandck2st.</shortDescription>
    <longDescription />
  </command>
  <command name="MSMaskScroll">
    <keyword>MSMaskScroll</keyword>
    <fullCommand>MSMaskScroll X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</parameters>
    <shortDescription>Stencil-Copy bm 2 bm and st 2 st.</shortDescription>
    <longDescription />
  </command>
  <command name="MSMaskScrollShape">
    <keyword>MSMaskScrollShape</keyword>
    <fullCommand>MSMaskScrollShape X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</parameters>
    <shortDescription>Cookie-Copy sh2sh and ck2ck.</shortDescription>
    <longDescription />
  </command>
  <command name="MSMaskScrollBitmapToShape">
    <keyword>MSMaskScrollBitmapToShape</keyword>
    <fullCommand>MSMaskScrollBitmapToShape X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</parameters>
    <shortDescription>Sten-Copy bm2sh&amp;st2ck.</shortDescription>
    <longDescription />
  </command>
  <command name="MSMaskScrollShapeToBitmap">
    <keyword>MSMaskScrollShapeToBitmap</keyword>
    <fullCommand>MSMaskScrollShapeToBitmap X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</parameters>
    <shortDescription>Cook-Copy sh2bm&amp;ck2st.</shortDescription>
    <longDescription />
  </command>
  <command name="MSBlockScroll">
    <keyword>MSBlockScroll</keyword>
    <fullCommand>MSBlockScroll X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</parameters>
    <shortDescription>Block-Copy bm 2 bm and st 2 st.</shortDescription>
    <longDescription />
  </command>
  <command name="MSBlockScrollShape">
    <keyword>MSBlockScrollShape</keyword>
    <fullCommand>MSBlockScrollShape X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</parameters>
    <shortDescription>Block-Copy sh2sh and ck2ck.</shortDescription>
    <longDescription />
  </command>
  <command name="MSBlockScrollBitmapToShape">
    <keyword>MSBlockScrollBitmapToShape</keyword>
    <fullCommand>MSBlockScrollBitmapToShape X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w]</parameters>
    <shortDescription>BlockCopy bm2sh&amp;st2ck.</shortDescription>
    <longDescription />
  </command>
  <command name="MSBlockScrollShapeToBitmap">
    <keyword>MSBlockScrollShapeToBitmap</keyword>
    <fullCommand>MSBlockScrollShapeToBitmap X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</fullCommand>
    <parameters>X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w]</parameters>
    <shortDescription>BlockCopy sh2bm&amp;ck2st.</shortDescription>
    <longDescription />
  </command>
  <command name="MSScrollCut">
    <keyword>MSScrollCut</keyword>
    <fullCommand>MSScrollCut On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>0=Paste stencil/cookie, &lt;&gt;0=Cut using stencil/cookie.</shortDescription>
    <longDescription />
  </command>
  <command name="MUseShapeBank">
    <keyword>MUseShapeBank</keyword>
    <fullCommand>MUseShapeBank BankNumber.w</fullCommand>
    <parameters>BankNumber.w</parameters>
    <shortDescription>Current shape bank, 0..31.</shortDescription>
    <longDescription />
  </command>
  <command name="MNothing">
    <keyword>MNothing</keyword>
    <fullCommand>MNothing</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>This is the 128th token and it doesn't work so is a dummy.</shortDescription>
    <longDescription />
  </command>
  <command name="MMaskScrollMode">
    <keyword>MMaskScrollMode</keyword>
    <fullCommand>MMaskScrollMode [([]Mode.w[])]</fullCommand>
    <parameters>[([]Mode.w[])]</parameters>
    <shortDescription>CookieMode/EraseMode/InvMode/SolidMode/MColourMode/MReMapMode/MSimpleReMapMode/MAddMo.</shortDescription>
    <longDescription />
  </command>
  <command name="MBlitMode">
    <keyword>MBlitMode</keyword>
    <fullCommand>MBlitMode [([]Mode.w[])]</fullCommand>
    <parameters>[([]Mode.w[])]</parameters>
    <shortDescription>CookieMode/EraseMode/InvMode/SolidMode/MColourMode/MReMapMode/MSimpleReMapMode/MAddMode.</shortDescription>
    <longDescription />
  </command>
  <command name="MBlit">
    <keyword>MBlit</keyword>
    <fullCommand>MBlit [ShapeNumber.w,]Xpos.w,Ypos,w</fullCommand>
    <parameters>[ShapeNumber.w,]Xpos.w,Ypos,w</parameters>
    <shortDescription>Blit shape to bitmap, any coords.</shortDescription>
    <longDescription />
  </command>
  <command name="MBlock">
    <keyword>MBlock</keyword>
    <fullCommand>MBlock [ShapeNumber.w,]Xpos.w,Ypos.w</fullCommand>
    <parameters>[ShapeNumber.w,]Xpos.w,Ypos.w</parameters>
    <shortDescription>Block-blit shape to bitmap, align Xpos and width in multiples of 16!.</shortDescription>
    <longDescription />
  </command>
  <command name="MTile16x16">
    <keyword>MTile16x16</keyword>
    <fullCommand>MTile16x16 [ShapeNumber.w,]Xpos.w,Ypos.w</fullCommand>
    <parameters>[ShapeNumber.w,]Xpos.w,Ypos.w</parameters>
    <shortDescription>Block-blit 16x16 shape to bitmap, size must be 16x16, align x/y.</shortDescription>
    <longDescription />
  </command>
  <command name="MTile32x32">
    <keyword>MTile32x32</keyword>
    <fullCommand>MTile32x32 [ShapeNumber.w,]Xpos.w,Ypos.w</fullCommand>
    <parameters>[ShapeNumber.w,]Xpos.w,Ypos.w</parameters>
    <shortDescription>Block-blit 32x32 shape to bitmap, size must be 32x32, align x/y.</shortDescription>
    <longDescription />
  </command>
  <command name="MSTile16x16">
    <keyword>MSTile16x16</keyword>
    <fullCommand>MSTile16x16 [ShapeNumber.w,]Xpos.w,Ypos.w</fullCommand>
    <parameters>[ShapeNumber.w,]Xpos.w,Ypos.w</parameters>
    <shortDescription>Block-blit 16x16 shape&amp;cook 2 bitmap, size 16x16, align x/y.</shortDescription>
    <longDescription />
  </command>
  <command name="MSTile32x32">
    <keyword>MSTile32x32</keyword>
    <fullCommand>MSTile32x32 [ShapeNumber.w,]Xpos.w,Ypos.w</fullCommand>
    <parameters>[ShapeNumber.w,]Xpos.w,Ypos.w</parameters>
    <shortDescription>Block-blit 32x32 shape&amp;cook 2 bitmap, size 32x32, align x/y.</shortDescription>
    <longDescription />
  </command>
  <command name="MSTile16x16Store">
    <keyword>MSTile16x16Store</keyword>
    <fullCommand>MSTile16x16Store [ShapeNumber.w,]Xpos.w,Ypos.w</fullCommand>
    <parameters>[ShapeNumber.w,]Xpos.w,Ypos.w</parameters>
    <shortDescription>Block-blit 16x16 shape&amp;cook 2 bitmaps, size 16x16, align x/y.</shortDescription>
    <longDescription />
  </command>
  <command name="MSTile32x32Store">
    <keyword>MSTile32x32Store</keyword>
    <fullCommand>MSTile32x32Store [ShapeNumber.w,]Xpos.w,Ypos.w</fullCommand>
    <parameters>[ShapeNumber.w,]Xpos.w,Ypos.w</parameters>
    <shortDescription>Block-blit 32x32 shape&amp;cook 2 bitmaps, size 32x32, align x/y.</shortDescription>
    <longDescription />
  </command>
  <command name="MTile16x16Store">
    <keyword>MTile16x16Store</keyword>
    <fullCommand>MTile16x16Store [ShapeNumber.w,]Xpos.w,Ypos.w</fullCommand>
    <parameters>[ShapeNumber.w,]Xpos.w,Ypos.w</parameters>
    <shortDescription>Block-blit 16x16 shape to 2 bitmaps, size 16x16, align x/y.</shortDescription>
    <longDescription />
  </command>
  <command name="MTile32x32Store">
    <keyword>MTile32x32Store</keyword>
    <fullCommand>MTile32x32Store [ShapeNumber.w,]Xpos.w,Ypos.w</fullCommand>
    <parameters>[ShapeNumber.w,]Xpos.w,Ypos.w</parameters>
    <shortDescription>Block-blit 32x32 shape to 2 bitmaps, size 32x32, align x/y.</shortDescription>
    <longDescription />
  </command>
  <command name="MReserveQueues">
    <keyword>MReserveQueues</keyword>
    <fullCommand>MReserveQueues [(]NumberOfQueues.w[)]</fullCommand>
    <parameters>[(]NumberOfQueues.w[)]</parameters>
    <shortDescription>Reserve structure-memory for Queues.</shortDescription>
    <longDescription />
  </command>
  <command name="MFreeQueue">
    <keyword>MFreeQueue</keyword>
    <fullCommand>MFreeQueue [FirstQueue.w[,LastQueue.w]]</fullCommand>
    <parameters>[FirstQueue.w[,LastQueue.w]]</parameters>
    <shortDescription>Free a Queue, a range of queues, or all queues.</shortDescription>
    <longDescription />
  </command>
  <command name="MAddrQueue">
    <keyword>MAddrQueue</keyword>
    <fullCommand>MAddrQueue [(QueueNumber.w)]</fullCommand>
    <parameters>[(QueueNumber.w)]</parameters>
    <shortDescription>Returns address of Queue structure.</shortDescription>
    <longDescription />
  </command>
  <command name="MQueue">
    <keyword>MQueue</keyword>
    <fullCommand>MQueue [(]QueueNumber.w,NumberOfItems.w[)]</fullCommand>
    <parameters>[(]QueueNumber.w,NumberOfItems.w[)]</parameters>
    <shortDescription>Allocmem for Queue list items.</shortDescription>
    <longDescription />
  </command>
  <command name="MFlushQueue">
    <keyword>MFlushQueue</keyword>
    <fullCommand>MFlushQueue QueueNumber.w</fullCommand>
    <parameters>QueueNumber.w</parameters>
    <shortDescription>Empties the queue to contain no items.</shortDescription>
    <longDescription />
  </command>
  <command name="MQBlitMode">
    <keyword>MQBlitMode</keyword>
    <fullCommand>MQBlitMode [([]Mode.w[])]</fullCommand>
    <parameters>[([]Mode.w[])]</parameters>
    <shortDescription>CookieMode/EraseMode/InvMode/SolidMode/MColourMode/MReMapMode/MSimpleReMapMode/MAddMode.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoUseQueues">
    <keyword>MAutoUseQueues</keyword>
    <fullCommand>MAutoUseQueues True/False</fullCommand>
    <parameters>True/False</parameters>
    <shortDescription>Automatically `use' new Queues. &lt;&gt;0=True.</shortDescription>
    <longDescription />
  </command>
  <command name="MUseQueue">
    <keyword>MUseQueue</keyword>
    <fullCommand>MUseQueue MainQueueNum.w[,SecondQueueNum.w[,ThirdQueueNum.w]]</fullCommand>
    <parameters>MainQueueNum.w[,SecondQueueNum.w[,ThirdQueueNum.w]]</parameters>
    <shortDescription>Current queue(s) to use.</shortDescription>
    <longDescription />
  </command>
  <command name="MUsedQueue">
    <keyword>MUsedQueue</keyword>
    <fullCommand>MUsedQueue</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns currently used Queue.</shortDescription>
    <longDescription />
  </command>
  <command name="MQBlit">
    <keyword>MQBlit</keyword>
    <fullCommand>MQBlit [[Queue.w,]ShapeNumber.w,]Xpos.w,Ypos,w</fullCommand>
    <parameters>[[Queue.w,]ShapeNumber.w,]Xpos.w,Ypos,w</parameters>
    <shortDescription>QBlit shape to bitmap, any coords.</shortDescription>
    <longDescription />
  </command>
  <command name="MQBlock">
    <keyword>MQBlock</keyword>
    <fullCommand>MQBlock [[Queue.w,]ShapeNumber.w,]Xpos.w,Ypos.w</fullCommand>
    <parameters>[[Queue.w,]ShapeNumber.w,]Xpos.w,Ypos.w</parameters>
    <shortDescription>QBlock-blit shape 2 bitmap, align Xpos &amp; width in mult of 16.</shortDescription>
    <longDescription />
  </command>
  <command name="MUnQueue">
    <keyword>MUnQueue</keyword>
    <fullCommand>MUnQueue QueueNumber.w[,FirstItem.w,LastItem.w][,BitmapNumber.w]</fullCommand>
    <parameters>QueueNumber.w[,FirstItem.w,LastItem.w][,BitmapNumber.w]</parameters>
    <shortDescription>UnQueue [range of] queued objects [&amp;flush].</shortDescription>
    <longDescription />
  </command>
  <command name="MBitmapPtr">
    <keyword>MBitmapPtr</keyword>
    <fullCommand>MBitmapPtr [Xpos.w,Ypos.w][,BitmapNumber.w]</fullCommand>
    <parameters>[Xpos.w,Ypos.w][,BitmapNumber.w]</parameters>
    <shortDescription>Return data address calculated using bitmap [and coords].</shortDescription>
    <longDescription />
  </command>
  <command name="MShapePtr">
    <keyword>MShapePtr</keyword>
    <fullCommand>MShapePtr [Xpos.w,Ypos.w][,ShapeNumber.w]</fullCommand>
    <parameters>[Xpos.w,Ypos.w][,ShapeNumber.w]</parameters>
    <shortDescription>Return data address calculated using shape [and coords].</shortDescription>
    <longDescription />
  </command>
  <command name="MStencilPtr">
    <keyword>MStencilPtr</keyword>
    <fullCommand>MStencilPtr [Xpos.w,Ypos.w][,BitmapNumber.w]</fullCommand>
    <parameters>[Xpos.w,Ypos.w][,BitmapNumber.w]</parameters>
    <shortDescription>Return address calculated using stencil [and coords].</shortDescription>
    <longDescription />
  </command>
  <command name="MCookiePtr">
    <keyword>MCookiePtr</keyword>
    <fullCommand>MCookiePtr [Xpos.w,Ypos.w][,ShapeNumber.w]</fullCommand>
    <parameters>[Xpos.w,Ypos.w][,ShapeNumber.w]</parameters>
    <shortDescription>Return address calculated using cookie [and coords].</shortDescription>
    <longDescription />
  </command>
  <command name="MQDummy">
    <keyword>MQDummy</keyword>
    <fullCommand>MQDummy [Queue.w,]Xpos.w,Ypos.w,Width.w,Height.w</fullCommand>
    <parameters>[Queue.w,]Xpos.w,Ypos.w,Width.w,Height.w</parameters>
    <shortDescription>Add an item to a queue without having to do a blit.</shortDescription>
    <longDescription />
  </command>
  <command name="MSBlitMode">
    <keyword>MSBlitMode</keyword>
    <fullCommand>MSBlitMode [([]Mode.w[])]</fullCommand>
    <parameters>[([]Mode.w[])]</parameters>
    <shortDescription>CookieMode/EraseMode/InvMode/SolidMode/MColourMode/MReMapMode/MSimpleReMapMode/MAddMode.</shortDescription>
    <longDescription />
  </command>
  <command name="MSBlit">
    <keyword>MSBlit</keyword>
    <fullCommand>MSBlit [ShapeNumber.w,]Xpos.w,Ypos,w</fullCommand>
    <parameters>[ShapeNumber.w,]Xpos.w,Ypos,w</parameters>
    <shortDescription>Blit shape to bitmap and cookie to stencil, any coords.</shortDescription>
    <longDescription />
  </command>
  <command name="MSBlock">
    <keyword>MSBlock</keyword>
    <fullCommand>MSBlock [ShapeNumber.w,]Xpos.w,Ypos.w</fullCommand>
    <parameters>[ShapeNumber.w,]Xpos.w,Ypos.w</parameters>
    <shortDescription>Block-blit shape to bitmap &amp; cookie 2 stencil, Xpos&amp;Width in 16's.</shortDescription>
    <longDescription />
  </command>
  <command name="MSBlitCut">
    <keyword>MSBlitCut</keyword>
    <fullCommand>MSBlitCut On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>0=Paste stencil/cookie, &lt;&gt;0=Cut using stencil/cookie.</shortDescription>
    <longDescription />
  </command>
  <command name="MQSBlitMode">
    <keyword>MQSBlitMode</keyword>
    <fullCommand>MQSBlitMode [([]Mode.w[])]</fullCommand>
    <parameters>[([]Mode.w[])]</parameters>
    <shortDescription>CookieMode/EraseMode/InvMode/SolidMode/MColourMode/MReMapMode/MSimpleReMapMode/MAddMode.</shortDescription>
    <longDescription />
  </command>
  <command name="MQSBlit">
    <keyword>MQSBlit</keyword>
    <fullCommand>MQSBlit [[Queue.w,]ShapeNumber.w,]Xpos.w,Ypos,w</fullCommand>
    <parameters>[[Queue.w,]ShapeNumber.w,]Xpos.w,Ypos,w</parameters>
    <shortDescription>QBlit shape to bitmap and cookie to stencil, any coords.</shortDescription>
    <longDescription />
  </command>
  <command name="MQSBlock">
    <keyword>MQSBlock</keyword>
    <fullCommand>MQSBlock [[Queue.w,]ShapeNumber.w,]Xpos.w,Ypos.w</fullCommand>
    <parameters>[[Queue.w,]ShapeNumber.w,]Xpos.w,Ypos.w</parameters>
    <shortDescription>QBlock-blit shape 2 bitmap, Xpos&amp;width mult of 16.</shortDescription>
    <longDescription />
  </command>
  <command name="MQSBlitCut">
    <keyword>MQSBlitCut</keyword>
    <fullCommand>MQSBlitCut On/Off</fullCommand>
    <parameters>On/Off</parameters>
    <shortDescription>0=Paste stencil/cookie, &lt;&gt;0=Cut using stencil/cookie. Adds entry to queue.</shortDescription>
    <longDescription />
  </command>
  <command name="MBoxF">
    <keyword>MBoxF</keyword>
    <fullCommand>MBoxF Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw a filled box in a bitmap in DrawingMode</fullCommand>
    <parameters>Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw a filled box in a bitmap in DrawingMode</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MBoxFShape">
    <keyword>MBoxFShape</keyword>
    <fullCommand>MBoxFShape Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw a filled box in a shape in DrawingMode</fullCommand>
    <parameters>Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw a filled box in a shape in DrawingMode</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MBoxFStencil">
    <keyword>MBoxFStencil</keyword>
    <fullCommand>MBoxFStencil Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw a filled box in a stencil in DrawingMode</fullCommand>
    <parameters>Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw a filled box in a stencil in DrawingMode</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MBoxFCookie">
    <keyword>MBoxFCookie</keyword>
    <fullCommand>MBoxFCookie Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw a filled box in a cookie in DrawingMode</fullCommand>
    <parameters>Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw a filled box in a cookie in DrawingMode</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MBox">
    <keyword>MBox</keyword>
    <fullCommand>MBox Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw an unfilled box in a bitmap in DrawingMode</fullCommand>
    <parameters>Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw an unfilled box in a bitmap in DrawingMode</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MBoxShape">
    <keyword>MBoxShape</keyword>
    <fullCommand>MBoxShape Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw an unfilled box in a shape in DrawingMode</fullCommand>
    <parameters>Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw an unfilled box in a shape in DrawingMode</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MBoxStencil">
    <keyword>MBoxStencil</keyword>
    <fullCommand>MBoxStencil Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw an unfilled box in a stencil in DrawingMode</fullCommand>
    <parameters>Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw an unfilled box in a stencil in DrawingMode</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MBoxCookie">
    <keyword>MBoxCookie</keyword>
    <fullCommand>MBoxCookie Xpos.w,Ypos.w,Width.w,Height.w[,Colour] Draw an unfilled box in a cookie in DrawingMode</fullCommand>
    <parameters>Xpos.w,Ypos.w,Width.w,Height.w[,Colour] Draw an unfilled box in a cookie in DrawingMode</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MPlanar16ToBitmap">
    <keyword>MPlanar16ToBitmap</keyword>
    <fullCommand>MPlanar16ToBitmap BitmapNum.w,PlanarAddr.l[,OpWidth.w,OpHeight.w,PlanarWidth.w,PlanarHeight.w]</fullCommand>
    <parameters>BitmapNum.w,PlanarAddr.l[,OpWidth.w,OpHeight.w,PlanarWidth.w,PlanarHeight.w]</parameters>
    <shortDescription>Convert p2c.</shortDescription>
    <longDescription />
  </command>
  <command name="MPlanar16ToShape">
    <keyword>MPlanar16ToShape</keyword>
    <fullCommand>MPlanar16ToShape ShapeNum.w,PlanarAddr.l[,OpWidth.w,OpHeight.w,PlanarWidth.w,PlanarHeight.w]</fullCommand>
    <parameters>ShapeNum.w,PlanarAddr.l[,OpWidth.w,OpHeight.w,PlanarWidth.w,PlanarHeight.w]</parameters>
    <shortDescription>Convert p2c.</shortDescription>
    <longDescription />
  </command>
  <command name="MGenericPtr">
    <keyword>MGenericPtr</keyword>
    <fullCommand>MGenericPtr Xpos.w,Ypos.w,BaseAddress.l,RowWidth.w</fullCommand>
    <parameters>Xpos.w,Ypos.w,BaseAddress.l,RowWidth.w</parameters>
    <shortDescription>Calculate and return address based on inputs.</shortDescription>
    <longDescription />
  </command>
  <command name="MCludgeCookie">
    <keyword>MCludgeCookie</keyword>
    <fullCommand>MCludgeCookie ShapeNumber.w,Memory.l</fullCommand>
    <parameters>ShapeNumber.w,Memory.l</parameters>
    <shortDescription>Cludge shape's cookie from existing mem.</shortDescription>
    <longDescription />
  </command>
  <command name="MCludgeStencil">
    <keyword>MCludgeStencil</keyword>
    <fullCommand>MCludgeStencil BitmapNumber.w,Memory.l</fullCommand>
    <parameters>BitmapNumber.w,Memory.l</parameters>
    <shortDescription>Cludge bitmap's stencil from existing mem.</shortDescription>
    <longDescription />
  </command>
  <command name="MBlockUnQueue">
    <keyword>MBlockUnQueue</keyword>
    <fullCommand>MBlockUnQueue QueueNumber.w[,FirstItem.w,LastItem.w][,BitmapNumber.w]</fullCommand>
    <parameters>QueueNumber.w[,FirstItem.w,LastItem.w][,BitmapNumber.w]</parameters>
    <shortDescription>Block-UnQueue [range of] objects[&amp;flush].</shortDescription>
    <longDescription />
  </command>
  <command name="MReMap">
    <keyword>MReMap</keyword>
    <fullCommand>MReMap [Colour#0.b,Colour#1.b,BitmapNum.w] *or* [RemapTable.l[,BitmapNum.w]]</fullCommand>
    <parameters>[Colour#0.b,Colour#1.b,BitmapNum.w] *or* [RemapTable.l[,BitmapNum.w]]</parameters>
    <shortDescription>Remap #0 to #1 or with table.</shortDescription>
    <longDescription />
  </command>
  <command name="MReMapShape">
    <keyword>MReMapShape</keyword>
    <fullCommand>MReMapShape [Colour#0.b,Colour#1.b,ShapeNum.w] *or* [RemapTable.l[,ShapeNum.w]]</fullCommand>
    <parameters>[Colour#0.b,Colour#1.b,ShapeNum.w] *or* [RemapTable.l[,ShapeNum.w]]</parameters>
    <shortDescription>Remap #0 to #1 or with table.</shortDescription>
    <longDescription />
  </command>
  <command name="MLine">
    <keyword>MLine</keyword>
    <fullCommand>MLine [Xpos.w,Ypos.w,]Xpos2.w,Ypos2.w[,Colour.b]</fullCommand>
    <parameters>[Xpos.w,Ypos.w,]Xpos2.w,Ypos2.w[,Colour.b]</parameters>
    <shortDescription>Draw a line from X1,Y1 to X2,Y2 in a Bitmap in DrawingMode.</shortDescription>
    <longDescription />
  </command>
  <command name="MLineShape">
    <keyword>MLineShape</keyword>
    <fullCommand>MLineShape [Xpos.w,Ypos.w,]Xpos2.w,Ypos2.w[,Colour.b]</fullCommand>
    <parameters>[Xpos.w,Ypos.w,]Xpos2.w,Ypos2.w[,Colour.b]</parameters>
    <shortDescription>Draw a line from X1,Y1 to X2,Y2 in a Shape in DrawingMode.</shortDescription>
    <longDescription />
  </command>
  <command name="MLineStencil">
    <keyword>MLineStencil</keyword>
    <fullCommand>MLineStencil [Xpos.w,Ypos.w,]Xpos2.w,Ypos2.w[,Colour.b]</fullCommand>
    <parameters>[Xpos.w,Ypos.w,]Xpos2.w,Ypos2.w[,Colour.b]</parameters>
    <shortDescription>Draw a line from X1,Y1 to X2,Y2 in a stencil in DrawingMode.</shortDescription>
    <longDescription />
  </command>
  <command name="MLineCookie">
    <keyword>MLineCookie</keyword>
    <fullCommand>MLineCookie [Xpos.w,Ypos.w,]Xpos2.w,Ypos2.w[,Colour.b]</fullCommand>
    <parameters>[Xpos.w,Ypos.w,]Xpos2.w,Ypos2.w[,Colour.b]</parameters>
    <shortDescription>Draw a line from X1,Y1 to X2,Y2 in a cookie in DrawingMode.</shortDescription>
    <longDescription />
  </command>
  <command name="MInk">
    <keyword>MInk</keyword>
    <fullCommand>MInk MainColour.b[,SecondColour.b[,ThirdColour.b]]</fullCommand>
    <parameters>MainColour.b[,SecondColour.b[,ThirdColour.b]]</parameters>
    <shortDescription>Set what colour to assume as currently used. 0..255.</shortDescription>
    <longDescription />
  </command>
  <command name="MColourMode">
    <keyword>MColourMode</keyword>
    <fullCommand>MColourMode</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns value 4 which represents `colour' mode in the blit modes.</shortDescription>
    <longDescription />
  </command>
  <command name="MReserveTables">
    <keyword>MReserveTables</keyword>
    <fullCommand>MReserveTables [(]NumberOfTables.w[)]</fullCommand>
    <parameters>[(]NumberOfTables.w[)]</parameters>
    <shortDescription>Reserve structure-memory for Tables.</shortDescription>
    <longDescription />
  </command>
  <command name="MFreeTable">
    <keyword>MFreeTable</keyword>
    <fullCommand>MFreeTable [FirstTable.w[,LastTable.w]] TableNumber.w</fullCommand>
    <parameters>[FirstTable.w[,LastTable.w]] TableNumber.w</parameters>
    <shortDescription>Free a Table, a range of tables or all tables.</shortDescription>
    <longDescription />
  </command>
  <command name="MAddrTable">
    <keyword>MAddrTable</keyword>
    <fullCommand>MAddrTable [(TableNumber.w)]</fullCommand>
    <parameters>[(TableNumber.w)]</parameters>
    <shortDescription>Returns address of Table structure.</shortDescription>
    <longDescription />
  </command>
  <command name="MTable">
    <keyword>MTable</keyword>
    <fullCommand>MTable [(]TableNumber.w,SizeInBytes.l[)]</fullCommand>
    <parameters>[(]TableNumber.w,SizeInBytes.l[)]</parameters>
    <shortDescription>Allocmem for Table list items.</shortDescription>
    <longDescription />
  </command>
  <command name="MAutoUseTables">
    <keyword>MAutoUseTables</keyword>
    <fullCommand>MAutoUseTables True/False</fullCommand>
    <parameters>True/False</parameters>
    <shortDescription>Automatically `use' new Tables. &lt;&gt;0=True.</shortDescription>
    <longDescription />
  </command>
  <command name="MUseTable">
    <keyword>MUseTable</keyword>
    <fullCommand>MUseTable MainTableNum.w[,SecondTableNum.w[,ThirdTableNum.w]]</fullCommand>
    <parameters>MainTableNum.w[,SecondTableNum.w[,ThirdTableNum.w]]</parameters>
    <shortDescription>Current table(s) to use.</shortDescription>
    <longDescription />
  </command>
  <command name="MUsedTable">
    <keyword>MUsedTable</keyword>
    <fullCommand>MUsedTable</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns currently used Table.</shortDescription>
    <longDescription />
  </command>
  <command name="MTablePtr">
    <keyword>MTablePtr</keyword>
    <fullCommand>MTablePtr [TableNum.w]</fullCommand>
    <parameters>[TableNum.w]</parameters>
    <shortDescription>Returns pointer to base of the table itself.</shortDescription>
    <longDescription />
  </command>
  <command name="MReMapMode">
    <keyword>MReMapMode</keyword>
    <fullCommand>MReMapMode</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns value 5 which represents `ReMap' mode in the blit modes (uses current 2-dimensional table).</shortDescription>
    <longDescription />
  </command>
  <command name="MSimpleReMapMode">
    <keyword>MSimpleReMapMode</keyword>
    <fullCommand>MSimpleReMapMode</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns value 6 which is `SimpleReMap' mode in blit modes (uses current 1-dimensional table).</shortDescription>
    <longDescription />
  </command>
  <command name="MSMaskScrollMode">
    <keyword>MSMaskScrollMode</keyword>
    <fullCommand>MSMaskScrollMode [([]Mode.w[])]</fullCommand>
    <parameters>[([]Mode.w[])]</parameters>
    <shortDescription>CookieMode/EraseMode/InvMode/SolidMode/MColourMode/MReMapMode/MSimpleReMapMode/MAdd.</shortDescription>
    <longDescription />
  </command>
  <command name="MPlotParticles">
    <keyword>MPlotParticles</keyword>
    <fullCommand>MPlotParticles CoordinateList.l,NumPoints.l[,Colour.b]</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l[,Colour.b]</parameters>
    <shortDescription>Plot lots of points from a table of positions.</shortDescription>
    <longDescription />
  </command>
  <command name="MGrabParticles">
    <keyword>MGrabParticles</keyword>
    <fullCommand>MGrabParticles CoordinateList.l,NumPoints.l,Buffer.l</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l,Buffer.l</parameters>
    <shortDescription>Grab lots of points from a table into buffer mem.</shortDescription>
    <longDescription />
  </command>
  <command name="MDrawParticles">
    <keyword>MDrawParticles</keyword>
    <fullCommand>MDrawParticles CoordinateList.l,NumPoints.l,Buffer.l</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l,Buffer.l</parameters>
    <shortDescription>Draw lots of previously grabbed points using a table.</shortDescription>
    <longDescription />
  </command>
  <command name="MGrabParticlesAndPlot">
    <keyword>MGrabParticlesAndPlot</keyword>
    <fullCommand>MGrabParticlesAndPlot CoordinateList.l,NumPoints.l,Buffer.l[,Colour.b]</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l,Buffer.l[,Colour.b]</parameters>
    <shortDescription>Grabs points to buffer &amp; plots table.</shortDescription>
    <longDescription />
  </command>
  <command name="MAddToParticles">
    <keyword>MAddToParticles</keyword>
    <fullCommand>MAddToParticles CoordinateList.l,NumPoints.l,IncA.l[,IncB.l]</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l,IncA.l[,IncB.l]</parameters>
    <shortDescription>Add [two sets of] increments to particle list.</shortDescription>
    <longDescription />
  </command>
  <command name="MWrapParticles">
    <keyword>MWrapParticles</keyword>
    <fullCommand>MWrapParticles CoordinateList.l,NumPoints.l</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l</parameters>
    <shortDescription>Bring particles in from opposite edge to which they left.</shortDescription>
    <longDescription />
  </command>
  <command name="MReboundParticles">
    <keyword>MReboundParticles</keyword>
    <fullCommand>MReboundParticles CoordinateList.l,NumPoints.l,DirectionList.l,DetectSize.w</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l,DirectionList.l,DetectSize.w</parameters>
    <shortDescription>Bounce off edges (NOT Ptr.l!!!).</shortDescription>
    <longDescription />
  </command>
  <command name="MProcessor">
    <keyword>MProcessor</keyword>
    <fullCommand>MProcessor</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns value 0..6 representing MC68000..MC68060 cpu according to exec\AttnFlags.</shortDescription>
    <longDescription />
  </command>
  <command name="MAddXYToParticles">
    <keyword>MAddXYToParticles</keyword>
    <fullCommand>MAddXYToParticles CoordinateList.l,NumPoints.l,XToAdd.w,YToAdd.w</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l,XToAdd.w,YToAdd.w</parameters>
    <shortDescription>Add constants to all particles.</shortDescription>
    <longDescription />
  </command>
  <command name="MAddXYToParticlesA">
    <keyword>MAddXYToParticlesA</keyword>
    <fullCommand>MAddXYToParticlesA CoordinateList.l,NumPoints.l,ValueToAdd.l</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l,ValueToAdd.l</parameters>
    <shortDescription>Add constant to all particle pointers.</shortDescription>
    <longDescription />
  </command>
  <command name="MAddXYToParticlesQ">
    <keyword>MAddXYToParticlesQ</keyword>
    <fullCommand>MAddXYToParticlesQ CoordinateList.l,NumPoints.l,XToAdd.q,YToAdd.q</fullCommand>
    <parameters>CoordinateList.l,NumPoints.l,XToAdd.q,YToAdd.q</parameters>
    <shortDescription>Add constants to all particles.</shortDescription>
    <longDescription />
  </command>
  <command name="MParticleMode">
    <keyword>MParticleMode</keyword>
    <fullCommand>MParticleMode Mode.w or ()</fullCommand>
    <parameters>Mode.w or ()</parameters>
    <shortDescription>MColourMode, MSimpleReMapMode, MReMapMode or MAddMode - to use in particle plot/draw.</shortDescription>
    <longDescription />
  </command>
  <command name="MMildredBase">
    <keyword>MMildredBase</keyword>
    <fullCommand>MMildredBase</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns long address of the base of Mildred's internal data area.</shortDescription>
    <longDescription />
  </command>
  <command name="MDrawingMode">
    <keyword>MDrawingMode</keyword>
    <fullCommand>MDrawingMode [(]Mode.w[)]</fullCommand>
    <parameters>[(]Mode.w[)]</parameters>
    <shortDescription>InvMode/MColourMode/MReMapMode/MSimpleReMapMode/MAddMode to use for drawing (MPlot etc).</shortDescription>
    <longDescription />
  </command>
  <command name="MParticleFormat">
    <keyword>MParticleFormat</keyword>
    <fullCommand>MParticleFormat [(]Format.b[)]</fullCommand>
    <parameters>[(]Format.b[)]</parameters>
    <shortDescription>Set particle lists/operation format. 0 = X.w,Y.w, &lt;0 = X.q,Y.q, &gt;0 = Ptr.l.</shortDescription>
    <longDescription />
  </command>
  <command name="MPictureDissolveIn">
    <keyword>MPictureDissolveIn</keyword>
    <fullCommand>MPictureDissolveIn PictureBitmapNum.w,Colour.b</fullCommand>
    <parameters>PictureBitmapNum.w,Colour.b</parameters>
    <shortDescription>Do a picture-based colour-number dissolve-in of a bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MPictureDissolveOut">
    <keyword>MPictureDissolveOut</keyword>
    <fullCommand>MPictureDissolveOut PictureBitmapNum.w,Colour.b,WipeToColour.b</fullCommand>
    <parameters>PictureBitmapNum.w,Colour.b,WipeToColour.b</parameters>
    <shortDescription>Do picture-based colour dissolve-out of bitmap.</shortDescription>
    <longDescription />
  </command>
  <command name="MZoom">
    <keyword>MZoom</keyword>
    <fullCommand>MZoom SrcX.q,SrcY.q,XAdd.q,YAdd.q,DestX.w,DestY.w,OpWidth.w,OpHeight.w,DeRes?.w[,SrcBmap.w[,CustomOffsets.l]]</fullCommand>
    <parameters>SrcX.q,SrcY.q,XAdd.q,YAdd.q,DestX.w,DestY.w,OpWidth.w,OpHeight.w,DeRes?.w[,SrcBmap.w[,CustomOffsets.l]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MZoomShape">
    <keyword>MZoomShape</keyword>
    <fullCommand>MZoomShape SrcX.q,SrcY.q,XAdd.q,YAdd.q,DestX.w,DestY.w,OpWidth.w,OpHeight.w,DeRes?.w[,SrcShap.w[,CustOffs.l]]</fullCommand>
    <parameters>SrcX.q,SrcY.q,XAdd.q,YAdd.q,DestX.w,DestY.w,OpWidth.w,OpHeight.w,DeRes?.w[,SrcShap.w[,CustOffs.l]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MZoomBitmapToShape">
    <keyword>MZoomBitmapToShape</keyword>
    <fullCommand>MZoomBitmapToShape SrcX.q,SrcY.q,XAdd.q,YAdd.q,DstX.w,DstY.w,OpWid.w,OpHeight.w,DeRes?.w[,SrcBmap.w[,CustOffs.l]]</fullCommand>
    <parameters>SrcX.q,SrcY.q,XAdd.q,YAdd.q,DstX.w,DstY.w,OpWid.w,OpHeight.w,DeRes?.w[,SrcBmap.w[,CustOffs.l]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MZoomShapeToBitmap">
    <keyword>MZoomShapeToBitmap</keyword>
    <fullCommand>MZoomShapeToBitmap SrcX.q,SrcY.q,XAdd.q,YAdd.q,DstX.w,DstY.w,OpWidth.w,OpHeight.w,DeRes?.w[,SrcShap.w[,CustOffs.l]]</fullCommand>
    <parameters>SrcX.q,SrcY.q,XAdd.q,YAdd.q,DstX.w,DstY.w,OpWidth.w,OpHeight.w,DeRes?.w[,SrcShap.w[,CustOffs.l]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StarField">
    <keyword>StarField</keyword>
    <fullCommand>StarField a starfield object</fullCommand>
    <parameters>a starfield object</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitStarField">
    <keyword>InitStarField</keyword>
    <fullCommand>InitStarField starfield,num [,type]</fullCommand>
    <parameters>starfield,num [,type]</parameters>
    <shortDescription>0=Normal / 1=3D.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeStarField">
    <keyword>FreeStarField</keyword>
    <fullCommand>FreeStarField starfield</fullCommand>
    <parameters>starfield</parameters>
    <shortDescription>Free's memory used by a starfield.</shortDescription>
    <longDescription />
  </command>
  <command name="StarFieldAdr">
    <keyword>StarFieldAdr</keyword>
    <fullCommand>StarFieldAdr(starfield)</fullCommand>
    <parameters>(starfield)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StarFieldSize">
    <keyword>StarFieldSize</keyword>
    <fullCommand>StarFieldSize(starfield)</fullCommand>
    <parameters>(starfield)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NumStars">
    <keyword>NumStars</keyword>
    <fullCommand>NumStars(starfield)</fullCommand>
    <parameters>(starfield)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StarFieldType">
    <keyword>StarFieldType</keyword>
    <fullCommand>StarFieldType(starfield)</fullCommand>
    <parameters>(starfield)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetStarFieldType">
    <keyword>SetStarFieldType</keyword>
    <fullCommand>SetStarFieldType starfield,type</fullCommand>
    <parameters>starfield,type</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetStar">
    <keyword>SetStar</keyword>
    <fullCommand>SetStar starfield,star,x,y,x speed,y speed</fullCommand>
    <parameters>starfield,star,x,y,x speed,y speed</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StarX">
    <keyword>StarX</keyword>
    <fullCommand>StarX(starfield,star)</fullCommand>
    <parameters>(starfield,star)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StarY">
    <keyword>StarY</keyword>
    <fullCommand>StarY(starfield,star)</fullCommand>
    <parameters>(starfield,star)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StarXSpeed">
    <keyword>StarXSpeed</keyword>
    <fullCommand>StarXSpeed(starfield,star)</fullCommand>
    <parameters>(starfield,star)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StarYSpeed">
    <keyword>StarYSpeed</keyword>
    <fullCommand>StarYSpeed(starfield,star)</fullCommand>
    <parameters>(starfield,star)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RecalcStarfield">
    <keyword>RecalcStarfield</keyword>
    <fullCommand>RecalcStarfield starfield,max width,max height</fullCommand>
    <parameters>starfield,max width,max height</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PlotStarfield">
    <keyword>PlotStarfield</keyword>
    <fullCommand>PlotStarfield starfield,colour</fullCommand>
    <parameters>starfield,colour</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DoStarfield">
    <keyword>DoStarfield</keyword>
    <fullCommand>DoStarfield starfield,max width,max height,colour</fullCommand>
    <parameters>starfield,max width,max height,colour</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Initmap">
    <keyword>Initmap</keyword>
    <fullCommand>Initmap width,height</fullCommand>
    <parameters>width,height</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MapWidth">
    <keyword>MapWidth</keyword>
    <fullCommand>MapWidth</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns width of map.</shortDescription>
    <longDescription />
  </command>
  <command name="MapHeight">
    <keyword>MapHeight</keyword>
    <fullCommand>MapHeight</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns height of map.</shortDescription>
    <longDescription />
  </command>
  <command name="MapLen">
    <keyword>MapLen</keyword>
    <fullCommand>MapLen</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns length of map in memory (In bytes).</shortDescription>
    <longDescription />
  </command>
  <command name="MapAdr">
    <keyword>MapAdr</keyword>
    <fullCommand>MapAdr</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns physical address of map in memory.</shortDescription>
    <longDescription />
  </command>
  <command name="MapPlot">
    <keyword>MapPlot</keyword>
    <fullCommand>MapPlot X,Y,Value</fullCommand>
    <parameters>X,Y,Value</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MapGet">
    <keyword>MapGet</keyword>
    <fullCommand>MapGet(X,Y)</fullCommand>
    <parameters>(X,Y)</parameters>
    <shortDescription>Returns value at map location.</shortDescription>
    <longDescription />
  </command>
  <command name="FreeMap">
    <keyword>FreeMap</keyword>
    <fullCommand>FreeMap</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Free's up memory used by map.</shortDescription>
    <longDescription />
  </command>
  <command name="FSin">
    <keyword>FSin</keyword>
    <fullCommand>FSin(float)</fullCommand>
    <parameters>(float)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FCos">
    <keyword>FCos</keyword>
    <fullCommand>FCos(float)</fullCommand>
    <parameters>(float)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FTan">
    <keyword>FTan</keyword>
    <fullCommand>FTan(float)</fullCommand>
    <parameters>(float)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FASin">
    <keyword>FASin</keyword>
    <fullCommand>FASin(float)</fullCommand>
    <parameters>(float)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FACos">
    <keyword>FACos</keyword>
    <fullCommand>FACos(float)</fullCommand>
    <parameters>(float)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FATan">
    <keyword>FATan</keyword>
    <fullCommand>FATan(float)</fullCommand>
    <parameters>(float)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FPow">
    <keyword>FPow</keyword>
    <fullCommand>FPow(float,float)</fullCommand>
    <parameters>(float,float)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FSqr">
    <keyword>FSqr</keyword>
    <fullCommand>FSqr(float)</fullCommand>
    <parameters>(float)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FLog10">
    <keyword>FLog10</keyword>
    <fullCommand>FLog10(float)</fullCommand>
    <parameters>(float)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FLog">
    <keyword>FLog</keyword>
    <fullCommand>FLog(float)</fullCommand>
    <parameters>(float)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FRad">
    <keyword>FRad</keyword>
    <fullCommand>FRad(float)</fullCommand>
    <parameters>(float)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FDeg">
    <keyword>FDeg</keyword>
    <fullCommand>FDeg(float)</fullCommand>
    <parameters>(float)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Word">
    <keyword>Word</keyword>
    <fullCommand>Word(Str[,Num])</fullCommand>
    <parameters>(Str[,Num])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Words">
    <keyword>Words</keyword>
    <fullCommand>Words(Str)</fullCommand>
    <parameters>(Str)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WordIndex">
    <keyword>WordIndex</keyword>
    <fullCommand>WordIndex(Str,Num)</fullCommand>
    <parameters>(Str,Num)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CtrlC">
    <keyword>CtrlC</keyword>
    <fullCommand>CtrlC</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns True if a CTRL/C has been received.</shortDescription>
    <longDescription />
  </command>
  <command name="New">
    <keyword>New</keyword>
    <fullCommand>New(Size[,Type])</fullCommand>
    <parameters>(Size[,Type])</parameters>
    <shortDescription>Allocates Memory.</shortDescription>
    <longDescription />
  </command>
  <command name="Dispose">
    <keyword>Dispose</keyword>
    <fullCommand>Dispose(Addr)</fullCommand>
    <parameters>(Addr)</parameters>
    <shortDescription>Deallocates previously allocated memory.</shortDescription>
    <longDescription />
  </command>
  <command name="KickVersion">
    <keyword>KickVersion</keyword>
    <fullCommand>KickVersion [(Ver)]</fullCommand>
    <parameters>[(Ver)]</parameters>
    <shortDescription>Used to Check/Get Kickstart version.</shortDescription>
    <longDescription />
  </command>
  <command name="execbase">
    <keyword>execbase</keyword>
    <fullCommand>execbase</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns pointer to Exec library base.</shortDescription>
    <longDescription />
  </command>
  <command name="StrLen">
    <keyword>StrLen</keyword>
    <fullCommand>StrLen(Str)|(Addr)</fullCommand>
    <parameters>(Str)|(Addr)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrLeft">
    <keyword>StrLeft</keyword>
    <fullCommand>StrLeft(Str,Len[,Pad])</fullCommand>
    <parameters>(Str,Len[,Pad])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrRight">
    <keyword>StrRight</keyword>
    <fullCommand>StrRight(Str,Len[,Pad])</fullCommand>
    <parameters>(Str,Len[,Pad])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrUpper">
    <keyword>StrUpper</keyword>
    <fullCommand>StrUpper(Str)</fullCommand>
    <parameters>(Str)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrLower">
    <keyword>StrLower</keyword>
    <fullCommand>StrLower(Str)</fullCommand>
    <parameters>(Str)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrFlip">
    <keyword>StrFlip</keyword>
    <fullCommand>StrFlip(Str)</fullCommand>
    <parameters>(Str)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrPack">
    <keyword>StrPack</keyword>
    <fullCommand>StrPack(Str[,Table])</fullCommand>
    <parameters>(Str[,Table])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrClone">
    <keyword>StrClone</keyword>
    <fullCommand>StrClone(Str,Num)</fullCommand>
    <parameters>(Str,Num)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StrRange">
    <keyword>StrRange</keyword>
    <fullCommand>StrRange(Start[,End])</fullCommand>
    <parameters>(Start[,End])</parameters>
    <shortDescription>Returns all characters between Start and END.</shortDescription>
    <longDescription />
  </command>
  <command name="StrChg">
    <keyword>StrChg</keyword>
    <fullCommand>StrChg(Str,OldStr,NewStr)</fullCommand>
    <parameters>(Str,OldStr,NewStr)</parameters>
    <shortDescription>Replace all OldStr by NewStr in Str.</shortDescription>
    <longDescription />
  </command>
  <command name="StrSub">
    <keyword>StrSub</keyword>
    <fullCommand>StrSub(Str,Pos[,Len[,Pad]])</fullCommand>
    <parameters>(Str,Pos[,Len[,Pad]])</parameters>
    <shortDescription>Returns a sub-string in Str.</shortDescription>
    <longDescription />
  </command>
  <command name="StrTrans">
    <keyword>StrTrans</keyword>
    <fullCommand>StrTrans(Str,OutTable,InTable[,Pad])</fullCommand>
    <parameters>(Str,OutTable,InTable[,Pad])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Printf">
    <keyword>Printf</keyword>
    <fullCommand>Printf Str[,Datas...]</fullCommand>
    <parameters>Str[,Datas...]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Stringf">
    <keyword>Stringf</keyword>
    <fullCommand>Stringf Str[,Datas...]</fullCommand>
    <parameters>Str[,Datas...]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PrintBuf">
    <keyword>PrintBuf</keyword>
    <fullCommand>PrintBuf</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FlipWord">
    <keyword>FlipWord</keyword>
    <fullCommand>FlipWord(Word)</fullCommand>
    <parameters>(Word)</parameters>
    <shortDescription>Flips a Word.</shortDescription>
    <longDescription />
  </command>
  <command name="FlipLong">
    <keyword>FlipLong</keyword>
    <fullCommand>FlipLong(Long)</fullCommand>
    <parameters>(Long)</parameters>
    <shortDescription>Flips a Long.</shortDescription>
    <longDescription />
  </command>
  <command name="FPeekW">
    <keyword>FPeekW</keyword>
    <fullCommand>FPeekW(Addr)</fullCommand>
    <parameters>(Addr)</parameters>
    <shortDescription>Returns and Flips a Word from Addr.</shortDescription>
    <longDescription />
  </command>
  <command name="FPeekL">
    <keyword>FPeekL</keyword>
    <fullCommand>FPeekL(Addr)</fullCommand>
    <parameters>(Addr)</parameters>
    <shortDescription>Returns and Flips a Long from Addr.</shortDescription>
    <longDescription />
  </command>
  <command name="UPeekB">
    <keyword>UPeekB</keyword>
    <fullCommand>UPeekB(Addr)</fullCommand>
    <parameters>(Addr)</parameters>
    <shortDescription>Returns an unsigned Byte from Addr.</shortDescription>
    <longDescription />
  </command>
  <command name="UPeekW">
    <keyword>UPeekW</keyword>
    <fullCommand>UPeekW(Addr)</fullCommand>
    <parameters>(Addr)</parameters>
    <shortDescription>Returns an unsigned Word from Addr.</shortDescription>
    <longDescription />
  </command>
  <command name="SaveMem">
    <keyword>SaveMem</keyword>
    <fullCommand>SaveMem(FileName,Addr,Len)</fullCommand>
    <parameters>(FileName,Addr,Len)</parameters>
    <shortDescription>Saves memory in a file.</shortDescription>
    <longDescription />
  </command>
  <command name="LoadMem">
    <keyword>LoadMem</keyword>
    <fullCommand>LoadMem(FileName,Addr,Len)</fullCommand>
    <parameters>(FileName,Addr,Len)</parameters>
    <shortDescription>Loads a file in memory.</shortDescription>
    <longDescription />
  </command>
  <command name="PeekB">
    <keyword>PeekB</keyword>
    <fullCommand>PeekB(Addr)</fullCommand>
    <parameters>(Addr)</parameters>
    <shortDescription>Reads a Byte from memory.</shortDescription>
    <longDescription />
  </command>
  <command name="PeekW">
    <keyword>PeekW</keyword>
    <fullCommand>PeekW(Addr)</fullCommand>
    <parameters>(Addr)</parameters>
    <shortDescription>Reads a Word from memory.</shortDescription>
    <longDescription />
  </command>
  <command name="PeekL">
    <keyword>PeekL</keyword>
    <fullCommand>PeekL(Addr)</fullCommand>
    <parameters>(Addr)</parameters>
    <shortDescription>Reads a Long from memory.</shortDescription>
    <longDescription />
  </command>
  <command name="PokeB">
    <keyword>PokeB</keyword>
    <fullCommand>PokeB Addr,Byte</fullCommand>
    <parameters>Addr,Byte</parameters>
    <shortDescription>Writes a Byte in memory.</shortDescription>
    <longDescription />
  </command>
  <command name="PokeW">
    <keyword>PokeW</keyword>
    <fullCommand>PokeW Addr,Word</fullCommand>
    <parameters>Addr,Word</parameters>
    <shortDescription>Writes a Word in memory.</shortDescription>
    <longDescription />
  </command>
  <command name="PokeL">
    <keyword>PokeL</keyword>
    <fullCommand>PokeL Addr,Long</fullCommand>
    <parameters>Addr,Long</parameters>
    <shortDescription>Writes a Long in memory.</shortDescription>
    <longDescription />
  </command>
  <command name="PeekS">
    <keyword>PeekS</keyword>
    <fullCommand>PeekS(Addr[,Len])</fullCommand>
    <parameters>(Addr[,Len])</parameters>
    <shortDescription>Reads a String form memory.</shortDescription>
    <longDescription />
  </command>
  <command name="PokeS">
    <keyword>PokeS</keyword>
    <fullCommand>PokeS Addr,Str[,Len]</fullCommand>
    <parameters>Addr,Str[,Len]</parameters>
    <shortDescription>Writes a String in memory.</shortDescription>
    <longDescription />
  </command>
  <command name="PeekT">
    <keyword>PeekT</keyword>
    <fullCommand>PeekT(Addr,Byte)</fullCommand>
    <parameters>(Addr,Byte)</parameters>
    <shortDescription>Reads memory into a String from Addr upto Byte.</shortDescription>
    <longDescription />
  </command>
  <command name="MPokeL">
    <keyword>MPokeL</keyword>
    <fullCommand>MPokeL Addr,Long[,Long...]</fullCommand>
    <parameters>Addr,Long[,Long...]</parameters>
    <shortDescription>Writes multiple Longs.</shortDescription>
    <longDescription />
  </command>
  <command name="MemCls">
    <keyword>MemCls</keyword>
    <fullCommand>MemCls Addr,Len[,Byte]</fullCommand>
    <parameters>Addr,Len[,Byte]</parameters>
    <shortDescription>Fills memory.</shortDescription>
    <longDescription />
  </command>
  <command name="LnkAdd">
    <keyword>LnkAdd</keyword>
    <fullCommand>LnkAdd(Header,Size)</fullCommand>
    <parameters>(Header,Size)</parameters>
    <shortDescription>Create linked list / Add an item.</shortDescription>
    <longDescription />
  </command>
  <command name="LnkDel">
    <keyword>LnkDel</keyword>
    <fullCommand>LnkDel Header,Item</fullCommand>
    <parameters>Header,Item</parameters>
    <shortDescription>Remove Item from linked list.</shortDescription>
    <longDescription />
  </command>
  <command name="OpenF">
    <keyword>OpenF</keyword>
    <fullCommand>OpenF(Name[,Mode])</fullCommand>
    <parameters>(Name[,Mode])</parameters>
    <shortDescription>Opens a file.</shortDescription>
    <longDescription />
  </command>
  <command name="CloseF">
    <keyword>CloseF</keyword>
    <fullCommand>CloseF [File]</fullCommand>
    <parameters>[File]</parameters>
    <shortDescription>Closes a file.</shortDescription>
    <longDescription />
  </command>
  <command name="ReadLN">
    <keyword>ReadLN</keyword>
    <fullCommand>ReadLN [(File)]</fullCommand>
    <parameters>[(File)]</parameters>
    <shortDescription>Reads a line from a file.</shortDescription>
    <longDescription />
  </command>
  <command name="ReadCH">
    <keyword>ReadCH</keyword>
    <fullCommand>ReadCH([File,]Len)</fullCommand>
    <parameters>([File,]Len)</parameters>
    <shortDescription>Reads characters from a file.</shortDescription>
    <longDescription />
  </command>
  <command name="WriteLN">
    <keyword>WriteLN</keyword>
    <fullCommand>WriteLN [File,]Str</fullCommand>
    <parameters>[File,]Str</parameters>
    <shortDescription>Write a line to a file.</shortDescription>
    <longDescription />
  </command>
  <command name="WriteCH">
    <keyword>WriteCH</keyword>
    <fullCommand>WriteCH [File,]Str</fullCommand>
    <parameters>[File,]Str</parameters>
    <shortDescription>Write characters to a file.</shortDescription>
    <longDescription />
  </command>
  <command name="WriteNM">
    <keyword>WriteNM</keyword>
    <fullCommand>WriteNM [File,]Num,Frm</fullCommand>
    <parameters>[File,]Num,Frm</parameters>
    <shortDescription>Write a number to a file.</shortDescription>
    <longDescription />
  </command>
  <command name="IOFile">
    <keyword>IOFile</keyword>
    <fullCommand>IOFile [File]</fullCommand>
    <parameters>[File]</parameters>
    <shortDescription>Used to Set or Get the working file.</shortDescription>
    <longDescription />
  </command>
  <command name="EOFile">
    <keyword>EOFile</keyword>
    <fullCommand>EOFile [(File)]</fullCommand>
    <parameters>[(File)]</parameters>
    <shortDescription>Used to check the end of a file.</shortDescription>
    <longDescription />
  </command>
  <command name="FSeek">
    <keyword>FSeek</keyword>
    <fullCommand>FSeek [File,]Pos,OffSet</fullCommand>
    <parameters>[File,]Pos,OffSet</parameters>
    <shortDescription>Moves the 'file cursor' inside a file.</shortDescription>
    <longDescription />
  </command>
  <command name="FSize">
    <keyword>FSize</keyword>
    <fullCommand>FSize [(File)]</fullCommand>
    <parameters>[(File)]</parameters>
    <shortDescription>Returns the size of a file in bytes.</shortDescription>
    <longDescription />
  </command>
  <command name="OpenS">
    <keyword>OpenS</keyword>
    <fullCommand>OpenS(Width,Height,Depth,ScrRes,Title[,Tags])</fullCommand>
    <parameters>(Width,Height,Depth,ScrRes,Title[,Tags])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="OpenW">
    <keyword>OpenW</keyword>
    <fullCommand>OpenW(X,Y,Width,Height,IDCMP,Flags,Title[,Scr[,Gads[,Tags]]])</fullCommand>
    <parameters>(X,Y,Width,Height,IDCMP,Flags,Title[,Scr[,Gads[,Tags]]])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CloseS">
    <keyword>CloseS</keyword>
    <fullCommand>CloseS Scr</fullCommand>
    <parameters>Scr</parameters>
    <shortDescription>Used to close a screen.</shortDescription>
    <longDescription />
  </command>
  <command name="CloseW">
    <keyword>CloseW</keyword>
    <fullCommand>CloseW Win</fullCommand>
    <parameters>Win</parameters>
    <shortDescription>Used to close a window.</shortDescription>
    <longDescription />
  </command>
  <command name="GetICode">
    <keyword>GetICode</keyword>
    <fullCommand>GetICode(Win)</fullCommand>
    <parameters>(Win)</parameters>
    <shortDescription>Used to get event code.</shortDescription>
    <longDescription />
  </command>
  <command name="GetIClass">
    <keyword>GetIClass</keyword>
    <fullCommand>GetIClass(Win)</fullCommand>
    <parameters>(Win)</parameters>
    <shortDescription>Used to get event class.</shortDescription>
    <longDescription />
  </command>
  <command name="WaitIMsg">
    <keyword>WaitIMsg</keyword>
    <fullCommand>WaitIMsg(Win)</fullCommand>
    <parameters>(Win)</parameters>
    <shortDescription>Waits for a message from Intuition.</shortDescription>
    <longDescription />
  </command>
  <command name="WaitICode">
    <keyword>WaitICode</keyword>
    <fullCommand>WaitICode Win,Code</fullCommand>
    <parameters>Win,Code</parameters>
    <shortDescription>Waits for Code(s).</shortDescription>
    <longDescription />
  </command>
  <command name="WaitIClass">
    <keyword>WaitIClass</keyword>
    <fullCommand>WaitIClass Win,Class</fullCommand>
    <parameters>Win,Class</parameters>
    <shortDescription>Waits for Class(es).</shortDescription>
    <longDescription />
  </command>
  <command name="MsgAddr">
    <keyword>MsgAddr</keyword>
    <fullCommand>MsgAddr</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Last IntuiMessage structure.</shortDescription>
    <longDescription />
  </command>
  <command name="MsgCode">
    <keyword>MsgCode</keyword>
    <fullCommand>MsgCode</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Code part of the last IntuiMessage.</shortDescription>
    <longDescription />
  </command>
  <command name="MsgClass">
    <keyword>MsgClass</keyword>
    <fullCommand>MsgClass</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Class part of the last IntuiMessage.</shortDescription>
    <longDescription />
  </command>
  <command name="MsgQualifier">
    <keyword>MsgQualifier</keyword>
    <fullCommand>MsgQualifier</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Qualifier part of the last IntuiMessage.</shortDescription>
    <longDescription />
  </command>
  <command name="AcScreen">
    <keyword>AcScreen</keyword>
    <fullCommand>AcScreen</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Used to get the pointer of the active screen.</shortDescription>
    <longDescription />
  </command>
  <command name="AcWindow">
    <keyword>AcWindow</keyword>
    <fullCommand>AcWindow</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Used to get the pointer of the active window.</shortDescription>
    <longDescription />
  </command>
  <command name="ScrMseX">
    <keyword>ScrMseX</keyword>
    <fullCommand>ScrMseX [(Scr)]</fullCommand>
    <parameters>[(Scr)]</parameters>
    <shortDescription>Returns X position of the mouse pointer relative to a screen.</shortDescription>
    <longDescription />
  </command>
  <command name="ScrMseY">
    <keyword>ScrMseY</keyword>
    <fullCommand>ScrMseY [(Scr)]</fullCommand>
    <parameters>[(Scr)]</parameters>
    <shortDescription>Returns Y position of the mouse pointer relative to a screen.</shortDescription>
    <longDescription />
  </command>
  <command name="WinMseX">
    <keyword>WinMseX</keyword>
    <fullCommand>WinMseX [(Win)]</fullCommand>
    <parameters>[(Win)]</parameters>
    <shortDescription>Returns X position of the mouse pointer relative to a window.</shortDescription>
    <longDescription />
  </command>
  <command name="WinMseY">
    <keyword>WinMseY</keyword>
    <fullCommand>WinMseY [(Win)]</fullCommand>
    <parameters>[(Win)]</parameters>
    <shortDescription>Returns Y position of the mouse pointer relative to a window.</shortDescription>
    <longDescription />
  </command>
  <command name="ScrMseIn">
    <keyword>ScrMseIn</keyword>
    <fullCommand>ScrMseIn([Scr,]x1,y1,x2,y2)</fullCommand>
    <parameters>([Scr,]x1,y1,x2,y2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="WinMseIn">
    <keyword>WinMseIn</keyword>
    <fullCommand>WinMseIn([Win,]x1,y1,x2,y2)</fullCommand>
    <parameters>([Win,]x1,y1,x2,y2)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NoMoreWin">
    <keyword>NoMoreWin</keyword>
    <fullCommand>NoMoreWin [(Scr)]</fullCommand>
    <parameters>[(Scr)]</parameters>
    <shortDescription>Used to check if there are windows on a screen.</shortDescription>
    <longDescription />
  </command>
  <command name="WaitNoMoreWin">
    <keyword>WaitNoMoreWin</keyword>
    <fullCommand>WaitNoMoreWin [(Scr)]</fullCommand>
    <parameters>[(Scr)]</parameters>
    <shortDescription>Waits while windows are still opened on a screen.</shortDescription>
    <longDescription />
  </command>
  <command name="intuitionbase">
    <keyword>intuitionbase</keyword>
    <fullCommand>intuitionbase</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns pointer to Intuition library base.</shortDescription>
    <longDescription />
  </command>
  <command name="DrPort">
    <keyword>DrPort</keyword>
    <fullCommand>DrPort [RastPort]</fullCommand>
    <parameters>[RastPort]</parameters>
    <shortDescription>Sets the RastPort to draw in.</shortDescription>
    <longDescription />
  </command>
  <command name="DrPlot">
    <keyword>DrPlot</keyword>
    <fullCommand>DrPlot x,y[,Pen]</fullCommand>
    <parameters>x,y[,Pen]</parameters>
    <shortDescription>Changes the color of a pixel in the current RastPort.</shortDescription>
    <longDescription />
  </command>
  <command name="DrBox">
    <keyword>DrBox</keyword>
    <fullCommand>DrBox x1,y1,x2,y2[,Pen]</fullCommand>
    <parameters>x1,y1,x2,y2[,Pen]</parameters>
    <shortDescription>Draws a box in the current RastPort.</shortDescription>
    <longDescription />
  </command>
  <command name="DrBoxf">
    <keyword>DrBoxf</keyword>
    <fullCommand>DrBoxf x1,y1,x2,y2[,Pen]</fullCommand>
    <parameters>x1,y1,x2,y2[,Pen]</parameters>
    <shortDescription>Draws a filled box in the current RastPort.</shortDescription>
    <longDescription />
  </command>
  <command name="DrLine">
    <keyword>DrLine</keyword>
    <fullCommand>DrLine x1,y1,x2,y2[,xn,yn...][,Pen]</fullCommand>
    <parameters>x1,y1,x2,y2[,xn,yn...][,Pen]</parameters>
    <shortDescription>Draws a series of lines on the current RastPort.</shortDescription>
    <longDescription />
  </command>
  <command name="DrBevel">
    <keyword>DrBevel</keyword>
    <fullCommand>DrBevel x2,y1,x2,y2,Pen1,Pen2</fullCommand>
    <parameters>x2,y1,x2,y2,Pen1,Pen2</parameters>
    <shortDescription>Draws a bevel box on the current RastPort.</shortDescription>
    <longDescription />
  </command>
  <command name="DrText">
    <keyword>DrText</keyword>
    <fullCommand>DrText Text,x,y,Pen[,Len]</fullCommand>
    <parameters>Text,x,y,Pen[,Len]</parameters>
    <shortDescription>Prints Text on the current RastPort.</shortDescription>
    <longDescription />
  </command>
  <command name="DrTextLen">
    <keyword>DrTextLen</keyword>
    <fullCommand>DrTextLen(Str[,Len])</fullCommand>
    <parameters>(Str[,Len])</parameters>
    <shortDescription>Returns size of Str in pixels.</shortDescription>
    <longDescription />
  </command>
  <command name="DrTextMax">
    <keyword>DrTextMax</keyword>
    <fullCommand>DrTextMax(x1,x2,Str)</fullCommand>
    <parameters>(x1,x2,Str)</parameters>
    <shortDescription>Returns the number of characters able to fit between x1 and x2.</shortDescription>
    <longDescription />
  </command>
  <command name="DrTextStl">
    <keyword>DrTextStl</keyword>
    <fullCommand>DrTextStl Style</fullCommand>
    <parameters>Style</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DrCls">
    <keyword>DrCls</keyword>
    <fullCommand>DrCls Pen</fullCommand>
    <parameters>Pen</parameters>
    <shortDescription>Clears the current RastPort.</shortDescription>
    <longDescription />
  </command>
  <command name="DrFont">
    <keyword>DrFont</keyword>
    <fullCommand>DrFont(Font)</fullCommand>
    <parameters>(Font)</parameters>
    <shortDescription>Sets RastPort font.</shortDescription>
    <longDescription />
  </command>
  <command name="DrMode">
    <keyword>DrMode</keyword>
    <fullCommand>DrMode Mode</fullCommand>
    <parameters>Mode</parameters>
    <shortDescription>Sets RastPort drawing mode.</shortDescription>
    <longDescription />
  </command>
  <command name="DrEllipse">
    <keyword>DrEllipse</keyword>
    <fullCommand>DrEllipse x,y,xRad,yRad[,Pen]</fullCommand>
    <parameters>x,y,xRad,yRad[,Pen]</parameters>
    <shortDescription>Used to Draw an outlined ellipse.</shortDescription>
    <longDescription />
  </command>
  <command name="DrCircle">
    <keyword>DrCircle</keyword>
    <fullCommand>DrCircle x,y,Rad[,Pen]</fullCommand>
    <parameters>x,y,Rad[,Pen]</parameters>
    <shortDescription>Used to Draw an outlined circle.</shortDescription>
    <longDescription />
  </command>
  <command name="DrBlit">
    <keyword>DrBlit</keyword>
    <fullCommand>DrBlit BitMap,xSrc,ySrc,xDest,yDest,Width,Height[,MinTerm]</fullCommand>
    <parameters>BitMap,xSrc,ySrc,xDest,yDest,Width,Height[,MinTerm]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="DrTopaz">
    <keyword>DrTopaz</keyword>
    <fullCommand>DrTopaz Size</fullCommand>
    <parameters>Size</parameters>
    <shortDescription>Sets Topaz font.</shortDescription>
    <longDescription />
  </command>
  <command name="DrPen">
    <keyword>DrPen</keyword>
    <fullCommand>DrPen Pen</fullCommand>
    <parameters>Pen</parameters>
    <shortDescription>SET drawing pen.</shortDescription>
    <longDescription />
  </command>
  <command name="c2p">
    <keyword>c2p</keyword>
    <fullCommand>c2p(Chunky,BitMap,Blocks)</fullCommand>
    <parameters>(Chunky,BitMap,Blocks)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="d2b">
    <keyword>d2b</keyword>
    <fullCommand>d2b(Int[,Len])</fullCommand>
    <parameters>(Int[,Len])</parameters>
    <shortDescription>Returns Bin representation.</shortDescription>
    <longDescription />
  </command>
  <command name="d2c">
    <keyword>d2c</keyword>
    <fullCommand>d2c(Int[,Len])</fullCommand>
    <parameters>(Int[,Len])</parameters>
    <shortDescription>Returns Asc representation.</shortDescription>
    <longDescription />
  </command>
  <command name="d2s">
    <keyword>d2s</keyword>
    <fullCommand>d2s(Int[,Len])</fullCommand>
    <parameters>(Int[,Len])</parameters>
    <shortDescription>Returns Str representation.</shortDescription>
    <longDescription />
  </command>
  <command name="d2x">
    <keyword>d2x</keyword>
    <fullCommand>d2x(Int[,Len])</fullCommand>
    <parameters>(Int[,Len])</parameters>
    <shortDescription>Returns Hex representation.</shortDescription>
    <longDescription />
  </command>
  <command name="c2b">
    <keyword>c2b</keyword>
    <fullCommand>c2b</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="c2d">
    <keyword>c2d</keyword>
    <fullCommand>c2d(Str[,Len])</fullCommand>
    <parameters>(Str[,Len])</parameters>
    <shortDescription>Returns Dec representation.</shortDescription>
    <longDescription />
  </command>
  <command name="c2x">
    <keyword>c2x</keyword>
    <fullCommand>c2x(Str[,Len])</fullCommand>
    <parameters>(Str[,Len])</parameters>
    <shortDescription>Returns Hex representation.</shortDescription>
    <longDescription />
  </command>
  <command name="s2d">
    <keyword>s2d</keyword>
    <fullCommand>s2d(Str)</fullCommand>
    <parameters>(Str)</parameters>
    <shortDescription>Convert in Dec.</shortDescription>
    <longDescription />
  </command>
  <command name="x2d">
    <keyword>x2d</keyword>
    <fullCommand>x2d(Str)</fullCommand>
    <parameters>(Str)</parameters>
    <shortDescription>Convert Hex in a string in Dec.</shortDescription>
    <longDescription />
  </command>
  <command name="b2d">
    <keyword>b2d</keyword>
    <fullCommand>b2d(Str[,Len]</fullCommand>
    <parameters>(Str[,Len]</parameters>
    <shortDescription>Convert a BinStr in Dec.</shortDescription>
    <longDescription />
  </command>
  <command name="FindByte">
    <keyword>FindByte</keyword>
    <fullCommand>FindByte(Str,Byte)|(Addr,Byte,Len)</fullCommand>
    <parameters>(Str,Byte)|(Addr,Byte,Len)</parameters>
    <shortDescription>Finds a Byte in memory.</shortDescription>
    <longDescription />
  </command>
  <command name="FindLong">
    <keyword>FindLong</keyword>
    <fullCommand>FindLong(Str,Long)|(Addr,Long,Len)</fullCommand>
    <parameters>(Str,Long)|(Addr,Long,Len)</parameters>
    <shortDescription>Finds a Long in memory.</shortDescription>
    <longDescription />
  </command>
  <command name="FindStrg">
    <keyword>FindStrg</keyword>
    <fullCommand>FindStrg(FindStr,Str)</fullCommand>
    <parameters>(FindStr,Str)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FindWord">
    <keyword>FindWord</keyword>
    <fullCommand>FindWord(Str,Word)|(Addr,Word,Len)</fullCommand>
    <parameters>(Str,Word)|(Addr,Word,Len)</parameters>
    <shortDescription>Finds a Word in memory.</shortDescription>
    <longDescription />
  </command>
  <command name="CountByte">
    <keyword>CountByte</keyword>
    <fullCommand>CountByte(Str,Byte)|(Addr,Byte,Len)</fullCommand>
    <parameters>(Str,Byte)|(Addr,Byte,Len)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CountWord">
    <keyword>CountWord</keyword>
    <fullCommand>CountWord(Str,Word)|(Addr,Word,Len)</fullCommand>
    <parameters>(Str,Word)|(Addr,Word,Len)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CountLong">
    <keyword>CountLong</keyword>
    <fullCommand>CountLong(Str,Long)|(Addr,Long,Len)</fullCommand>
    <parameters>(Str,Long)|(Addr,Long,Len)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Big">
    <keyword>Big</keyword>
    <fullCommand>Big(Int,Int)</fullCommand>
    <parameters>(Int,Int)</parameters>
    <shortDescription>Returns biggest.</shortDescription>
    <longDescription />
  </command>
  <command name="Low">
    <keyword>Low</keyword>
    <fullCommand>Low(Int,Int)</fullCommand>
    <parameters>(Int,Int)</parameters>
    <shortDescription>Returns Lowest.</shortDescription>
    <longDescription />
  </command>
  <command name="ArNew">
    <keyword>ArNew</keyword>
    <fullCommand>ArNew(Num[,Kind])</fullCommand>
    <parameters>(Num[,Kind])</parameters>
    <shortDescription>Used to create a new Array.</shortDescription>
    <longDescription />
  </command>
  <command name="ArDispose">
    <keyword>ArDispose</keyword>
    <fullCommand>ArDispose Array</fullCommand>
    <parameters>Array</parameters>
    <shortDescription>Frees memory used by the Array.</shortDescription>
    <longDescription />
  </command>
  <command name="ArLen">
    <keyword>ArLen</keyword>
    <fullCommand>ArLen(Array)</fullCommand>
    <parameters>(Array)</parameters>
    <shortDescription>Returns the length of the Array.</shortDescription>
    <longDescription />
  </command>
  <command name="ArItm">
    <keyword>ArItm</keyword>
    <fullCommand>ArItm(Array)</fullCommand>
    <parameters>(Array)</parameters>
    <shortDescription>Returns the number of items in the Array.</shortDescription>
    <longDescription />
  </command>
  <command name="ArGet">
    <keyword>ArGet</keyword>
    <fullCommand>ArGet(Array,Item)</fullCommand>
    <parameters>(Array,Item)</parameters>
    <shortDescription>Used to get an Item form an Array.</shortDescription>
    <longDescription />
  </command>
  <command name="ArSet">
    <keyword>ArSet</keyword>
    <fullCommand>ArSet(Array,Item,Data[,Data...]</fullCommand>
    <parameters>(Array,Item,Data[,Data...]</parameters>
    <shortDescription>Sets one or more items.</shortDescription>
    <longDescription />
  </command>
  <command name="ArStr">
    <keyword>ArStr</keyword>
    <fullCommand>ArStr(Array,Item)</fullCommand>
    <parameters>(Array,Item)</parameters>
    <shortDescription>Used to get a String from an Array.</shortDescription>
    <longDescription />
  </command>
  <command name="ArOfByte">
    <keyword>ArOfByte</keyword>
    <fullCommand>ArOfByte(Byte[,Byte...])</fullCommand>
    <parameters>(Byte[,Byte...])</parameters>
    <shortDescription>Creates an array of Bytes.</shortDescription>
    <longDescription />
  </command>
  <command name="ArOfWord">
    <keyword>ArOfWord</keyword>
    <fullCommand>ArOfWord(Word[,Word...])</fullCommand>
    <parameters>(Word[,Word...])</parameters>
    <shortDescription>Creates an array of Words.</shortDescription>
    <longDescription />
  </command>
  <command name="ArOfLong">
    <keyword>ArOfLong</keyword>
    <fullCommand>ArOfLong(Long[,Long...])</fullCommand>
    <parameters>(Long[,Long...])</parameters>
    <shortDescription>Creates an array of Longs.</shortDescription>
    <longDescription />
  </command>
  <command name="ArOfStrg">
    <keyword>ArOfStrg</keyword>
    <fullCommand>ArOfStrg(Strg[,Strg...])</fullCommand>
    <parameters>(Strg[,Strg...])</parameters>
    <shortDescription>Creates an array of Strings.</shortDescription>
    <longDescription />
  </command>
  <command name="wbmessage">
    <keyword>wbmessage</keyword>
    <fullCommand>wbmessage</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns location of WBStartup message.</shortDescription>
    <longDescription />
  </command>
  <command name="WBArgs">
    <keyword>WBArgs</keyword>
    <fullCommand>WBArgs</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Returns the number of arguments passed by the Workbench.</shortDescription>
    <longDescription />
  </command>
  <command name="wArg">
    <keyword>wArg</keyword>
    <fullCommand>wArg(Num)</fullCommand>
    <parameters>(Num)</parameters>
    <shortDescription>Used to get WB args.</shortDescription>
    <longDescription />
  </command>
  <command name="ReadArgs">
    <keyword>ReadArgs</keyword>
    <fullCommand>ReadArgs(Template)</fullCommand>
    <parameters>(Template)</parameters>
    <shortDescription>Used to parse CLI args.</shortDescription>
    <longDescription />
  </command>
  <command name="cArg">
    <keyword>cArg</keyword>
    <fullCommand>cArg(Num)</fullCommand>
    <parameters>(Num)</parameters>
    <shortDescription>Used to get CLI args.</shortDescription>
    <longDescription />
  </command>
  <command name="CSaveFirstFrame">
    <keyword>CSaveFirstFrame</keyword>
    <fullCommand>CSaveFirstFrame(BitMap#,FileName$,Width.w,ViewMode.l,Palette#)</fullCommand>
    <parameters>(BitMap#,FileName$,Width.w,ViewMode.l,Palette#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CSaveIff">
    <keyword>CSaveIff</keyword>
    <fullCommand>CSaveIff(BitMap#,FileName$,Width.w,ViewMode.l,Palette#)</fullCommand>
    <parameters>(BitMap#,FileName$,Width.w,ViewMode.l,Palette#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CSaveNextFrame">
    <keyword>CSaveNextFrame</keyword>
    <fullCommand>CSaveNextFrame(BitMap1#,Bitmap2#,FileName$,Width.w,Palette#)</fullCommand>
    <parameters>(BitMap1#,Bitmap2#,FileName$,Width.w,Palette#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Help">
    <keyword>Help</keyword>
    <fullCommand>Help Call BBOnLine-Help Index</fullCommand>
    <parameters>Call BBOnLine-Help Index</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PlayPTModule">
    <keyword>PlayPTModule</keyword>
    <fullCommand>PlayPTModule PTModule#[,position]</fullCommand>
    <parameters>PTModule#[,position]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="StopPTModule">
    <keyword>StopPTModule</keyword>
    <fullCommand>StopPTModule</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTSongPos">
    <keyword>GetPTSongPos</keyword>
    <fullCommand>GetPTSongPos</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTPatternPos">
    <keyword>GetPTPatternPos</keyword>
    <fullCommand>GetPTPatternPos</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTVolume">
    <keyword>SetPTVolume</keyword>
    <fullCommand>SetPTVolume volume</fullCommand>
    <parameters>volume</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTVoicePeriod">
    <keyword>GetPTVoicePeriod</keyword>
    <fullCommand>GetPTVoicePeriod(voice)</fullCommand>
    <parameters>(voice)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTVoiceInstrument">
    <keyword>GetPTVoiceInstrument</keyword>
    <fullCommand>GetPTVoiceInstrument(voice)</fullCommand>
    <parameters>(voice)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTMask">
    <keyword>SetPTMask</keyword>
    <fullCommand>SetPTMask voicebitmap</fullCommand>
    <parameters>voicebitmap</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTMask">
    <keyword>GetPTMask</keyword>
    <fullCommand>GetPTMask</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTSongLoop">
    <keyword>SetPTSongLoop</keyword>
    <fullCommand>SetPTSongLoop on|off</fullCommand>
    <parameters>on|off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTPatLoop">
    <keyword>SetPTPatLoop</keyword>
    <fullCommand>SetPTPatLoop on|off|once</fullCommand>
    <parameters>on|off|once</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Once">
    <keyword>Once</keyword>
    <fullCommand>Once</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTModuleLen">
    <keyword>GetPTModuleLen</keyword>
    <fullCommand>GetPTModuleLen(PTModule#)</fullCommand>
    <parameters>(PTModule#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTPosPattern">
    <keyword>GetPTPosPattern</keyword>
    <fullCommand>GetPTPosPattern(PTModule#,position)</fullCommand>
    <parameters>(PTModule#,position)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTVuLevel">
    <keyword>GetPTVuLevel</keyword>
    <fullCommand>GetPTVuLevel(voice)</fullCommand>
    <parameters>(voice)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTStat">
    <keyword>GetPTStat</keyword>
    <fullCommand>GetPTStat</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTVoiceToggle">
    <keyword>SetPTVoiceToggle</keyword>
    <fullCommand>SetPTVoiceToggle voice</fullCommand>
    <parameters>voice</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTVoiceOn">
    <keyword>SetPTVoiceOn</keyword>
    <fullCommand>SetPTVoiceOn voice</fullCommand>
    <parameters>voice</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTVoiceOff">
    <keyword>SetPTVoiceOff</keyword>
    <fullCommand>SetPTVoiceOff voice</fullCommand>
    <parameters>voice</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTVoiceStat">
    <keyword>GetPTVoiceStat</keyword>
    <fullCommand>GetPTVoiceStat(voice)</fullCommand>
    <parameters>(voice)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTCiaInt">
    <keyword>SetPTCiaInt</keyword>
    <fullCommand>SetPTCiaInt interrupttype</fullCommand>
    <parameters>interrupttype</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTCiaPri">
    <keyword>SetPTCiaPri</keyword>
    <fullCommand>SetPTCiaPri interruptpriority</fullCommand>
    <parameters>interruptpriority</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTCia">
    <keyword>SetPTCia</keyword>
    <fullCommand>SetPTCia</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTVbl">
    <keyword>SetPTVbl</keyword>
    <fullCommand>SetPTVbl</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTZeroSpeed">
    <keyword>SetPTZeroSpeed</keyword>
    <fullCommand>SetPTZeroSpeed on|off</fullCommand>
    <parameters>on|off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PausePTModule">
    <keyword>PausePTModule</keyword>
    <fullCommand>PausePTModule</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ContPTModule">
    <keyword>ContPTModule</keyword>
    <fullCommand>ContPTModule</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTSpeed">
    <keyword>SetPTSpeed</keyword>
    <fullCommand>SetPTSpeed speed</fullCommand>
    <parameters>speed</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTModuleName$">
    <keyword>GetPTModuleName$</keyword>
    <fullCommand>GetPTModuleName$(PTModule#)</fullCommand>
    <parameters>(PTModule#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTInstrumentName$">
    <keyword>GetPTInstrumentName$</keyword>
    <fullCommand>GetPTInstrumentName$(PTModule#,instrumentnumber)</fullCommand>
    <parameters>(PTModule#,instrumentnumber)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTInstrumentAddr">
    <keyword>GetPTInstrumentAddr</keyword>
    <fullCommand>GetPTInstrumentAddr(PTModule#,instrumentnumber)</fullCommand>
    <parameters>(PTModule#,instrumentnumber)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTInstrumentLen">
    <keyword>GetPTInstrumentLen</keyword>
    <fullCommand>GetPTInstrumentLen(PTModule#,instrumentnumber)</fullCommand>
    <parameters>(PTModule#,instrumentnumber)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTInstrumentRepeatStart">
    <keyword>GetPTInstrumentRepeatStart</keyword>
    <fullCommand>GetPTInstrumentRepeatStart(PTModule#,instrumentnumber)</fullCommand>
    <parameters>(PTModule#,instrumentnumber)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTInstrumentRepLen">
    <keyword>GetPTInstrumentRepLen</keyword>
    <fullCommand>GetPTInstrumentRepLen(PTModule#,instrumentnumber)</fullCommand>
    <parameters>(PTModule#,instrumentnumber)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTInstrumentVol">
    <keyword>GetPTInstrumentVol</keyword>
    <fullCommand>GetPTInstrumentVol(PTModule#,instrumentnumber)</fullCommand>
    <parameters>(PTModule#,instrumentnumber)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PTInt">
    <keyword>PTInt</keyword>
    <fullCommand>PTInt</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTNoInt">
    <keyword>SetPTNoInt</keyword>
    <fullCommand>SetPTNoInt</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="PTModule">
    <keyword>PTModule</keyword>
    <fullCommand>PTModule</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="LoadPTModule">
    <keyword>LoadPTModule</keyword>
    <fullCommand>LoadPTModule(PTModule#,filename$)</fullCommand>
    <parameters>(PTModule#,filename$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SavePTModule">
    <keyword>SavePTModule</keyword>
    <fullCommand>SavePTModule(PTModule#,filename$)</fullCommand>
    <parameters>(PTModule#,filename$)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTTempo">
    <keyword>SetPTTempo</keyword>
    <fullCommand>SetPTTempo ciatempo</fullCommand>
    <parameters>ciatempo</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTSpeed">
    <keyword>GetPTSpeed</keyword>
    <fullCommand>GetPTSpeed</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTTempo">
    <keyword>GetPTTempo</keyword>
    <fullCommand>GetPTTempo</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SetPTVoiceVolume">
    <keyword>SetPTVoiceVolume</keyword>
    <fullCommand>SetPTVoiceVolume Voice,Volume</fullCommand>
    <parameters>Voice,Volume</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTVoiceVolume">
    <keyword>GetPTVoiceVolume</keyword>
    <fullCommand>GetPTVoiceVolume(Voice)</fullCommand>
    <parameters>(Voice)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTVoiceNote">
    <keyword>GetPTVoiceNote</keyword>
    <fullCommand>GetPTVoiceNote(Voice)</fullCommand>
    <parameters>(Voice)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="GetPTRealLevel">
    <keyword>GetPTRealLevel</keyword>
    <fullCommand>GetPTRealLevel(voice)</fullCommand>
    <parameters>(voice)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIObject">
    <keyword>MUIObject</keyword>
    <fullCommand>MUIObject A MUI object</fullCommand>
    <parameters>A MUI object</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUISetMaximumTags">
    <keyword>MUISetMaximumTags</keyword>
    <fullCommand>MUISetMaximumTags max</fullCommand>
    <parameters>max</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIApplicationTitle">
    <keyword>MUIApplicationTitle</keyword>
    <fullCommand>MUIApplicationTitle title$</fullCommand>
    <parameters>title$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIApplicationVersion">
    <keyword>MUIApplicationVersion</keyword>
    <fullCommand>MUIApplicationVersion ver$</fullCommand>
    <parameters>ver$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIApplicationCopyright">
    <keyword>MUIApplicationCopyright</keyword>
    <fullCommand>MUIApplicationCopyright copyright$</fullCommand>
    <parameters>copyright$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIApplicationAuthor">
    <keyword>MUIApplicationAuthor</keyword>
    <fullCommand>MUIApplicationAuthor author$</fullCommand>
    <parameters>author$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIApplicationDescription">
    <keyword>MUIApplicationDescription</keyword>
    <fullCommand>MUIApplicationDescription desc$</fullCommand>
    <parameters>desc$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIApplicationBase">
    <keyword>MUIApplicationBase</keyword>
    <fullCommand>MUIApplicationBase base$</fullCommand>
    <parameters>base$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIAddApplicationTags">
    <keyword>MUIAddApplicationTags</keyword>
    <fullCommand>MUIAddApplicationTags &amp;TagList | Tag,Value [,Tag,Value...]</fullCommand>
    <parameters>&amp;TagList | Tag,Value [,Tag,Value...]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICreateApplication">
    <keyword>MUICreateApplication</keyword>
    <fullCommand>MUICreateApplication</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIRemoveApplication">
    <keyword>MUIRemoveApplication</keyword>
    <fullCommand>MUIRemoveApplication</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIApplicationLoc">
    <keyword>MUIApplicationLoc</keyword>
    <fullCommand>MUIApplicationLoc</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIApplicationObj">
    <keyword>MUIApplicationObj</keyword>
    <fullCommand>MUIApplicationObj To MUIObject#</fullCommand>
    <parameters>To MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIAddSubWindow">
    <keyword>MUIAddSubWindow</keyword>
    <fullCommand>MUIAddSubWindow MUIObject#</fullCommand>
    <parameters>MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIFreeObject">
    <keyword>MUIFreeObject</keyword>
    <fullCommand>MUIFreeObject MUIObject#</fullCommand>
    <parameters>MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICreateWindow">
    <keyword>MUICreateWindow</keyword>
    <fullCommand>MUICreateWindow MUIObject#,title$ [,id$ [,MUIObject#]]</fullCommand>
    <parameters>MUIObject#,title$ [,id$ [,MUIObject#]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIOpenWindow">
    <keyword>MUIOpenWindow</keyword>
    <fullCommand>MUIOpenWindow(MUIObject#)</fullCommand>
    <parameters>(MUIObject#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICloseWindow">
    <keyword>MUICloseWindow</keyword>
    <fullCommand>MUICloseWindow MUIObject#</fullCommand>
    <parameters>MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIAddTags">
    <keyword>MUIAddTags</keyword>
    <fullCommand>MUIAddTags MUIObject#,&amp;TagList | MUIObject#,Tag,Value [,Tag,Value...]</fullCommand>
    <parameters>MUIObject#,&amp;TagList | MUIObject#,Tag,Value [,Tag,Value...]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUINewObject">
    <keyword>MUINewObject</keyword>
    <fullCommand>MUINewObject MUIObject#,Class$,&amp;TagList | MUIObject#,Class$,Tag,Value [,Tag,Value...]</fullCommand>
    <parameters>MUIObject#,Class$,&amp;TagList | MUIObject#,Class$,Tag,Value [,Tag,Value...]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIMakeObject">
    <keyword>MUIMakeObject</keyword>
    <fullCommand>MUIMakeObject MUIObject#,Type,&amp;TagList | MUIObject#,Type,Tag,Value [,Tag,Value...]</fullCommand>
    <parameters>MUIObject#,Type,&amp;TagList | MUIObject#,Type,Tag,Value [,Tag,Value...]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIHVSpace">
    <keyword>MUIHVSpace</keyword>
    <fullCommand>MUIHVSpace MUIObject#</fullCommand>
    <parameters>MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIHSpace">
    <keyword>MUIHSpace</keyword>
    <fullCommand>MUIHSpace MUIObject#,x</fullCommand>
    <parameters>MUIObject#,x</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIVSpace">
    <keyword>MUIVSpace</keyword>
    <fullCommand>MUIVSpace MUIObject#,x</fullCommand>
    <parameters>MUIObject#,x</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIKeyString">
    <keyword>MUIKeyString</keyword>
    <fullCommand>MUIKeyString MUIObject#,Contents$,MaxLen,ControlChar$</fullCommand>
    <parameters>MUIObject#,Contents$,MaxLen,ControlChar$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICheckMark">
    <keyword>MUICheckMark</keyword>
    <fullCommand>MUICheckMark MUIObject#,Selected</fullCommand>
    <parameters>MUIObject#,Selected</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIKeyCheckMark">
    <keyword>MUIKeyCheckMark</keyword>
    <fullCommand>MUIKeyCheckMark MUIObject#,Selected,ControlChar$</fullCommand>
    <parameters>MUIObject#,Selected,ControlChar$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUISimpleButton">
    <keyword>MUISimpleButton</keyword>
    <fullCommand>MUISimpleButton MUIObject#,Name$</fullCommand>
    <parameters>MUIObject#,Name$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIKeyButton">
    <keyword>MUIKeyButton</keyword>
    <fullCommand>MUIKeyButton MUIObject#,Name$,Key$</fullCommand>
    <parameters>MUIObject#,Name$,Key$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICycle">
    <keyword>MUICycle</keyword>
    <fullCommand>MUICycle MUIObject#,  Entry$ [,Entry$...] | *Array</fullCommand>
    <parameters>MUIObject#,  Entry$ [,Entry$...] | *Array</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIKeyCycle">
    <keyword>MUIKeyCycle</keyword>
    <fullCommand>MUIKeyCycle MUIObject#,Key$,  Entry$ [,Entry$...] | *Array</fullCommand>
    <parameters>MUIObject#,Key$,  Entry$ [,Entry$...] | *Array</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIRadio">
    <keyword>MUIRadio</keyword>
    <fullCommand>MUIRadio MUIObject#,Name$,  Entry$ [,Entry$...] | *Array</fullCommand>
    <parameters>MUIObject#,Name$,  Entry$ [,Entry$...] | *Array</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIKeyRadio">
    <keyword>MUIKeyRadio</keyword>
    <fullCommand>MUIKeyRadio MUIObject#,Name$,Key$,  Entry$ [,Entry$...] | *Array</fullCommand>
    <parameters>MUIObject#,Name$,Key$,  Entry$ [,Entry$...] | *Array</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUISlider">
    <keyword>MUISlider</keyword>
    <fullCommand>MUISlider MUIObject#,Min,Max,Level</fullCommand>
    <parameters>MUIObject#,Min,Max,Level</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIKeySlider">
    <keyword>MUIKeySlider</keyword>
    <fullCommand>MUIKeySlider MUIObject#,Min,Max,Level,Key$</fullCommand>
    <parameters>MUIObject#,Min,Max,Level,Key$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUILabel">
    <keyword>MUILabel</keyword>
    <fullCommand>MUILabel MUIObject#,Label$,Flags</fullCommand>
    <parameters>MUIObject#,Label$,Flags</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIAddObjHGroup">
    <keyword>MUIAddObjHGroup</keyword>
    <fullCommand>MUIAddObjHGroup To MUIObject#,MUIObject#</fullCommand>
    <parameters>To MUIObject#,MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICreateHGroup">
    <keyword>MUICreateHGroup</keyword>
    <fullCommand>MUICreateHGroup MUIObject#</fullCommand>
    <parameters>MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIAddObjVGroup">
    <keyword>MUIAddObjVGroup</keyword>
    <fullCommand>MUIAddObjVGroup To MUIObject#,MUIObject#</fullCommand>
    <parameters>To MUIObject#,MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICreateVGroup">
    <keyword>MUICreateVGroup</keyword>
    <fullCommand>MUICreateVGroup MUIObject#</fullCommand>
    <parameters>MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUISet">
    <keyword>MUISet</keyword>
    <fullCommand>MUISet MUIObject#,&amp;TagList | MUIObject#,Attr,Value [,Attr,Value...]</fullCommand>
    <parameters>MUIObject#,&amp;TagList | MUIObject#,Attr,Value [,Attr,Value...]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIGet">
    <keyword>MUIGet</keyword>
    <fullCommand>MUIGet(MUIObject#,Attribute)</fullCommand>
    <parameters>(MUIObject#,Attribute)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIDoMethod">
    <keyword>MUIDoMethod</keyword>
    <fullCommand>MUIDoMethod MUIObject#,Method,  Tag [,Tag...] | &amp;TagList</fullCommand>
    <parameters>MUIObject#,Method,  Tag [,Tag...] | &amp;TagList</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUINotify">
    <keyword>MUINotify</keyword>
    <fullCommand>MUINotify MUIObject#,Tag,Value,MUIObject#,  Tag [,Tag...] | &amp;TagList</fullCommand>
    <parameters>MUIObject#,Tag,Value,MUIObject#,  Tag [,Tag...] | &amp;TagList</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIEvent">
    <keyword>MUIEvent</keyword>
    <fullCommand>MUIEvent</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIWaitEvent">
    <keyword>MUIWaitEvent</keyword>
    <fullCommand>MUIWaitEvent</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUINumericButton">
    <keyword>MUINumericButton</keyword>
    <fullCommand>MUINumericButton MUIObject#,Format$,Min,Max</fullCommand>
    <parameters>MUIObject#,Format$,Min,Max</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIAddObjPage">
    <keyword>MUIAddObjPage</keyword>
    <fullCommand>MUIAddObjPage To MUIObject#,MUIObject#</fullCommand>
    <parameters>To MUIObject#,MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICreatePage">
    <keyword>MUICreatePage</keyword>
    <fullCommand>MUICreatePage MUIObject#  ,Page1$ [,Page2$...] | &amp;Page$(0)</fullCommand>
    <parameters>MUIObject#  ,Page1$ [,Page2$...] | &amp;Page$(0)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIList">
    <keyword>MUIList</keyword>
    <fullCommand>MUIList MUIObject#,Format$,Array$()</fullCommand>
    <parameters>MUIObject#,Format$,Array$()</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIListView">
    <keyword>MUIListView</keyword>
    <fullCommand>MUIListView To MUIObject#,MUIObject#</fullCommand>
    <parameters>To MUIObject#,MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIObjLoc">
    <keyword>MUIObjLoc</keyword>
    <fullCommand>MUIObjLoc(MUIObject#)</fullCommand>
    <parameters>(MUIObject#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIRequest">
    <keyword>MUIRequest</keyword>
    <fullCommand>MUIRequest To MUIObject#,Flags,Title$,Gadgets$,Format$  [,Param...]</fullCommand>
    <parameters>To MUIObject#,Flags,Title$,Gadgets$,Format$  [,Param...]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIPopButton">
    <keyword>MUIPopButton</keyword>
    <fullCommand>MUIPopButton MUIObject#,Image</fullCommand>
    <parameters>MUIObject#,Image</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIImageButton">
    <keyword>MUIImageButton</keyword>
    <fullCommand>MUIImageButton MUIObject#,Shape#</fullCommand>
    <parameters>MUIObject#,Shape#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIInsertSingle">
    <keyword>MUIInsertSingle</keyword>
    <fullCommand>MUIInsertSingle MUIObject#,Position,  Entry$ [,Entry$...] | *Array</fullCommand>
    <parameters>MUIObject#,Position,  Entry$ [,Entry$...] | *Array</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIRemoveSingle">
    <keyword>MUIRemoveSingle</keyword>
    <fullCommand>MUIRemoveSingle MUIObject#,Position</fullCommand>
    <parameters>MUIObject#,Position</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIRedrawSingle">
    <keyword>MUIRedrawSingle</keyword>
    <fullCommand>MUIRedrawSingle MUIObject#,Position</fullCommand>
    <parameters>MUIObject#,Position</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIListTitle">
    <keyword>MUIListTitle</keyword>
    <fullCommand>MUIListTitle MUIObject#,  Title$ [,Title$...] | *Array</fullCommand>
    <parameters>MUIObject#,  Title$ [,Title$...] | *Array</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICreateMenu">
    <keyword>MUICreateMenu</keyword>
    <fullCommand>MUICreateMenu MUIObject#,GTMenuList#,Flags [,TitleUData1 [,...]]</fullCommand>
    <parameters>MUIObject#,GTMenuList#,Flags [,TitleUData1 [,...]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUISetMenu">
    <keyword>MUISetMenu</keyword>
    <fullCommand>MUISetMenu To MUIObject#,MUIObject#</fullCommand>
    <parameters>To MUIObject#,MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIFindUData">
    <keyword>MUIFindUData</keyword>
    <fullCommand>MUIFindUData To MUIObject#,MUIObject#,UserData</fullCommand>
    <parameters>To MUIObject#,MUIObject#,UserData</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIBalanceObject">
    <keyword>MUIBalanceObject</keyword>
    <fullCommand>MUIBalanceObject MUIObject#</fullCommand>
    <parameters>MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUINotifyApp">
    <keyword>MUINotifyApp</keyword>
    <fullCommand>MUINotifyApp MUIObject#,Tag,Value,ReturnID</fullCommand>
    <parameters>MUIObject#,Tag,Value,ReturnID</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIAddObjsHGroup">
    <keyword>MUIAddObjsHGroup</keyword>
    <fullCommand>MUIAddObjsHGroup To MUIObject#,MUIObject# [,MUIObject# [,...]]</fullCommand>
    <parameters>To MUIObject#,MUIObject# [,MUIObject# [,...]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIAddObjsVGroup">
    <keyword>MUIAddObjsVGroup</keyword>
    <fullCommand>MUIAddObjsVGroup To MUIObject#,MUIObject# [,MUIObject# [,...]]</fullCommand>
    <parameters>To MUIObject#,MUIObject# [,MUIObject# [,...]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIAddObjsPage">
    <keyword>MUIAddObjsPage</keyword>
    <fullCommand>MUIAddObjsPage To MUIObject#,MUIObject# [,MUIObject# [,...]]</fullCommand>
    <parameters>To MUIObject#,MUIObject# [,MUIObject# [,...]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIBitmapObject">
    <keyword>MUIBitmapObject</keyword>
    <fullCommand>MUIBitmapObject MUIObject#,BitMap# [,Palette#]</fullCommand>
    <parameters>MUIObject#,BitMap# [,Palette#]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIShapeObject">
    <keyword>MUIShapeObject</keyword>
    <fullCommand>MUIShapeObject MUIObject#,Shape# [,Palette#]</fullCommand>
    <parameters>MUIObject#,Shape# [,Palette#]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIChangeBitmap">
    <keyword>MUIChangeBitmap</keyword>
    <fullCommand>MUIChangeBitmap MUIObject#,BitMap# [,Palette#]</fullCommand>
    <parameters>MUIObject#,BitMap# [,Palette#]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIChangeShape">
    <keyword>MUIChangeShape</keyword>
    <fullCommand>MUIChangeShape MUIObject#,Shape# [,Palette#]</fullCommand>
    <parameters>MUIObject#,Shape# [,Palette#]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIRedraw">
    <keyword>MUIRedraw</keyword>
    <fullCommand>MUIRedraw MUIObject#,Flags</fullCommand>
    <parameters>MUIObject#,Flags</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIListHook">
    <keyword>MUIListHook</keyword>
    <fullCommand>MUIListHook On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIChangeList">
    <keyword>MUIChangeList</keyword>
    <fullCommand>MUIChangeList MUIObject# [,Array$(),Position]</fullCommand>
    <parameters>MUIObject# [,Array$(),Position]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIGetCM">
    <keyword>MUIGetCM</keyword>
    <fullCommand>MUIGetCM(MUIObject#)</fullCommand>
    <parameters>(MUIObject#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIGetCycle">
    <keyword>MUIGetCycle</keyword>
    <fullCommand>MUIGetCycle(MUIObject#)</fullCommand>
    <parameters>(MUIObject#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIGetString$">
    <keyword>MUIGetString$</keyword>
    <fullCommand>MUIGetString$(MUIObject#)</fullCommand>
    <parameters>(MUIObject#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUISetCM">
    <keyword>MUISetCM</keyword>
    <fullCommand>MUISetCM MUIObject#,Selected</fullCommand>
    <parameters>MUIObject#,Selected</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUISetCycle">
    <keyword>MUISetCycle</keyword>
    <fullCommand>MUISetCycle MUIObject#,Selected</fullCommand>
    <parameters>MUIObject#,Selected</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUISetString">
    <keyword>MUISetString</keyword>
    <fullCommand>MUISetString MUIObject#,String$</fullCommand>
    <parameters>MUIObject#,String$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUINList">
    <keyword>MUINList</keyword>
    <fullCommand>MUINList MUIObject#,Format$,Array$()</fullCommand>
    <parameters>MUIObject#,Format$,Array$()</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUINListView">
    <keyword>MUINListView</keyword>
    <fullCommand>MUINListView To MUIObject#,MUIObject#</fullCommand>
    <parameters>To MUIObject#,MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUINListHook">
    <keyword>MUINListHook</keyword>
    <fullCommand>MUINListHook On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIBetterString">
    <keyword>MUIBetterString</keyword>
    <fullCommand>MUIBetterString MUIObject#,Contents$,MaxLen</fullCommand>
    <parameters>MUIObject#,Contents$,MaxLen</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIKeyBetterString">
    <keyword>MUIKeyBetterString</keyword>
    <fullCommand>MUIKeyBetterString MUIObject#,Contents$,MaxLen,ControlChar$</fullCommand>
    <parameters>MUIObject#,Contents$,MaxLen,ControlChar$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICreateHVirtGroup">
    <keyword>MUICreateHVirtGroup</keyword>
    <fullCommand>MUICreateHVirtGroup MUIObject#</fullCommand>
    <parameters>MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICreateVVirtGroup">
    <keyword>MUICreateVVirtGroup</keyword>
    <fullCommand>MUICreateVVirtGroup MUIObject#</fullCommand>
    <parameters>MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIBetterBalance">
    <keyword>MUIBetterBalance</keyword>
    <fullCommand>MUIBetterBalance MUIObject#</fullCommand>
    <parameters>MUIObject#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIWeight">
    <keyword>MUIWeight</keyword>
    <fullCommand>MUIWeight MUIObject#,Lbs</fullCommand>
    <parameters>MUIObject#,Lbs</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIVertWeight">
    <keyword>MUIVertWeight</keyword>
    <fullCommand>MUIVertWeight MUIObject#,Lbs</fullCommand>
    <parameters>MUIObject#,Lbs</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIHorizWeight">
    <keyword>MUIHorizWeight</keyword>
    <fullCommand>MUIHorizWeight MUIObject#,Lbs</fullCommand>
    <parameters>MUIObject#,Lbs</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICycleChain">
    <keyword>MUICycleChain</keyword>
    <fullCommand>MUICycleChain MUIObject#,Chain</fullCommand>
    <parameters>MUIObject#,Chain</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICycleChains">
    <keyword>MUICycleChains</keyword>
    <fullCommand>MUICycleChains Chain,MUIObject# [,MUIObject# [,...]]</fullCommand>
    <parameters>Chain,MUIObject# [,MUIObject# [,...]]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIGroupSpacing">
    <keyword>MUIGroupSpacing</keyword>
    <fullCommand>MUIGroupSpacing MUIObject#,Pixels</fullCommand>
    <parameters>MUIObject#,Pixels</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIGroupVSpacing">
    <keyword>MUIGroupVSpacing</keyword>
    <fullCommand>MUIGroupVSpacing MUIObject#,Pixels</fullCommand>
    <parameters>MUIObject#,Pixels</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIGroupHSpacing">
    <keyword>MUIGroupHSpacing</keyword>
    <fullCommand>MUIGroupHSpacing MUIObject#,Pixels</fullCommand>
    <parameters>MUIObject#,Pixels</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIText">
    <keyword>MUIText</keyword>
    <fullCommand>MUIText MUIObject#,Contents$,SetVMax</fullCommand>
    <parameters>MUIObject#,Contents$,SetVMax</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUITextContents">
    <keyword>MUITextContents</keyword>
    <fullCommand>MUITextContents MUIObject#,Contents$</fullCommand>
    <parameters>MUIObject#,Contents$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIShortHelp">
    <keyword>MUIShortHelp</keyword>
    <fullCommand>MUIShortHelp MUIObject#,Help$</fullCommand>
    <parameters>MUIObject#,Help$</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIHookToNList">
    <keyword>MUIHookToNList</keyword>
    <fullCommand>MUIHookToNList MUIObject#,Format$,*Construct,*Display,*Destruct</fullCommand>
    <parameters>MUIObject#,Format$,*Construct,*Display,*Destruct</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUINListEntries">
    <keyword>MUINListEntries</keyword>
    <fullCommand>MUINListEntries(MUIObject#)</fullCommand>
    <parameters>(MUIObject#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUINListGetActive">
    <keyword>MUINListGetActive</keyword>
    <fullCommand>MUINListGetActive(MUIObject#)</fullCommand>
    <parameters>(MUIObject#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUINListSetActive">
    <keyword>MUINListSetActive</keyword>
    <fullCommand>MUINListSetActive MUIObject#,Entry</fullCommand>
    <parameters>MUIObject#,Entry</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIAllocDispatcherHook">
    <keyword>MUIAllocDispatcherHook</keyword>
    <fullCommand>MUIAllocDispatcherHook(*HookTo)</fullCommand>
    <parameters>(*HookTo)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUINewObjectClass">
    <keyword>MUINewObjectClass</keyword>
    <fullCommand>MUINewObjectClass MUIObject#,ClassPtr,ClassID,&amp;TagList</fullCommand>
    <parameters>MUIObject#,ClassPtr,ClassID,&amp;TagList</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICreateCustomClass">
    <keyword>MUICreateCustomClass</keyword>
    <fullCommand>MUICreateCustomClass(Base,Supername$,SuperMCC,DataSize,DispatcherHook)</fullCommand>
    <parameters>(Base,Supername$,SuperMCC,DataSize,DispatcherHook)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIDeleteCustomClass">
    <keyword>MUIDeleteCustomClass</keyword>
    <fullCommand>MUIDeleteCustomClass(*MCC)</fullCommand>
    <parameters>(*MCC)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICDoMethodA">
    <keyword>MUICDoMethodA</keyword>
    <fullCommand>MUICDoMethodA(Obj,Message)</fullCommand>
    <parameters>(Obj,Message)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICDoMethod">
    <keyword>MUICDoMethod</keyword>
    <fullCommand>MUICDoMethod(Obj,MethodID,Tag[,Tag..])</fullCommand>
    <parameters>(Obj,MethodID,Tag[,Tag..])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIDoSuperMethodA">
    <keyword>MUIDoSuperMethodA</keyword>
    <fullCommand>MUIDoSuperMethodA(Class,Obj,Message)</fullCommand>
    <parameters>(Class,Obj,Message)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUIDoSuperMethod">
    <keyword>MUIDoSuperMethod</keyword>
    <fullCommand>MUIDoSuperMethod(Class,Obj,MethodID,Tag[,Tag..])</fullCommand>
    <parameters>(Class,Obj,MethodID,Tag[,Tag..])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICoerceMethodA">
    <keyword>MUICoerceMethodA</keyword>
    <fullCommand>MUICoerceMethodA(Class,Obj,Message)</fullCommand>
    <parameters>(Class,Obj,Message)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUICoerceMethod">
    <keyword>MUICoerceMethod</keyword>
    <fullCommand>MUICoerceMethod(Class,Obj,MethodID,Tag[,Tag..])</fullCommand>
    <parameters>(Class,Obj,MethodID,Tag[,Tag..])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="MUISetSuperAttrs">
    <keyword>MUISetSuperAttrs</keyword>
    <fullCommand>MUISetSuperAttrs(Class,Obj,Tag[,Tag..])</fullCommand>
    <parameters>(Class,Obj,Tag[,Tag..])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Blink">
    <keyword>Blink</keyword>
    <fullCommand>Blink &lt;number of blinks&gt;</fullCommand>
    <parameters>&lt;number of blinks&gt;</parameters>
    <shortDescription>Blinks the LED &lt;n&gt; times.</shortDescription>
    <longDescription />
  </command>
  <command name="LEDStatus">
    <keyword>LEDStatus</keyword>
    <fullCommand>LEDStatus</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>word=LEDStatus - returns -1 if LED is off, 0 if it's on.</shortDescription>
    <longDescription />
  </command>
  <command name="Crash">
    <keyword>Crash</keyword>
    <fullCommand>Crash</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Probably the most useful command EVER! :) (Use it 4 unreg. progs :).</shortDescription>
    <longDescription />
  </command>
  <command name="NoCrash">
    <keyword>NoCrash</keyword>
    <fullCommand>NoCrash &lt;On/Off&gt;</fullCommand>
    <parameters>&lt;On/Off&gt;</parameters>
    <shortDescription>Disables Crash statement (use if you're still debugging).</shortDescription>
    <longDescription />
  </command>
  <command name="FindColor">
    <keyword>FindColor</keyword>
    <fullCommand>FindColor(Pal#,Red,Green,Blue[,Tolerance])</fullCommand>
    <parameters>(Pal#,Red,Green,Blue[,Tolerance])</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ColorGrey">
    <keyword>ColorGrey</keyword>
    <fullCommand>ColorGrey(Pal#,Color#)</fullCommand>
    <parameters>(Pal#,Color#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="ColorToGrey">
    <keyword>ColorToGrey</keyword>
    <fullCommand>ColorToGrey(Pal#,Color#)</fullCommand>
    <parameters>(Pal#,Color#)</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="SaveILBM">
    <keyword>SaveILBM</keyword>
    <fullCommand>SaveILBM BitMap#,Filename$,BtmHeader,ViewMode.l,Palette#</fullCommand>
    <parameters>BitMap#,Filename$,BtmHeader,ViewMode.l,Palette#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NChunky">
    <keyword>NChunky</keyword>
    <fullCommand>NChunky is a Chunky Buffer from the BDChunkyLib</fullCommand>
    <parameters>is a Chunky Buffer from the BDChunkyLib</parameters>
    <shortDescription>-).</shortDescription>
    <longDescription />
  </command>
  <command name="InitNChunky">
    <keyword>InitNChunky</keyword>
    <fullCommand>InitNChunky NChunky#,Width.l,Height.l</fullCommand>
    <parameters>NChunky#,Width.l,Height.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NChunkyToBtmA">
    <keyword>NChunkyToBtmA</keyword>
    <fullCommand>NChunkyToBtmA *AddrNChunky.l, *AddrBitMap.l</fullCommand>
    <parameters>*AddrNChunky.l, *AddrBitMap.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BtmToNChunkyA">
    <keyword>BtmToNChunkyA</keyword>
    <fullCommand>BtmToNChunkyA *AddrBtm.l, *AddrNChunky.l</fullCommand>
    <parameters>*AddrBtm.l, *AddrNChunky.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCPlot">
    <keyword>NCPlot</keyword>
    <fullCommand>NCPlot NChunky#, x.l, y.l, colour.b</fullCommand>
    <parameters>NChunky#, x.l, y.l, colour.b</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCPoint">
    <keyword>NCPoint</keyword>
    <fullCommand>NCPoint( NChunky#, x.l, y.l )</fullCommand>
    <parameters>( NChunky#, x.l, y.l )</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCBoxF">
    <keyword>NCBoxF</keyword>
    <fullCommand>NCBoxF NChunky#, x1.l, y1.l, x2.l, y2.l, colour.b</fullCommand>
    <parameters>NChunky#, x1.l, y1.l, x2.l, y2.l, colour.b</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCBox">
    <keyword>NCBox</keyword>
    <fullCommand>NCBox NChunky#, x1.l, y1.l, x2.l, y2.l, colour.b</fullCommand>
    <parameters>NChunky#, x1.l, y1.l, x2.l, y2.l, colour.b</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopyNChunky">
    <keyword>CopyNChunky</keyword>
    <fullCommand>CopyNChunky NChunkySrc#, NChunkyDest#</fullCommand>
    <parameters>NChunkySrc#, NChunkyDest#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCCls">
    <keyword>NCCls</keyword>
    <fullCommand>NCCls NChunky# [,colour.b ]</fullCommand>
    <parameters>NChunky# [,colour.b ]</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NChunkyToBtm">
    <keyword>NChunkyToBtm</keyword>
    <fullCommand>NChunkyToBtm NChunky#, BitMap#</fullCommand>
    <parameters>NChunky#, BitMap#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="BtmToNChunky">
    <keyword>BtmToNChunky</keyword>
    <fullCommand>BtmToNChunky BitMap#, NChunky#</fullCommand>
    <parameters>BitMap#, NChunky#</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="InitNChunkyA">
    <keyword>InitNChunkyA</keyword>
    <fullCommand>InitNChunkyA( Width.l,Height.l )</fullCommand>
    <parameters>( Width.l,Height.l )</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="FreeNChunkyA">
    <keyword>FreeNChunkyA</keyword>
    <fullCommand>FreeNChunkyA( *AddrNChunky )</fullCommand>
    <parameters>( *AddrNChunky )</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCPlotA">
    <keyword>NCPlotA</keyword>
    <fullCommand>NCPlotA *AddrNChunky.l, x.l, y.l, colour.b</fullCommand>
    <parameters>*AddrNChunky.l, x.l, y.l, colour.b</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCPointA">
    <keyword>NCPointA</keyword>
    <fullCommand>NCPointA( *AddrNChunky.l, x.l, y.l )</fullCommand>
    <parameters>( *AddrNChunky.l, x.l, y.l )</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCBoxFA">
    <keyword>NCBoxFA</keyword>
    <fullCommand>NCBoxFA *AddrNChunky.l ,x1.l ,y1.l ,x2.l ,y2.l ,colour.b</fullCommand>
    <parameters>*AddrNChunky.l ,x1.l ,y1.l ,x2.l ,y2.l ,colour.b</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCBoxA">
    <keyword>NCBoxA</keyword>
    <fullCommand>NCBoxA *AddrNChunky.l ,x1.l ,y1.l ,x2.l ,y2.l ,colour.b</fullCommand>
    <parameters>*AddrNChunky.l ,x1.l ,y1.l ,x2.l ,y2.l ,colour.b</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="CopyNChunkyA">
    <keyword>CopyNChunkyA</keyword>
    <fullCommand>CopyNChunkyA *AddrNChunkySrc.l ,*AddrNChunkyDest.l</fullCommand>
    <parameters>*AddrNChunkySrc.l ,*AddrNChunkyDest.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="NCClsA">
    <keyword>NCClsA</keyword>
    <fullCommand>NCClsA *AddrNChunky.l ,colour.b</fullCommand>
    <parameters>*AddrNChunky.l ,colour.b</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemapNChunkyLineA">
    <keyword>RemapNChunkyLineA</keyword>
    <fullCommand>RemapNChunkyLineA *AddrNChunky.l ,y.l ,&amp;RemapTable.l</fullCommand>
    <parameters>*AddrNChunky.l ,y.l ,&amp;RemapTable.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemapNChunkyLine">
    <keyword>RemapNChunkyLine</keyword>
    <fullCommand>RemapNChunkyLine NChunky# ,y.l ,&amp;RemapTable.l</fullCommand>
    <parameters>NChunky# ,y.l ,&amp;RemapTable.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemapNChunkyPointA">
    <keyword>RemapNChunkyPointA</keyword>
    <fullCommand>RemapNChunkyPointA *AddrNChunky.l ,x, y.l ,&amp;RemapTable.l</fullCommand>
    <parameters>*AddrNChunky.l ,x, y.l ,&amp;RemapTable.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="RemapNChunkyPoint">
    <keyword>RemapNChunkyPoint</keyword>
    <fullCommand>RemapNChunkyPoint NChunky# ,x.l ,y.l ,&amp;RemapTable.l</fullCommand>
    <parameters>NChunky# ,x.l ,y.l ,&amp;RemapTable.l</parameters>
    <shortDescription />
    <longDescription />
  </command>
  <command name="Goto">
    <keyword>Goto</keyword>
    <fullCommand>Goto Program Label</fullCommand>
    <parameters>Program Label</parameters>
    <shortDescription />
    <longDescription>Goto causes program flow to be transferred to the specified program label. This
allows sections of a program to be 'skipped' or 'repeated'.</longDescription>
  </command>
  <command name="Gosub">
    <keyword>Gosub</keyword>
    <fullCommand>Gosub Program Label</fullCommand>
    <parameters>Program Label</parameters>
    <shortDescription />
    <longDescription>Gosub operates in two steps. First, the location of the instruction following the
Gosub is remembered in a special storage area (known as the 'stack'). Secondly,
program flow is transferred to the specified Program Label.

The section of program that program flow is transferred to is known as a
'subroutine' and should be terminated by a Return command.</longDescription>
  </command>
  <command name="Return">
    <keyword>Return</keyword>
    <fullCommand>Return</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Return is used to return program flow to the instruction following the previously
executed Gosub command. This allows the creation of 'subroutines' which may be
called from various points in a program.</longDescription>
  </command>
  <command name="On">
    <keyword>On</keyword>
    <fullCommand>On Expression Goto|Gosub Program Label[,Program Label...]</fullCommand>
    <parameters>Expression Goto|Gosub Program Label[,Program Label...]</parameters>
    <shortDescription />
    <longDescription>On allows a program to branch, via either a Goto or a Gosub, to one of a number of
Program Labels depending upon the result of the specified Expression.

If the specified Expression results in a 1, then the first Program Label will be
branched to. A result of 2 will cause the second Program Label to be branched to and
so on. If the result of Expression is less than one, or not enough

Program Labels are supplied, program flow will continue without a branch.</longDescription>
  </command>
  <command name="End">
    <keyword>End</keyword>
    <fullCommand>End</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>End will halt program flow completely. In the case of programs run from the Blitz
editor, you will be returned to the editor. In the case of executable files, you
will be returned to the Workbench or CLI.</longDescription>
  </command>
  <command name="Stop">
    <keyword>Stop</keyword>
    <fullCommand>Stop</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>The Stop command causes the Blitz Debugger to interrupt program flow. Place Stop
commands in your code as breakpoints when debugging, ensure runtime errors are
enabled. Click on Run from the debugger to continue program flow after a Stop.</longDescription>
  </command>
  <command name="If">
    <keyword>If</keyword>
    <fullCommand>If Expression [Then...]</fullCommand>
    <parameters>Expression [Then...]</parameters>
    <shortDescription />
    <longDescription>If allows execution of a section of program depending on the result of an
expression. The Then command indicates only the rest of the line will be defined as
the section of code to either execute or not. Without a Then the section of code
will be defined as that up to the EndIf command.</longDescription>
  </command>
  <command name="EndIf">
    <keyword>EndIf</keyword>
    <fullCommand>EndIf</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>EndIf is used to terminate an 'If block'. An If block is begun by use of the If
statement without the Then present. Please refer to If for more information on If
blocks.</longDescription>
  </command>
  <command name="Else">
    <keyword>Else</keyword>
    <fullCommand>Else [Statement..]</fullCommand>
    <parameters>[Statement..]</parameters>
    <shortDescription />
    <longDescription>Else may be used after an If to cause program instructions to be executed if the
expression specified in the If proved to be false.</longDescription>
  </command>
  <command name="While">
    <keyword>While</keyword>
    <fullCommand>While Expression</fullCommand>
    <parameters>Expression</parameters>
    <shortDescription />
    <longDescription>The While command is used to execute a series of commands repeatedly while the
specified Expression proves to be true. The cAmmands to be executed include all the
commands following the While until the next matching Wend.</longDescription>
  </command>
  <command name="Wend">
    <keyword>Wend</keyword>
    <fullCommand>Wend</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Wend is used in conjunction with While to determine a section of program to be
executed repeatedly based upon the truth of an expression.</longDescription>
  </command>
  <command name="Select">
    <keyword>Select</keyword>
    <fullCommand>Select Expression</fullCommand>
    <parameters>Expression</parameters>
    <shortDescription />
    <longDescription>Select examines and 'remembers' the result of the specified Expression. The Case
commands may then be used to execute different sections of program code depending on
the result of the expression in the Select line.</longDescription>
  </command>
  <command name="Case">
    <keyword>Case</keyword>
    <fullCommand>Case Expression</fullCommand>
    <parameters>Expression</parameters>
    <shortDescription />
    <longDescription>A Case is used following a Select to execute a section of program code when, and
only when, the Expression specified in the Case statement is equivalent to the
Expression evaluated in the Select statement.

If a Case statement is satisfied, program flow will continue until the next Case
Default or End Select statement is encountered, at which point program flow will
branch to the next matching End Select.</longDescription>
  </command>
  <command name="Default">
    <keyword>Default</keyword>
    <fullCommand>Default</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>A Default statement may appear following a series of Case statements to cause a
section of program code to be executed if NONE of the Case statements were
satisfied.</longDescription>
  </command>
  <command name="For">
    <keyword>For</keyword>
    <fullCommand>For Var=Expression 1 To Expression2 [Step Expression3]</fullCommand>
    <parameters>Var=Expression 1 To Expression2 [Step Expression3]</parameters>
    <shortDescription />
    <longDescription>The For statement initializes a For...Next loop. All For/Next loops must begin with
a For statement, and must have a terminating Next statement further down the
program. For..Next loops cause a particular section of code to be repeated a certain
number of times.

The For statement does most of the work in a For/Next loop. When For is executed,
the variable specified by Var (known as the index variable) will be set to the value
Expressionl. After this, the actual loop commences.

At the beginning of the loop, a check is made to see if the value of Var has
exceeded Expression2. If so, program flow will branch to the command following the
For/Next loop's Next, ending the loop. If not, program flow continues on until the
loop's Next is reached.

At this point, the value specified in Expression3 (the 'step' value) is added to
Var, and program flow is sent back to the top of the loop, where Var is again
checked against Expression2. If Expression3 is omitted, a default step value of I
will be used.

In order for a For/Next loop to count 'down' from one value to a lower value, a
negative step number must be supplied.</longDescription>
  </command>
  <command name="Next">
    <keyword>Next</keyword>
    <fullCommand>Next [var[,Var..]]</fullCommand>
    <parameters>[var[,Var..]]</parameters>
    <shortDescription />
    <longDescription>Next terminates a For..Next loop. Please refer to the For command for more
information on For..Next loops.</longDescription>
  </command>
  <command name="Repeat">
    <keyword>Repeat</keyword>
    <fullCommand>Repeat</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Repeat is used to begin a Repeat...Until loop. Each Repeat statement in a program
must have a corresponding Until further down the program.

The purpose of Repeat/Until loops is to cause a section of code to be executed AT
LEAST ONCE before a test is made to see if the code should be executed again.</longDescription>
  </command>
  <command name="Until">
    <keyword>Until</keyword>
    <fullCommand>Until Expression</fullCommand>
    <parameters>Expression</parameters>
    <shortDescription />
    <longDescription>Until is used to terminate a Repeat/Until loop. If Expression proves to be true (non
0), then program flow will continue from the command following Until. If Expression
proves to be false (0), then program flow will go back to the corresponding Repeat,
found further up the program.</longDescription>
  </command>
  <command name="Forever">
    <keyword>Forever</keyword>
    <fullCommand>Forever</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Forever may be used instead of Until to cause a Repeat/Until loop to NEVER exit.
Executing Forever is identical to executing 'Until 0'.</longDescription>
  </command>
  <command name="Pop">
    <keyword>Pop</keyword>
    <fullCommand>Pop Gosub|For|Select|If|While|Repeat</fullCommand>
    <parameters>Gosub|For|Select|If|While|Repeat</parameters>
    <shortDescription />
    <longDescription>Sometimes, it may be necessary to exit from a particular type of program loop in
order to transfer program flow to a different part of the program. Pop must be
included before the Goto which transfers program flow out from the inside of the
loop.

Actually, Pop is only necessary to prematurely terminate Gosubs, Fors and Selects.
If, While and Repeat have been included for completeness but are not necessary.</longDescription>
  </command>
  <command name="MouseWait">
    <keyword>MouseWait</keyword>
    <fullCommand>MouseWait</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>MouseWait simply halts program flow until the left mouse button is pushed. If the
left mouse button is already held down when a MouseWait is executed, program flow
will simply continue through.

MouseWait should normally be used only for program testing purposes, as MouseWait
severely slows down multi-tasking.</longDescription>
  </command>
  <command name="VWait">
    <keyword>VWait</keyword>
    <fullCommand>VWait [Frames]</fullCommand>
    <parameters>[Frames]</parameters>
    <shortDescription />
    <longDescription>VWait will cause program flow to halt until the next vertical blank occurs. The
optional Frames parameter may be used to wait for a particular number of vertical
blanks.

VWait is especially useful in animation for synchrodizing display changes with the
rate at which the display is physically redrawn by the monitor.</longDescription>
  </command>
  <command name="Statement">
    <keyword>Statement</keyword>
    <fullCommand>Statement Procedurename{[Parameter1[,Paramater2...]]}</fullCommand>
    <parameters>Procedurename{[Parameter1[,Paramater2...]]}</parameters>
    <shortDescription />
    <longDescription>Statement Return may be used to prematurely exit from a 'statement type' procedure.
Program flow will return to the command following the procedure call.</longDescription>
  </command>
  <command name="Function">
    <keyword>Function</keyword>
    <fullCommand>Function [.Type] Procedurename{[Parameter1[,Parameter2...]]}</fullCommand>
    <parameters>[.Type] Procedurename{[Parameter1[,Parameter2...]]}</parameters>
    <shortDescription />
    <longDescription>Function Return allows 'function type' procedures to return values to their calling
expressions. Function type procedures are always called from within Blitz
expressions.</longDescription>
  </command>
  <command name="Shared">
    <keyword>Shared</keyword>
    <fullCommand>Shared Var[,Var...]</fullCommand>
    <parameters>Var[,Var...]</parameters>
    <shortDescription />
    <longDescription>Shared is used to declare certain variables within a procedure definition as being
global variables. Any variables appearing within a procedure definition that do not
appear in a Shared statement are, by default, local variables.</longDescription>
  </command>
  <command name="Setint">
    <keyword>Setint</keyword>
    <fullCommand>Setint Type</fullCommand>
    <parameters>Type</parameters>
    <shortDescription />
    <longDescription>Setint is used to declare a section of program code as 'interrupt' code. Often, when
a computer program is running, an event of some importance takes place which must be
processed immediately. The different types of interrupt on the Amiga are as follows:


Type    Cause of Interupt 

()      Serial transmit buffer empty
1       Disk Block read/written
2       Software interupt
3       Cia ports interupt
4       Co-processor ('copper') interupt
5       Vertical Blank interupt
6       glitter finished
7       Audio channel 0 pointer/length fetched
8       Audio channel I pointer/length fetched
9       Audio channel 2 pointer/length fetched
10      Audio channel 3 pointer/length fetched
11      Serial receive butffer full
12      Floppy disk sync
13      External interupt


The most useful of these interrupts is the vertical blank interrupt. This interrupt
occurs every time an entire video frame has been fully displayed (about every
sixtieth of a second), and is very useful for animation purposes. If a section of
program code has been designated as a vertical blank interrupt handler, then that
section of code will be executed every sixtieth of a second.

Interrupt handlers must perform their task as quickly as possible, especially in the
case of vertical blank handlers which must NEVER take longer than one sixtieth of a
second to execute.

Interupt handlers in Blitz must NEVER access string variables or literal strings. In
Blitz mode, this is the only restriction on interrupt handlers. In Amiga mode, no
blister, Intuition or file i/o commands may be executed by interrupt handlers.

To set up a section of code to be used as an interrupt handler, you use the SetInt
command followed by the actual interrupt handler code. An End SetInt should follow
the interrupt code. The Type parameter specifies the type of interrupt, from the
above table, the interrupt handler should be attached to. For example, SetInt 5
should be used for vertical blank interrupt code.

More than one interrupt handler may be attached to a particular type of interrupt.</longDescription>
  </command>
  <command name="Clrlnt">
    <keyword>Clrlnt</keyword>
    <fullCommand>Clrlnt Type</fullCommand>
    <parameters>Type</parameters>
    <shortDescription />
    <longDescription>ClrInt may be used to remove any interrupt handlers currently attached to the
specified interrupt Type. The SetInt command is used to attach interupt handlers to
particular interupts.</longDescription>
  </command>
  <command name="SetErr">
    <keyword>SetErr</keyword>
    <fullCommand>SetErr</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>The SetErr command allows you to set up custom error handlers. Program code which
appears after the SetErr command will be executed when any Blitz runtime errors are
caused. Custom error code should be ended by an End SetErr.</longDescription>
  </command>
  <command name="ClrErr">
    <keyword>ClrErr</keyword>
    <fullCommand>ClrErr</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>ClrErr may be used to remove a custom error handler set up using SetErr.</longDescription>
  </command>
  <command name="ErrFail">
    <keyword>ErrFail</keyword>
    <fullCommand>ErrFail</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>ErrFail may be used within custom error handlers to cause a 'normal' error. The
error which caused the custom error handler to be executed will be reported and
transfer will be passed to direct mode.</longDescription>
  </command>
  <command name="Let">
    <keyword>Let</keyword>
    <fullCommand>Let Var=Expression</fullCommand>
    <parameters>Var=Expression</parameters>
    <shortDescription />
    <longDescription>Let is an optional command used t&amp;lt;&amp;gt; assign a value to a variable. Let must always be
followed by a variable name and an expression. Normally, an equals sign ('=') is
placed between the variable name and the expression. If the equals sign is omitted,
then an operator (eg: '+', '*') must appear between the variable name and the
expression. In this case, the specified variable will be altered by the specified
operator and expression.</longDescription>
  </command>
  <command name="Exchange">
    <keyword>Exchange</keyword>
    <fullCommand>Exchange Var,Var</fullCommand>
    <parameters>Var,Var</parameters>
    <shortDescription />
    <longDescription>Exchange will 'swap' the values contained in the 2 specified variables. Exchange may
only be used with 2 variables of the same type.</longDescription>
  </command>
  <command name="MaxLen">
    <keyword>MaxLen</keyword>
    <fullCommand>MaxLen StringVar=Expression</fullCommand>
    <parameters>StringVar=Expression</parameters>
    <shortDescription />
    <longDescription>MaxLen sets aside a block c&amp;gt;f memory for a string variable to grow into. This is
normally only necessary in the case of special Blitz commands which require this
space to be present before execution. Currently, only 2 Blitz commands require the
use of MaxLen:FileRequest$ and Fields.</longDescription>
  </command>
  <command name="DEFTYPE">
    <keyword>DEFTYPE</keyword>
    <fullCommand>DEFTYPE .Typename [Var[,Var...]]</fullCommand>
    <parameters>.Typename [Var[,Var...]]</parameters>
    <shortDescription />
    <longDescription>DEFTYPE may be used to declare a list of variables as being of a particular type. In
this case, Var parameters must be supplied.

DEFTYPE may also be used to select a default variable type for future 'unknown'
variables. Unknown variables are variables created with no Typename specifier. In
this case, no Var parameters are supplied.</longDescription>
  </command>
  <command name="NEWTYPE.Typename">
    <keyword>NEWTYPE.Typename</keyword>
    <fullCommand>NEWTYPE.Typename</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>NEWTYPE is used to create a custom variable type. NEWTYPE must be followed by a list
of entry names separated by colons (':') and/or newlines. NEWTYPEs are terminated
using End NEWTYPE.</longDescription>
  </command>
  <command name="SizeOf.Typename[,Entrypath]">
    <keyword>SizeOf.Typename[,Entrypath]</keyword>
    <fullCommand>SizeOf.Typename[,Entrypath]</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>SizeOf allows you to determine the amount of memory, in bytes, a particular variable
type takes up. SizeOf may also be followed by an optional Entrypath, in which case
the offset from the start of the type to the specified entry is returned.</longDescription>
  </command>
  <command name="Dim">
    <keyword>Dim</keyword>
    <fullCommand>Dim Arrayname [List] (Dimensionl[,Dimension2...])</fullCommand>
    <parameters>Arrayname [List] (Dimensionl[,Dimension2...])</parameters>
    <shortDescription />
    <longDescription>Dim is used to initialize a BASIC array. Blitz supports 2 array types - simple
arrays, and list arrays. The optional List parameter, if present, denotes a list
array. Simple arrays are identical to standard BASIC arrays, and may be of any
number dimensions. List arrays may be of only 1 dimension.</longDescription>
  </command>
  <command name="Additem">
    <keyword>Additem</keyword>
    <fullCommand>Additem (Arrayname())</fullCommand>
    <parameters>(Arrayname())</parameters>
    <shortDescription />
    <longDescription>The AddItem function allows you to insert an array list item after the list array's
'current' item. AddItem returns a true/false value reflecting whether or not there
was enough room in the array list to add an element. If an array element was
available, Additem returns a true value (-1), and sets the list array's 'current
item' pointer to the item added. If no array element was available, Additem returns
false (0).</longDescription>
  </command>
  <command name="Previtem">
    <keyword>Previtem</keyword>
    <fullCommand>Previtem (Arrayname())</fullCommand>
    <parameters>(Arrayname())</parameters>
    <shortDescription />
    <longDescription>Previtem will set the specified list array's 'current item' pointer to the item
before the list array's old current item. This allows for 'backwards' processing of
a list array. Previtem returns a true/false value reflecting whether or not there
actually was a previous item. If a previous item was available, PrevItem will return
true (-1 ). Otherwise, PrevItem will return false (0).</longDescription>
  </command>
  <command name="Nextitem">
    <keyword>Nextitem</keyword>
    <fullCommand>Nextitem (Arrayname())</fullCommand>
    <parameters>(Arrayname())</parameters>
    <shortDescription />
    <longDescription>Nextitem will set the specified list array's 'current item' pointer to the item
after the list array's old current item. This allows for 'forwards' processing of a
list array. Nextitem returns a true/false value reflecting whether or not there
actually was a next item available or not. If an item was available, Nextitem will
return true (-1 ). Otherwise, Nextitem will return false (0).</longDescription>
  </command>
  <command name="Firstitem">
    <keyword>Firstitem</keyword>
    <fullCommand>Firstitem (Arrayname())</fullCommand>
    <parameters>(Arrayname())</parameters>
    <shortDescription />
    <longDescription>Executing Firstitem will set the specified list array's 'current item' pointer to
the very first item in the list array. If there are no items in the list array,
Firstitem will return false (0) otherwise, Firstitem will return true (-1).</longDescription>
  </command>
  <command name="Lastitem">
    <keyword>Lastitem</keyword>
    <fullCommand>Lastitem (Arrayname())</fullCommand>
    <parameters>(Arrayname())</parameters>
    <shortDescription />
    <longDescription>Executing Lastitem will set the specified list array's 'current item' pointer to the
very last item in the list array. If there are no items in the list array, Lastitem
will return false (0), otherwise Lastitem will return true (-1).</longDescription>
  </command>
  <command name="Pushitem">
    <keyword>Pushitem</keyword>
    <fullCommand>Pushitem Arrayname()</fullCommand>
    <parameters>Arrayname()</parameters>
    <shortDescription />
    <longDescription>Executing Pushitem causes the specified list array's 'current item' pointer to be
pushed onto an internal stack. This pointer may be later recalled by executing
Popitem. The internal item pointer stack is set for up to 8 'pushes'.</longDescription>
  </command>
  <command name="Popitem">
    <keyword>Popitem</keyword>
    <fullCommand>Popitem Arrayname()</fullCommand>
    <parameters>Arrayname()</parameters>
    <shortDescription />
    <longDescription>Popitem 'pops' or 'recalls' a previously pushed current item pointer for the
specified list array. Arrayname() must match the arrayname of the most recently
executed Pushitem.</longDescription>
  </command>
  <command name="Data">
    <keyword>Data</keyword>
    <fullCommand>Data [.Type] item[,item...]</fullCommand>
    <parameters>[.Type] item[,item...]</parameters>
    <shortDescription />
    <longDescription>The Data statement allows you to include pre-defined values in your programs. These
'data items' may be transferred into variables using the Read statement. When data
is read into variables, the Type of the data being read MUST match the type of the
variable it is being read into.</longDescription>
  </command>
  <command name="Read">
    <keyword>Read</keyword>
    <fullCommand>Read Var[,Var...]</fullCommand>
    <parameters>Var[,Var...]</parameters>
    <shortDescription />
    <longDescription>Read is used to transfer items in Data statements into variables. Data is
transferred sequentially into variables through what is known as a 'date pointer'.
Each time a piece of data is read, the data pointer is incremented to point at the
next piece of data. The data pointer may be set to point to a particular piece of
data using the Restore command.</longDescription>
  </command>
  <command name="Restore">
    <keyword>Restore</keyword>
    <fullCommand>Restore [Program Label]</fullCommand>
    <parameters>[Program Label]</parameters>
    <shortDescription />
    <longDescription>Restore allows you to set Blitz's internal 'data pointer' to a particular piece of
data. after executing a Restore, The first item of data following the specified
Program Label will become the data to be read when the next Read command is
executed. Restore with no parameters will reset the data pointer to the very first
piece of data in the program.</longDescription>
  </command>
  <command name="Defaultinput">
    <keyword>Defaultinput</keyword>
    <fullCommand>Defaultinput</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Detaultinput causes all future Edit$ and Inkey$ functions to receive their input
from the CLI window the Blitz program was run from. This is the default input
channel used when a Blitz program is first run.</longDescription>
  </command>
  <command name="Popinput">
    <keyword>Popinput</keyword>
    <fullCommand>Popinput</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>After input has been re-directed (eg using WindowInput/Filelnput), Popinput may be
used to return the channel to it's previous condition.</longDescription>
  </command>
  <command name="GameB">
    <keyword>GameB</keyword>
    <fullCommand>GameB (Port#)</fullCommand>
    <parameters>(Port#)</parameters>
    <shortDescription />
    <longDescription>GameB returns the button states of CD32 style game controllers. The values of all
buttons pressed are added together to make up the value returned by GameB. To check
a certain button is down a logical AND should be performed, buttonvalue AND
returnvalue will evaluate to 0 if the button is not held down. The button values
are:

.Button     Value

Play/Pause    1
Reverse       2
Forward       4
Green         8
Yellow        16
Red           32
Blue          64.</longDescription>
  </command>
  <command name="ILBMlnfo">
    <keyword>ILBMlnfo</keyword>
    <fullCommand>ILBMlnfo Filename$</fullCommand>
    <parameters>Filename$</parameters>
    <shortDescription />
    <longDescription>ILBMInfo is used to examine an ILBM file. Once ILBMInfo has been executed.
ILBMWidth, ILBMHeight and ILBMDepth may be used to examine properties of the image
contained in the file.</longDescription>
  </command>
  <command name="OLimit">
    <keyword>OLimit</keyword>
    <fullCommand>OLimit (Quick,Low,High)</fullCommand>
    <parameters>(Quick,Low,High)</parameters>
    <shortDescription />
    <longDescription>QLimit is used to limit the range of a quick number. If Quick is greater than or
equal to Low, and less than or equal to High, the value of Quick is returned. If
Quick is less than Low, then Low is returned. If Quick is greater than High, then
High is returned.</longDescription>
  </command>
  <command name="Strip">
    <keyword>Strip</keyword>
    <fullCommand>Strip Lead$ (String$,Expression)</fullCommand>
    <parameters>Lead$ (String$,Expression)</parameters>
    <shortDescription />
    <longDescription>StripLead$ removes all leading occurrences of the ASCII character specified by
Expression from the string String$.</longDescription>
  </command>
  <command name="USEPATH">
    <keyword>USEPATH</keyword>
    <fullCommand>USEPATH Pathtext</fullCommand>
    <parameters>Pathtext</parameters>
    <shortDescription />
    <longDescription>USEPATH allows you to specify a 'shortcut' path when dealing with NEWTYPE variables.
Consider the following lines of code:

aliens()\x=160
aliens()\y=100
aliens()\xs=10
aliens()\ys=-10

USEPATH can be used to save you some typing, like so:

USEPATH aliens()
\x=160
\y=100
\xs=10
\ys=-10

Whenever Blitz encounters a variable starting with the backslash character ('\'), it
simply inserts the current USEPATH text before the backslash.</longDescription>
  </command>
  <command name="BLITZ">
    <keyword>BLITZ</keyword>
    <fullCommand>BLITZ</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>The BLITZ directive is used to enter Blitz mode.

For a full discussion on Amiga/Blitz mode, please refer to the programming chapter
of the Blitz Programmers Guide.</longDescription>
  </command>
  <command name="AMIGA">
    <keyword>AMIGA</keyword>
    <fullCommand>AMIGA</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>The AMIGA directive is used to enter Amiga mode.

For a full discussion on Amiga/Blitz mode, please refer to the programming chapter
of the Blitz Programmers Guide.</longDescription>
  </command>
  <command name="QAMIGA">
    <keyword>QAMIGA</keyword>
    <fullCommand>QAMIGA</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>The QAMIGA directive is used to enter Quick Amiga mode.

For a full discussion on Amiga/Blitz mode, please refer to the programming chapter
of the Blitz Programmers Guide.</longDescription>
  </command>
  <command name="INCLUDE">
    <keyword>INCLUDE</keyword>
    <fullCommand>INCLUDE Filename</fullCommand>
    <parameters>Filename</parameters>
    <shortDescription />
    <longDescription>INCLUDE is a compile time directive which causes the specified file, Filename, to be
compiled as part of the programs object code. The file must be in tokenised form
(de: saved from the Blitz editor) - ascii files may not be INCLUDE'd.

INCDIR may be used to specify a path for Filename.

Filename may be optionally quote enclosed to avoid tokenisation problems.</longDescription>
  </command>
  <command name="XINCLUDE">
    <keyword>XINCLUDE</keyword>
    <fullCommand>XINCLUDE Filename</fullCommand>
    <parameters>Filename</parameters>
    <shortDescription />
    <longDescription>XINCLUDE stands for exclusive include. XINCLUDE works identically to INCLUDE with
the exception that XlNCLUDE'd files are only ever included once. For example, if a
program has 2 XINCLUDE statements with the same filename, only the first XINCLUDE
will have any effect.

INCDIR may be used to specify a path for Filename.

Filename may be optionally quote enclosed to avoid tokenisation problems.</longDescription>
  </command>
  <command name="INCBIN">
    <keyword>INCBIN</keyword>
    <fullCommand>INCBIN Filename</fullCommand>
    <parameters>Filename</parameters>
    <shortDescription />
    <longDescription>INCBIN allows you to include a binary file in your object code. This is mainly of
use to assembler language programmers, as having big chunks of binary data in the
middle of a BASIC program is not really a good idea.

INCDIR may be used to specify an AmigaDos path for Filename.

Filename may be optionally quote enclosed to avoid tokenisation problems.</longDescription>
  </command>
  <command name="INCDIR">
    <keyword>INCDIR</keyword>
    <fullCommand>INCDIR Pathname</fullCommand>
    <parameters>Pathname</parameters>
    <shortDescription />
    <longDescription>The INCDIR command allows you to specify an AmigaDos path to be prefixed to any.
filenames specified by any of INCLUDE, XINCLUDE or INCBIN commands.

Pathname may be optionally quote enclosed to avoid tokenisation problems.</longDescription>
  </command>
  <command name="CNIF">
    <keyword>CNIF</keyword>
    <fullCommand>CNIF Constant Comparison Constant</fullCommand>
    <parameters>Constant Comparison Constant</parameters>
    <shortDescription />
    <longDescription>CNIF allows you to conditionally compile a section of program code based on a
comparison of 2 constants. Comparison should be one of '&amp;lt;', '&amp;gt;', '=', '&amp;lt;&amp;gt;', '&amp;lt;='
or'&amp;gt;='. If the comparison proves to be true, then compiling will continue as normal.
If the comparison proves to be false, then no object code will be generated until a
matching CEND is encountered.</longDescription>
  </command>
  <command name="CEND">
    <keyword>CEND</keyword>
    <fullCommand>CEND</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>CEND marks the end of a block of conditionally compiled code. CEND must always
appear somewhere following a CNIF or CSIF directive.</longDescription>
  </command>
  <command name="CSIF">
    <keyword>CSIF</keyword>
    <fullCommand>CSIF "String" Comparison "String"</fullCommand>
    <parameters>"String" Comparison "String"</parameters>
    <shortDescription />
    <longDescription>CSIF allows you to conditionally compile a section of program code based on a
comparison of 2 literal strings. Comparison should be one of '&amp;lt;', '&amp;gt;', '=', '&amp;lt;&amp;gt;',
'&amp;lt;=' or'&amp;gt;='. Both strings must be quote enclosed literal strings. If the comparison
proves to be true, then compiling will continue as normal. If the comparison proves
to be false, then no object code will be generated until a matching CEND is
encountered.

CSIF is of most use in macros for checking macro parameters.</longDescription>
  </command>
  <command name="CELSE">
    <keyword>CELSE</keyword>
    <fullCommand>CELSE</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>CELSE may be used between a CNIF or CSIF, and a CEND to cause code to be compiled
when a constant comparison proves to be false.</longDescription>
  </command>
  <command name="CERR">
    <keyword>CERR</keyword>
    <fullCommand>CERR Errormessage</fullCommand>
    <parameters>Errormessage</parameters>
    <shortDescription />
    <longDescription>CERR allows a program to generate compile-time error messages. CERR is normally used
in conjunction with macros and conditional compiling to generate errors when
incorrect macro parameters are encountered.</longDescription>
  </command>
  <command name="Macro">
    <keyword>Macro</keyword>
    <fullCommand>Macro Macroname</fullCommand>
    <parameters>Macroname</parameters>
    <shortDescription />
    <longDescription>Macro is used to declare the start of a macro definition. All text following Macro,
up until the next End Macro, will be included in the macro's contents.</longDescription>
  </command>
  <command name="Runerrson">
    <keyword>Runerrson</keyword>
    <fullCommand>Runerrson</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>These two new compiler directives are for enabling and disabling error checking in
different parts of the program, they override the settings in Compiler Options.</longDescription>
  </command>
  <command name="Runerrsoff">
    <keyword>Runerrsoff</keyword>
    <fullCommand>Runerrsoff</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>See description of Runerrson.</longDescription>
  </command>
  <command name="USED">
    <keyword>USED</keyword>
    <fullCommand>USED ObjectName</fullCommand>
    <parameters>ObjectName</parameters>
    <shortDescription />
    <longDescription>Used returns the currently used object number. This is useful for routines which
need to operate on the currently used object, also interrupts should restore
currently used object settings.</longDescription>
  </command>
  <command name="Addr">
    <keyword>Addr</keyword>
    <fullCommand>Addr Objectname(Object#)</fullCommand>
    <parameters>Objectname(Object#)</parameters>
    <shortDescription />
    <longDescription>Addr is a low-level function allowing advanced programmers the ability to find where
a particular Blitz object resides in RAM. An appendix at the end of this manual
lists all Blitz object formats.</longDescription>
  </command>
  <command name="Maximum">
    <keyword>Maximum</keyword>
    <fullCommand>Maximum Objectname</fullCommand>
    <parameters>Objectname</parameters>
    <shortDescription />
    <longDescription>The Maximum function allows a program to determine the 'maximum' setting for a
particular Blitz object. Maximum settings are entered into the OPTIONS requester,
accessed throuh the 'COMPILER' menu of the Blitz editor.</longDescription>
  </command>
  <command name="Inline">
    <keyword>Inline</keyword>
    <fullCommand>Inline</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>:

using PutReg and GetReg, BASIC variables can be exchanged with the 68000's data and
address registers.</longDescription>
  </command>
  <command name="Procedures">
    <keyword>Procedures</keyword>
    <fullCommand>Procedures</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>:

Statements and Functions can contain 100% assembler, parameters are passed in
registers d0..d5 and in the case of Functions the value in d0 is returned to the
caller. The AsmExit commmand is used in place of StatmentReturn or FunctionReturn.</longDescription>
  </command>
  <command name="Libraries">
    <keyword>Libraries</keyword>
    <fullCommand>Libraries</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>:

Actual commands can he added to Blitz using assembler. see the libsdev archive in
the blitzlibs: volume for more information.

Please note that when using assmbler inline and within procedures, address registers
A4-A6 must he preserved. Blitz uses A5 as a glohal variable base. A4 as a local
variable base, and tries to keep A6 from having to be be- loaded too often.

Also note that Absolute Short addressing mode and Short Branches are not supported.</longDescription>
  </command>
  <command name="DCB">
    <keyword>DCB</keyword>
    <fullCommand>DCB [.Size] Repeats,Data</fullCommand>
    <parameters>[.Size] Repeats,Data</parameters>
    <shortDescription />
    <longDescription>DCB stantd for 'define cotistant block' .DCB allows you to insert a repeating series
of the same value into your assembler programs.</longDescription>
  </command>
  <command name="EVEN">
    <keyword>EVEN</keyword>
    <fullCommand>EVEN</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>EVEN allows you to word align B1itz's internal program counter. This may be
necessary if a DC, DCB or DS statement has caused the program counter to be left at
an odd address.</longDescription>
  </command>
  <command name="GetReg">
    <keyword>GetReg</keyword>
    <fullCommand>GetReg 68000 Reg,Expression</fullCommand>
    <parameters>68000 Reg,Expression</parameters>
    <shortDescription />
    <longDescription>GetReg allows you to tranfer the result of a BASIC expressition to a 68000 register.
The result of the expression will first be converted into a long value before being
moved to the data register.

GetReg should only he used to transfer expressions to one of the 8 data registers
(d0-d7).

GetReg will use the stack to temporarily store any registers used in calculation of
the expression.</longDescription>
  </command>
  <command name="PutReg">
    <keyword>PutReg</keyword>
    <fullCommand>PutReg 68000 Reg,Variable</fullCommand>
    <parameters>68000 Reg,Variable</parameters>
    <shortDescription />
    <longDescription>PutReg may he used to transfer a vlue from any 68000 register (d0-d7/a0-a7) into a
BASIC variable. If the specified variable is a string, long, float or quick, then
all 4 bytes from the register will be transferred. If the specified variable is a
word or a byte, then only the relevant low bytes will be transferred.</longDescription>
  </command>
  <command name="SysJsr">
    <keyword>SysJsr</keyword>
    <fullCommand>SysJsr RBoutine</fullCommand>
    <parameters>RBoutine</parameters>
    <shortDescription />
    <longDescription>SysJsr allows you to call any of Blitz's system routines from your own program.
Routine specifies a routine number to call.</longDescription>
  </command>
  <command name="TokeJsr">
    <keyword>TokeJsr</keyword>
    <fullCommand>TokeJsr Token[,Form]</fullCommand>
    <parameters>Token[,Form]</parameters>
    <shortDescription />
    <longDescription>TokeJsr allows you to call any of Blitz's library based routines. Token refers to
either a token number, or an actual token name. Form refers to a particular form of
the token. A full list of all token numbers with their various forms will be
available shortly trom Acid Software.</longDescription>
  </command>
  <command name="ALibJsr">
    <keyword>ALibJsr</keyword>
    <fullCommand>ALibJsr Token[,Form]</fullCommand>
    <parameters>Token[,Form]</parameters>
    <shortDescription />
    <longDescription>ALibJsr is only used when writing Blitz libraries. ALibJsr allows you to call a
routine from another library from within your own library. Please refer to the
Library Writing section of the programmers guide for more information on library
writing.</longDescription>
  </command>
  <command name="BLibJsr">
    <keyword>BLibJsr</keyword>
    <fullCommand>BLibJsr Token[,Form]</fullCommand>
    <parameters>Token[,Form]</parameters>
    <shortDescription />
    <longDescription>BLibJsr is only used when writing Blitz libraries. BLibJsr allows you to call a
routine from another library from within your own library. Please refer to the
Library Writing section of the programmers guide for more information on library
writing.</longDescription>
  </command>
  <command name="AsmExit">
    <keyword>AsmExit</keyword>
    <fullCommand>AsmExit</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>AsmExit is used to exit from functions and statements written in assembler. Remember
also that registers A4-A6 must be preserved in functions and statements written in
assembler.</longDescription>
  </command>
  <command name="Peek$">
    <keyword>Peek$</keyword>
    <fullCommand>Peek$ (Address,length)</fullCommand>
    <parameters>(Address,length)</parameters>
    <shortDescription />
    <longDescription>Peek$ will return a string of characters corresponding to bytes peeked from
consective memory locations starting at Address, and Length characters in length.</longDescription>
  </command>
  <command name="WBStartup">
    <keyword>WBStartup</keyword>
    <fullCommand>WBStartup</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>By executing WBStartup at some point in your program, your program will be given the
ability to run from Workbench. A program run from Workbench which does NOT include
the WBStartup command will promptly crash if an attempt is made to run it from
Workbench.</longDescription>
  </command>
  <command name="CloseEd">
    <keyword>CloseEd</keyword>
    <fullCommand>CloseEd</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>The CloseEd statement will cause the Blitz editor screen to 'close down' when
programs are executed from within Blitz. This may be useful when writing programs
which use a large amount of chip memory, as the editor screen itself occupies about
40K of chip memory.

CloseEd will have no effect on executable files run outside of the Blitz environment.</longDescription>
  </command>
  <command name="NoCli">
    <keyword>NoCli</keyword>
    <fullCommand>NoCli</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>NoCli will prevent the nonnal 'Default Cli' from opening when programs are executed
from within Blitz. NoCli has no effect on executable files run outside of the Blitz
environment.</longDescription>
  </command>
  <command name="Display">
    <keyword>Display</keyword>
    <fullCommand>Display On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription>Display is a blitz mode only command which allows you to 'turn on' or 'turn off' the
entire display. If the display is turned off, the display will appear as a solid
block of colour 0.</longDescription>
  </command>
  <command name="BitMapinput">
    <keyword>BitMapinput</keyword>
    <fullCommand>BitMapinput</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>BitMaplnput is a special command designed to allow you to use Edit$ and Edit in
Blitz mode. To work properly, a BlitzKeys On must have been executed before
BitMapInput. A BitMapOutput must also be executed before any Edit$ or Edit commands
are encountered.</longDescription>
  </command>
  <command name="Clueue">
    <keyword>Clueue</keyword>
    <fullCommand>Clueue Queue#,Max Items</fullCommand>
    <parameters>Queue#,Max Items</parameters>
    <shortDescription />
    <longDescription>The Queue command creates a queue object for use with the QBlit and UnQueue
commands. What is a queue? Well, queues (in the Blitz sense) are used for the
purpose of multi-shape animation. Before going into what a queue is, let's have a
quick look at the basics of animation.

Say you want to get a group of objects flying around the screen. To achieve this,
you will have to construct a loop similar to the following:


Step 1: Start at the first object
Step 2: Erase the object from the display
Step 3: Move the object
Step 4: Draw the object at it's new location on the display
Step 5: If there are any more objects to move, go on to the next object and then go
        to step 2, else...
Step 6: go to step 1


Step 2 is very important, as if it is left out, all the objects will leave trails
behind them! However, it is often very cumbersome to have to erase every object you
wish to move. This is where queues are of use.

Using queues, you can 'remember' all the objects drawn through a loop, then, at the
end of the loop (or at the start of the next loop), erase all the objects
'remembered' from the previous loop. Lets have a look at how this works:


Step 1: Erase all objects remembered in the queue
Step 2: Start at the first object
Step 3: Move the object
Step 4: Draw the object at it's new location, and add it to the end of the queue
Step 5: If there are any objects left to move, go on to the next object, then go to
        step 3; else...
Step 6: Go to step 1


This is achieved quite easily using Blitz's queue system. The UnQueue command
performs step 1, and the QBlit command performs step 4.

Queues purpose is to initialize the actual queue used to remember objects in. Queue
must be told the maximum number of items the queue is capable of remembering, which
is specified in the Max Items parameter.</longDescription>
  </command>
  <command name="Load">
    <keyword>Load</keyword>
    <fullCommand>Load Palette Palette#, Filename$[,Palette Offset]</fullCommand>
    <parameters>Palette Palette#, Filename$[,Palette Offset]</parameters>
    <shortDescription />
    <longDescription>LoadPalette creates and initializes a palette object. Filename$ specifies the name
of an ILBM IFF file containing colour information. If the file contains colour
cycling information, this will also be loaded into the palette object.

An optional Palette Offset may be specified to allow the colour information to be
loaded at a specified point (colour register) in the palette. This is especially
useful in the case of sprite colours, as these must begin at colour register
sixteen.

LoadPalette does not actually change any display colours. Once a palette is loaded,
Use Palette can be used to cause display changes.</longDescription>
  </command>
  <command name="Fadeln">
    <keyword>Fadeln</keyword>
    <fullCommand>Fadeln Palette#[,Rate[,Low Colour, High Colour]]</fullCommand>
    <parameters>Palette#[,Rate[,Low Colour, High Colour]]</parameters>
    <shortDescription />
    <longDescription>Fadein will cause the colour palette of the currently used slice to be 'faded in'
from black up to the RGB values contained in the specified Palette#.

Rate# allows you to control the speed of the fade, with 0 being the fastest fade.
Low Colour and High Colour allow you to control which colour palette registers are
affected by the fade.</longDescription>
  </command>
  <command name="GetMedinstr">
    <keyword>GetMedinstr</keyword>
    <fullCommand>GetMedinstr Channel</fullCommand>
    <parameters>Channel</parameters>
    <shortDescription />
    <longDescription>GetMedInstr returns the current instrument playing through the specified audio
channel.</longDescription>
  </command>
  <command name="Windowinput">
    <keyword>Windowinput</keyword>
    <fullCommand>Windowinput Window#</fullCommand>
    <parameters>Window#</parameters>
    <shortDescription />
    <longDescription>Windowinput will cause any future executions of the Inkey$, Edit$ or Edit functions
to receive their input as keystrokes from the specified window object.

WindowInput is automatically executed when either a window is opened, or Use Window
is executed.

After a window is closed (using Free Window), remember to tell Blitz to get it's
input from somewhere else useful (for example, using another WindowInput command)
before executing another Inkey$, Edit$ or Edit function.</longDescription>
  </command>
  <command name="Flush">
    <keyword>Flush</keyword>
    <fullCommand>Flush Events [IDCMP_Flag]</fullCommand>
    <parameters>Events [IDCMP_Flag]</parameters>
    <shortDescription />
    <longDescription>When window events occur in Blitz, they are automatically 'queued' for you. This
means that if your program is tied up processing one window event while others are
being created, you wont miss out on anything. Any events which may have occured
between executions of WaitEvent or Event will be stored in a queue for later use.
However, there may be situations where you want to ignore this backlog of events.
This is what FlushEvents is for.

Executing FlushEvents with no parameters will completely clear Blitz's internal
event queue, leaving you with no outstanding events. Supplying an IDCMP_Flag
parameter will only clear events of the specified type from the event queue.</longDescription>
  </command>
  <command name="WLine">
    <keyword>WLine</keyword>
    <fullCommand>WLine X1,Y1,X2,Y2[,Xn,Yn..],Colour</fullCommand>
    <parameters>X1,Y1,X2,Y2[,Xn,Yn..],Colour</parameters>
    <shortDescription />
    <longDescription>Wline allows you to draw a line or a series of lines into the currently used window.
The first two sets of coordinates X1,Y1,X2,Y2, specify the start and end points of
the initial line. Any coordinates specified after these initial two, will be the end
points of another line going from the last set of end points, to this set. Colour is
the colour of the line(s) that are to be drawn.</longDescription>
  </command>
  <command name="Gadget">
    <keyword>Gadget</keyword>
    <fullCommand>Gadget Border X,Y,Width,Height</fullCommand>
    <parameters>Border X,Y,Width,Height</parameters>
    <shortDescription />
    <longDescription>The GadgetBorder command may be used to draw a rectangular border into the currently
used window.

Proportional gadgets and shape gadgets do not have borders automatically created tor
them. The GadgetBorder command may be used, once a window is opened, to render
borders around these gadgets.

X,Y, Width and Height refer to the position of the gadget a border is required
around. GadgetBorder will automatically insert spaces between the gadget and the
border. The Borders command may be used to alter the amount of spacing.

Of course, GadgetBorder may be used to draw a border around any arbitary area,
regardless of whether or not that area contains a gadget.</longDescription>
  </command>
  <command name="Subitem">
    <keyword>Subitem</keyword>
    <fullCommand>Subitem MenuList#,Flags,Menu,Item,Subitem,Subitem text$[,Shortcut$]</fullCommand>
    <parameters>MenuList#,Flags,Menu,Item,Subitem,Subitem text$[,Shortcut$]</parameters>
    <shortDescription />
    <longDescription>All menu items may have an optional list of sub menu items attached to them.

To attach a sub menu item to a menu item, you use the SubItem command.

Item specifies the menu item to attach the sub item to.

Subitem refers to the number of the sub menu item to attach. Higher numbered sub
items appear further down a sub item list, with 0 being the topmost sub item. Sub
items should be added in 'top down' order, with sub item 0 being created first.

Subitemtext$ specifies the actual text for the sub item. As with menu items, sub
items may have an optional keyboard shortcut character, specified using the
Shortcut$ parameter.

All other parameters are identical to the MenuItem command.</longDescription>
  </command>
  <command name="SubitemOff">
    <keyword>SubitemOff</keyword>
    <fullCommand>SubitemOff X Offset,Y Offset</fullCommand>
    <parameters>X Offset,Y Offset</parameters>
    <shortDescription />
    <longDescription>SubItemOff allows you to control the relative position of the top of a list of sub
menu items, in relation to their associated menu item.

Whenver a menu item is created which is to have sub menu items, it's a good idea to
append the name of the menu item with the '&amp;gt;&amp;gt;' character. This may be done using
Chr$(187). This gives the user a visual indication that more options are available.

To position the sub menu items correctly so that they appear after the '&amp;gt;&amp;gt;'
character, SubItemOff should be used.</longDescription>
  </command>
  <command name="GTSetinteger">
    <keyword>GTSetinteger</keyword>
    <fullCommand>GTSetinteger GTList#,id,value</fullCommand>
    <parameters>GTList#,id,value</parameters>
    <shortDescription />
    <longDescription>Used with both GTInteger and GTNumber gadgets, GTSetInteger will not only update the
contents of the gadget but redraw it also.</longDescription>
  </command>
  <command name="GTGetinteger">
    <keyword>GTGetinteger</keyword>
    <fullCommand>GTGetinteger GTList#,id</fullCommand>
    <parameters>GTList#,id</parameters>
    <shortDescription />
    <longDescription>Used to read the contents from a GTlnteger gadget.</longDescription>
  </command>
  <command name="GetRexxResult()">
    <keyword>GetRexxResult()</keyword>
    <fullCommand>GetRexxResult() Resultl=GetRexxResult(rexxmsg,ResultNum)</fullCommand>
    <parameters>Resultl=GetRexxResult(rexxmsg,ResultNum)</parameters>
    <shortDescription />
    <longDescription>GetRexxResult extracts either of the two result numbers from the RexxMsg structure.
Care must be taken with this Function to ascertain wether you are dealing with error
codes or a ResultString address.

Basically if result 1 is zero then result 2 will either be zero or contain a
ArgString pointer to the ResultString. This should then be obtained using
GetResultString().

The arguments to GetRexxResult are:

rexxmsg is the LONGWORD address of a RexxMsg structure returned from ARexx.

ResultNum is either 1 or 2 depending on wether you wish to check result 1 or result
2.</longDescription>
  </command>
  <command name="RexxError()">
    <keyword>RexxError()</keyword>
    <fullCommand>RexxError() ErrorString$=RexxError(ErrorCode)</fullCommand>
    <parameters>ErrorString$=RexxError(ErrorCode)</parameters>
    <shortDescription />
    <longDescription>RexxError converts a numerical error code such as you would get from
GetRexxResult(msg,2) into an understandable string error message. If the ErrorCode
is not known to ARexx a string stating so is returned this ensures that this
function will always succeed.</longDescription>
  </command>
  <command name="Quickplay">
    <keyword>Quickplay</keyword>
    <fullCommand>Quickplay On|Off</fullCommand>
    <parameters>On|Off</parameters>
    <shortDescription />
    <longDescription>QuickPlay will alter the way tapes are played using the PlayBack command. If
QuickPlay is enabled by use of an On parameter, then all PlayBack commands will
cause tapes to be played with no delays between actions. This means any pauses which
may be present in a tape (for instance, delays between mouse movements) will be
ignored when it is played back.

QuickPlay Off will return PlayBack to it's default mode of including all tape
pauses. This is sometimes necessary when playing back tapes which must at some point
wait for disk access to finish before continuing.</longDescription>
  </command>
  <command name="ABCD">
    <keyword>ABCD</keyword>
    <fullCommand>ABCD</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Add with extend using BCD.

Usage:
ABCD Dy,Dx
ABCD -(Ay),-(Ax).</longDescription>
  </command>
  <command name="ADD">
    <keyword>ADD</keyword>
    <fullCommand>ADD</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Add binary.

Usage:
ADD&lt;ea&gt;,Dn
ADD Dn,&lt;ea&gt;
ADDA &lt;ea&gt;,An
ADDI #&lt;data&gt;,&lt;ea&gt;
ADDQ #&lt;data&gt;,&lt;ea&gt;.</longDescription>
  </command>
  <command name="ADDX">
    <keyword>ADDX</keyword>
    <fullCommand>ADDX</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Add with Extend.

Usage:
ADDX Dy,Dx
ADDX -(Ay),-(Ax).</longDescription>
  </command>
  <command name="AND">
    <keyword>AND</keyword>
    <fullCommand>AND</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>AND logical.

Usage:
AND &lt;ea&gt;,Dn
AND Dn,&lt;ea&gt;
ANDI #&lt;data&gt;,&lt;ea&gt;.</longDescription>
  </command>
  <command name="AS">
    <keyword>AS</keyword>
    <fullCommand>AS</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Arithmetic Shift Left.

Usage:
ASL Dx,Dy
ASL #&lt;data&gt;,Dy
ASL &lt;ea&gt;.</longDescription>
  </command>
  <command name="ASR">
    <keyword>ASR</keyword>
    <fullCommand>ASR</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Arithmetic Shift Pight.

Usage:
ASR Dx,Dy
ASR #&lt;data&gt;,Dy
ASR &lt;ea&gt;.</longDescription>
  </command>
  <command name="Bcc">
    <keyword>Bcc</keyword>
    <fullCommand>Bcc</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Branch Conditionally.

Usage:
Bcd &lt;label&gt;.</longDescription>
  </command>
  <command name="BCHG">
    <keyword>BCHG</keyword>
    <fullCommand>BCHG</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Test a Bit &amp; Change.

Usage:
BCHG Dn,&lt;ea&gt;
BCHG #&lt;data&gt;,&lt;ea&gt;.</longDescription>
  </command>
  <command name="BCLR">
    <keyword>BCLR</keyword>
    <fullCommand>BCLR</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Test a Bit &amp; Clear.

Usage:
BCLR Dn,&lt;ea&gt;
BCLR #&lt;data&gt;,&lt;ea&gt;.</longDescription>
  </command>
  <command name="BRA">
    <keyword>BRA</keyword>
    <fullCommand>BRA</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Branch Always.

Usage:
BRA &lt;label&gt;.</longDescription>
  </command>
  <command name="BSET">
    <keyword>BSET</keyword>
    <fullCommand>BSET</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Test a Bit &amp; Set.

Usage:
BSET Dn,&lt;ea&gt;
BSET #&lt;data&gt;,&lt;ea&gt;.</longDescription>
  </command>
  <command name="BTST">
    <keyword>BTST</keyword>
    <fullCommand>BTST</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Test a Bit.

Usage:
BTST Dn,&lt;ea&gt;
BTST #&lt;data&gt;,&lt;ea&gt;.</longDescription>
  </command>
  <command name="CHK">
    <keyword>CHK</keyword>
    <fullCommand>CHK</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Check Register Against Bounds.

Usage:
CHK &lt;ea&gt;,Dn.</longDescription>
  </command>
  <command name="CLR">
    <keyword>CLR</keyword>
    <fullCommand>CLR</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Clear an Operand.

Usage:
CLR &lt;ea&gt;.</longDescription>
  </command>
  <command name="CMP">
    <keyword>CMP</keyword>
    <fullCommand>CMP</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Compare.

Usage:
CMP &lt;ea&gt;,Dn
CMPA &lt;ea&gt;,An
CMPI #&lt;data&gt;,&lt;ea&gt;.</longDescription>
  </command>
  <command name="CMPM">
    <keyword>CMPM</keyword>
    <fullCommand>CMPM</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Compare Memory.

Usage:
CMPM (Ay)+,(Ax)+.</longDescription>
  </command>
  <command name="DBcc">
    <keyword>DBcc</keyword>
    <fullCommand>DBcc</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Test Condition, Decrement, and Branch.

Usage:
DBcc Dn,&lt;label&gt;.</longDescription>
  </command>
  <command name="DIVS">
    <keyword>DIVS</keyword>
    <fullCommand>DIVS</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Signed Divide.

Usage:
DIVS &lt;ea&gt;,Dn Data.</longDescription>
  </command>
  <command name="DIVU">
    <keyword>DIVU</keyword>
    <fullCommand>DIVU</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Unsigned Divide.

Usage:
DIVU &lt;ea&gt;,Dn.</longDescription>
  </command>
  <command name="EOR">
    <keyword>EOR</keyword>
    <fullCommand>EOR</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Exclusive OR Logical.

Usage:
EOR Dn,&lt;ea&gt;
EORI #&lt;data&gt;,&lt;ea&gt;.</longDescription>
  </command>
  <command name="EXG">
    <keyword>EXG</keyword>
    <fullCommand>EXG</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Exchange Registers.

Usage:
EXG Rx,Ry.</longDescription>
  </command>
  <command name="EXT">
    <keyword>EXT</keyword>
    <fullCommand>EXT</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Sign Extend.

Usage:
EXT Dn Data.</longDescription>
  </command>
  <command name="ILLEGAL">
    <keyword>ILLEGAL</keyword>
    <fullCommand>ILLEGAL</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Illegal Instruction.

Usage:
ILLEGAL.</longDescription>
  </command>
  <command name="JMP">
    <keyword>JMP</keyword>
    <fullCommand>JMP</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Jump.

Usage:
JMP &lt;ea&gt;.</longDescription>
  </command>
  <command name="JSR">
    <keyword>JSR</keyword>
    <fullCommand>JSR</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Jump to Subroutine.

Usage:
JSR &lt;ea&gt;.</longDescription>
  </command>
  <command name="LEA">
    <keyword>LEA</keyword>
    <fullCommand>LEA</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Load Effective Address.

Usage:
LEA &lt;ea&gt;,An.</longDescription>
  </command>
  <command name="LINK">
    <keyword>LINK</keyword>
    <fullCommand>LINK</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>LINK and Allocate.

Usage:
LINK An,#&lt;displacement&gt;.</longDescription>
  </command>
  <command name="LSL">
    <keyword>LSL</keyword>
    <fullCommand>LSL</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Logical Shift Left.

Usage:
LSL Dx,Dy
LSL #&lt;data&gt;,Dy
LSL &lt;ea&gt;.</longDescription>
  </command>
  <command name="LSR">
    <keyword>LSR</keyword>
    <fullCommand>LSR</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Logical Shift Right.

Usage:
LSP Dx,Dy
LSR #&lt;data&gt;,Dy
LSR &lt;ea&gt;.</longDescription>
  </command>
  <command name="MOVE">
    <keyword>MOVE</keyword>
    <fullCommand>MOVE</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Move Data from Source to Destination.

Usage:
MOVE &lt;ea&gt;,&lt;ea&gt;
MOVEA &lt;ea&gt;,An
MOVEQ #&lt;data&gt;,Dn.</longDescription>
  </command>
  <command name="MOVEM">
    <keyword>MOVEM</keyword>
    <fullCommand>MOVEM</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Move Multiple Registers.

Usage:
MOVEM &lt;register list&gt;,&lt;ea&gt;
MOVEM &lt;ea&gt;,&lt;register list&gt;.</longDescription>
  </command>
  <command name="MOVEP">
    <keyword>MOVEP</keyword>
    <fullCommand>MOVEP</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Move Paripheral.

Usage:
MOVEP DX,d(Ay)
MOVEP d(Ay),x.</longDescription>
  </command>
  <command name="MULS">
    <keyword>MULS</keyword>
    <fullCommand>MULS</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Signed multiple.

Usage:
MULS &lt;ea&gt;,Dn.</longDescription>
  </command>
  <command name="MULU">
    <keyword>MULU</keyword>
    <fullCommand>MULU</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Unsigned Multiple.

Usage:
MUL &lt;ea&gt;,Dn.</longDescription>
  </command>
  <command name="NBCD">
    <keyword>NBCD</keyword>
    <fullCommand>NBCD</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Negate Decimal with Extend.

Usage:
NBCD &lt;ea&gt;.</longDescription>
  </command>
  <command name="NEG">
    <keyword>NEG</keyword>
    <fullCommand>NEG</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Negate.

Usage:
NEG &lt;ea&gt;.</longDescription>
  </command>
  <command name="NEGX">
    <keyword>NEGX</keyword>
    <fullCommand>NEGX</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Negate with Extend.

Usage:
NEGX &lt;ea&gt;.</longDescription>
  </command>
  <command name="NOP">
    <keyword>NOP</keyword>
    <fullCommand>NOP</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>No Operation.

Usage:
NOP.</longDescription>
  </command>
  <command name="NOT">
    <keyword>NOT</keyword>
    <fullCommand>NOT</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Logical Complement.

Usage:
NOT &lt;ea&gt;.</longDescription>
  </command>
  <command name="OR">
    <keyword>OR</keyword>
    <fullCommand>OR</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Inclusive OR Logical.

Usage:
OR &lt;ea&gt;, Dn
OR Dn,&lt;ea&gt;
ORI #&lt;data&gt;,&lt;ea&gt;.</longDescription>
  </command>
  <command name="PEA">
    <keyword>PEA</keyword>
    <fullCommand>PEA</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Push Effective Address.

Usage:
PEA &lt;ea&gt;.</longDescription>
  </command>
  <command name="RESET">
    <keyword>RESET</keyword>
    <fullCommand>RESET</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Reset External Device.

Usage:
RESET.</longDescription>
  </command>
  <command name="ROL">
    <keyword>ROL</keyword>
    <fullCommand>ROL</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Rotate Left (without Extend).

Usage:
ROL Dx,Dy
ROL #&lt;data&gt;,Dn
ROL &lt;ea&gt;.</longDescription>
  </command>
  <command name="ROR">
    <keyword>ROR</keyword>
    <fullCommand>ROR</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Rotate Right (without Extend).

Usage:
ROR Dx,Dy
ROR #&lt;data&gt;,Dn
ROR &lt;ea&gt;.</longDescription>
  </command>
  <command name="ROXL">
    <keyword>ROXL</keyword>
    <fullCommand>ROXL</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Rotate Left with Extend.

Usage:
ROXL Dx,Dy
ROXL #&lt;data&gt;,Dn
ROXL &lt;ea&gt;.</longDescription>
  </command>
  <command name="ROXR">
    <keyword>ROXR</keyword>
    <fullCommand>ROXR</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Rotate Right with Extend.

Usage:
ROXR Dx,Dy
ROXR #&lt;data&gt;, Dn
ROXR &lt;ea&gt;.</longDescription>
  </command>
  <command name="RTE">
    <keyword>RTE</keyword>
    <fullCommand>RTE</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Return from Exception.

Usage:
RTE Data.</longDescription>
  </command>
  <command name="RTR">
    <keyword>RTR</keyword>
    <fullCommand>RTR</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Return and Restore Condition Codes.

Usage:
RTR.</longDescription>
  </command>
  <command name="RTS">
    <keyword>RTS</keyword>
    <fullCommand>RTS</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Return from Subroutine.

Usage:
RTS.</longDescription>
  </command>
  <command name="SBCD">
    <keyword>SBCD</keyword>
    <fullCommand>SBCD</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Subtract Decimal with Extend.

Usage:
SBCD Dy,Dx
SBCD -(Ay),-(Ax).</longDescription>
  </command>
  <command name="Scc">
    <keyword>Scc</keyword>
    <fullCommand>Scc</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Set according to Condition.

Usage:
Scc &lt;ea&gt;.</longDescription>
  </command>
  <command name="STOP">
    <keyword>STOP</keyword>
    <fullCommand>STOP</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Load Status Register and Stop.

Usage:
STOP #xxx.</longDescription>
  </command>
  <command name="SUB">
    <keyword>SUB</keyword>
    <fullCommand>SUB</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Subtract Binary.

Usage:
SUB &lt;ea&gt;,Dn
SUB Dn,&lt;ea&gt;
SUBA &lt;ea&gt;,An
SUBI #&lt;data&gt;,&lt;ea&gt;
SUBQ #&lt;data&gt;,&lt;ea&gt;.</longDescription>
  </command>
  <command name="SUBX">
    <keyword>SUBX</keyword>
    <fullCommand>SUBX</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Subtract with Extend.

Usage:
SUBX Dy,Dx
SUBX -(Ay),-(Ax).</longDescription>
  </command>
  <command name="SWAP">
    <keyword>SWAP</keyword>
    <fullCommand>SWAP</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Swap Register Halves.

Usage:
SWAP Dn.</longDescription>
  </command>
  <command name="TAS">
    <keyword>TAS</keyword>
    <fullCommand>TAS</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Test &amp; Set an Operand.

Usage:
TAS &lt;ea&gt;.</longDescription>
  </command>
  <command name="TRAP">
    <keyword>TRAP</keyword>
    <fullCommand>TRAP</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Trap.

Usage:
TRAP #&lt;vector&gt;.</longDescription>
  </command>
  <command name="TRAPV">
    <keyword>TRAPV</keyword>
    <fullCommand>TRAPV</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Trap an Overflow.

Usage:
TRAPV.</longDescription>
  </command>
  <command name="TST">
    <keyword>TST</keyword>
    <fullCommand>TST</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>Test an Operand.

Usage:
TST &lt;ea&gt;.</longDescription>
  </command>
  <command name="UNLK">
    <keyword>UNLK</keyword>
    <fullCommand>UNLK</fullCommand>
    <parameters>
    </parameters>
    <shortDescription />
    <longDescription>UnLINK.

Usage:
UNLK An Data.</longDescription>
  </command>
  <command name="OMEDVerboseErrors">
    <keyword>OMEDVerboseErrors</keyword>
    <fullCommand>OMEDVerboseErrors</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Do verbose error reports.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDQuietErrors">
    <keyword>OMEDQuietErrors</keyword>
    <fullCommand>OMEDQuietErrors</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Do quiet error reports.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDError">
    <keyword>OMEDError</keyword>
    <fullCommand>OMEDError</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return True/False error status.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDErrorMessage">
    <keyword>OMEDErrorMessage</keyword>
    <fullCommand>OMEDErrorMessage</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Return error message string.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDOn">
    <keyword>OMEDOn</keyword>
    <fullCommand>OMEDOn</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Turn on OMED.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDOff">
    <keyword>OMEDOff</keyword>
    <fullCommand>OMEDOff</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Turn off OMED.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDLoad">
    <keyword>OMEDLoad</keyword>
    <fullCommand>OMEDLoad "filename", bank</fullCommand>
    <parameters>"filename", bank</parameters>
    <shortDescription>Load song from file into chip memory bank.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDLoadFast">
    <keyword>OMEDLoadFast</keyword>
    <fullCommand>OMEDLoadFast "filename",bank</fullCommand>
    <parameters>"filename",bank</parameters>
    <shortDescription>Load song from file into fast memory bank.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDUnload">
    <keyword>OMEDUnload</keyword>
    <fullCommand>OMEDUnload bank</fullCommand>
    <parameters>bank</parameters>
    <shortDescription>Unload MED bank.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDUnloadAll">
    <keyword>OMEDUnloadAll</keyword>
    <fullCommand>OMEDUnloadAll</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Unload all MED banks.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDPlay">
    <keyword>OMEDPlay</keyword>
    <fullCommand>OMEDPlay bank[,song]</fullCommand>
    <parameters>bank[,song]</parameters>
    <shortDescription>Play song and optional sub song.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDStop">
    <keyword>OMEDStop</keyword>
    <fullCommand>OMEDStop</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Stop playing.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDContinue">
    <keyword>OMEDContinue</keyword>
    <fullCommand>OMEDContinue</fullCommand>
    <parameters>
    </parameters>
    <shortDescription>Continue playing.</shortDescription>
    <longDescription />
  </command>
  <command name="OMEDVolume">
    <keyword>OMEDVolume</keyword>
    <fullCommand>OMEDVolume volume</fullCommand>
    <parameters>volume</parameters>
    <shortDescription>Set volume.</shortDescription>
    <longDescription />
  </command>
  <command name="MTPlayFX">
    <keyword>MTPlayFX</keyword>
    <fullCommand>MTPlayFX &amp;sfxStruct.l</fullCommand>
    <parameters>&amp;sfxStruct.l</parameters>
    <shortDescription>Play a sound effect.</shortDescription>
    <longDescription />
  </command>
</bb2doc>